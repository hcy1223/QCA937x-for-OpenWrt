diff -urN hostap_2_4.orig/configurations/tizen.config hostap_2_4/configurations/tizen.config
--- hostap_2_4.orig/configurations/tizen.config	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/configurations/tizen.config	2015-09-24 15:25:20.385038328 +0800
@@ -0,0 +1,553 @@
+# Example wpa_supplicant build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cases, these lines should use += in order not
+# to override previous values of the variables.
+
+
+# Uncomment following two lines and fix the paths if you have installed OpenSSL
+# or GnuTLS in non-default location
+#CFLAGS += -I/usr/local/openssl/include
+#LIBS += -L/usr/local/openssl/lib
+
+# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+# the kerberos files are not in the default include path. Following line can be
+# used to fix build issues on such systems (krb5.h not found).
+#CFLAGS += -I/usr/include/kerberos
+
+# Example configuration for various cross-compilation platforms
+
+#### sveasoft (e.g., for Linksys WRT54G) ######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
+#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
+###############################################################################
+
+#### openwrt (e.g., for Linksys WRT54G) #######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
+#	-I../WRT54GS/release/src/include
+#LIBS = -lssl
+###############################################################################
+
+
+# Driver interface for Host AP driver
+#CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for Agere driver
+#CONFIG_DRIVER_HERMES=y
+# Change include directories to match with the local setup
+#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
+#CFLAGS += -I../../include/wireless
+
+# Driver interface for madwifi driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_MADWIFI=y
+# Set include directory to the madwifi source tree
+#CFLAGS += -I../../madwifi
+
+# Driver interface for ndiswrapper
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_NDISWRAPPER=y
+
+# Driver interface for Atmel driver
+#CONFIG_DRIVER_ATMEL=y
+
+# Driver interface for old Broadcom driver
+# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
+# Linux wireless extensions and does not need (or even work) with the old
+# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
+#CONFIG_DRIVER_BROADCOM=y
+# Example path for wlioctl.h; change to match your configuration
+#CFLAGS += -I/opt/WRT54GS/release/src/include
+
+# Driver interface for Intel ipw2100/2200 driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_IPW=y
+
+# Driver interface for Ralink driver
+#CONFIG_DRIVER_RALINK=y
+
+# Driver interface for generic Linux wireless extensions
+# Note: WEXT is deprecated in the current Linux kernel version and no new
+# functionality is added to it. nl80211-based interface is the new
+# replacement for WEXT and its use allows wpa_supplicant to properly control
+# the driver to improve existing functionality like roaming and to support new
+# functionality.
+CONFIG_DRIVER_WEXT=y
+
+# Driver interface for Linux drivers using the nl80211 kernel interface
+CONFIG_DRIVER_NL80211=y
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+#LIBS_p += -L/usr/local/lib
+#LIBS_c += -L/usr/local/lib
+
+# Driver interface for Windows NDIS
+#CONFIG_DRIVER_NDIS=y
+#CFLAGS += -I/usr/include/w32api/ddk
+#LIBS += -L/usr/local/lib
+# For native build using mingw
+#CONFIG_NATIVE_WINDOWS=y
+# Additional directories for cross-compilation on Linux host for mingw target
+#CFLAGS += -I/opt/mingw/mingw32/include/ddk
+#LIBS += -L/opt/mingw/mingw32/lib
+#CC=mingw32-gcc
+# By default, driver_ndis uses WinPcap for low-level operations. This can be
+# replaced with the following option which replaces WinPcap calls with NDISUIO.
+# However, this requires that WZC is disabled (net stop wzcsvc) before starting
+# wpa_supplicant.
+# CONFIG_USE_NDISUIO=y
+
+# Driver interface for development testing
+#CONFIG_DRIVER_TEST=y
+
+# Driver interface for wired Ethernet drivers
+#CONFIG_DRIVER_WIRED=y
+
+# Driver interface for the Broadcom RoboSwitch family
+#CONFIG_DRIVER_ROBOSWITCH=y
+
+# Driver interface for no driver (e.g., WPS ER only)
+#CONFIG_DRIVER_NONE=y
+
+# Solaris libraries
+#LIBS += -lsocket -ldlpi -lnsl
+#LIBS_c += -lsocket
+
+# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+# included)
+CONFIG_IEEE8021X_EAPOL=y
+
+# EAP-MD5
+CONFIG_EAP_MD5=y
+
+# EAP-MSCHAPv2
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-TLS
+CONFIG_EAP_TLS=y
+
+# EAL-PEAP
+CONFIG_EAP_PEAP=y
+
+# EAP-TTLS
+CONFIG_EAP_TTLS=y
+
+# EAP-FAST
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# EAP-GTC
+CONFIG_EAP_GTC=y
+
+# EAP-OTP
+CONFIG_EAP_OTP=y
+
+# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
+#CONFIG_EAP_SIM=y
+
+# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-PAX
+#CONFIG_EAP_PAX=y
+
+# LEAP
+CONFIG_EAP_LEAP=y
+
+# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
+#CONFIG_EAP_AKA=y
+
+# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
+# This requires CONFIG_EAP_AKA to be enabled, too.
+#CONFIG_EAP_AKA_PRIME=y
+
+# Enable USIM simulator (Milenage) for EAP-AKA
+#CONFIG_USIM_SIMULATOR=y
+
+# EAP-SAKE
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-TNC and related Trusted Network Connect support (experimental)
+#CONFIG_EAP_TNC=y
+
+# Wi-Fi Protected Setup (WPS)
+CONFIG_WPS=y
+# Enable WSC 2.0 support
+CONFIG_WPS2=y
+# Enable WPS external registrar functionality
+#CONFIG_WPS_ER=y
+# Disable credentials for an open network by default when acting as a WPS
+# registrar.
+#CONFIG_WPS_REG_DISABLE_OPEN=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+# engine.
+CONFIG_SMARTCARD=y
+
+# PC/SC interface for smartcards (USIM, GSM SIM)
+# Enable this if EAP-SIM or EAP-AKA is included
+#CONFIG_PCSC=y
+
+# Development testing
+#CONFIG_EAPOL_TEST=y
+
+# Select control interface backend for external programs, e.g, wpa_cli:
+# unix = UNIX domain sockets (default for Linux/*BSD)
+# udp = UDP sockets using localhost (127.0.0.1)
+# named_pipe = Windows Named Pipe (default for Windows)
+# y = use default (backwards compatibility)
+# If this option is commented out, control interface is not included in the
+# build.
+CONFIG_CTRL_IFACE=unix
+
+# Include support for GNU Readline and History Libraries in wpa_cli.
+# When building a wpa_cli binary for distribution, please note that these
+# libraries are licensed under GPL and as such, BSD license may not apply for
+# the resulting binary.
+#CONFIG_READLINE=y
+
+# Include internal line edit mode in wpa_cli. This can be used as a replacement
+# for GNU Readline to provide limited command line editing and history support.
+#CONFIG_WPA_CLI_EDIT=y
+
+# Remove debugging code that is printing out debug message to stdout.
+# This can be used to reduce the size of the wpa_supplicant considerably
+# if debugging code is not needed. The size reduction can be around 35%
+# (e.g., 90 kB).
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
+# 35-50 kB in code size.
+#CONFIG_NO_WPA=y
+
+# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
+# save about 1 kB in code size when building only WPA-Personal (no EAP support)
+# or 6 kB if building for WPA-Enterprise.
+#CONFIG_NO_WPA2=y
+
+# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
+# This option can be used to reduce code size by removing support for
+# converting ASCII passphrases into PSK. If this functionality is removed, the
+# PSK can only be configured as the 64-octet hexstring (e.g., from
+# wpa_passphrase). This saves about 0.5 kB in code size.
+#CONFIG_NO_WPA_PASSPHRASE=y
+
+# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
+# This can be used if ap_scan=1 mode is never enabled.
+#CONFIG_NO_SCAN_PROCESSING=y
+
+# Select configuration backend:
+# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
+#	path is given on command line, not here; this option is just used to
+#	select the backend that allows configuration files to be used)
+# winreg = Windows registry (see win_example.reg for an example)
+CONFIG_BACKEND=file
+
+# Remove configuration write functionality (i.e., to allow the configuration
+# file to be updated based on runtime configuration changes). The runtime
+# configuration can still be changed, the changes are just not going to be
+# persistent over restarts. This option can be used to reduce code size by
+# about 3.5 kB.
+#CONFIG_NO_CONFIG_WRITE=y
+
+# Remove support for configuration blobs to reduce code size by about 1.5 kB.
+#CONFIG_NO_CONFIG_BLOBS=y
+
+# Select program entry point implementation:
+# main = UNIX/POSIX like main() function (default)
+# main_winsvc = Windows service (read parameters from registry)
+# main_none = Very basic example (development use only)
+CONFIG_MAIN=main
+
+# Select wrapper for operatins system and C library specific functions
+# unix = UNIX/POSIX like systems (default)
+# win32 = Windows systems
+# none = Empty template
+CONFIG_OS=unix
+
+# Select event loop implementation
+# eloop = select() loop (default)
+# eloop_win = Windows events and WaitForMultipleObject() loop
+# eloop_none = Empty template
+CONFIG_ELOOP=eloop
+
+# Select layer 2 packet implementation
+# linux = Linux packet socket (default)
+# pcap = libpcap/libdnet/WinPcap
+# freebsd = FreeBSD libpcap
+# winpcap = WinPcap with receive thread
+# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+# none = Empty template
+CONFIG_L2_PACKET=linux
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+# This version is an experimental implementation based on IEEE 802.11w/D1.0
+# draft and is subject to change since the standard has not yet been finalized.
+# Driver support is also needed for IEEE 802.11w.
+#CONFIG_IEEE80211W=y
+
+# Select TLS implementation
+# openssl = OpenSSL (default)
+# gnutls = GnuTLS
+# internal = Internal TLSv1 implementation (experimental)
+# none = Empty template
+CONFIG_TLS=openssl
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
+# can be enabled to get a stronger construction of messages when block ciphers
+# are used. It should be noted that some existing TLS v1.0 -based
+# implementation may not be compatible with TLS v1.1 message (ClientHello is
+# sent prior to negotiating which version will be used)
+#CONFIG_TLSV11=y
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
+# can be enabled to enable use of stronger crypto algorithms. It should be
+# noted that some existing TLS v1.0 -based implementation may not be compatible
+# with TLS v1.2 message (ClientHello is sent prior to negotiating which version
+# will be used)
+#CONFIG_TLSV12=y
+
+# If CONFIG_TLS=internal is used, additional library and include paths are
+# needed for LibTomMath. Alternatively, an integrated, minimal version of
+# LibTomMath can be used. See beginning of libtommath.c for details on benefits
+# and drawbacks of this option.
+#CONFIG_INTERNAL_LIBTOMMATH=y
+#ifndef CONFIG_INTERNAL_LIBTOMMATH
+#LTM_PATH=/usr/src/libtommath-0.39
+#CFLAGS += -I$(LTM_PATH)
+#LIBS += -L$(LTM_PATH)
+#LIBS_p += -L$(LTM_PATH)
+#endif
+# At the cost of about 4 kB of additional binary size, the internal LibTomMath
+# can be configured to include faster routines for exptmod, sqr, and div to
+# speed up DH and RSA calculation considerably
+#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+
+# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
+# This is only for Windows builds and requires WMI-related header files and
+# WbemUuid.Lib from Platform SDK even when building with MinGW.
+#CONFIG_NDIS_EVENTS_INTEGRATED=y
+#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
+
+# Add support for old DBus control interface
+# (fi.epitest.hostap.WPASupplicant)
+#CONFIG_CTRL_IFACE_DBUS=y
+
+# Add support for new DBus control interface
+# (fi.w1.hostap.wpa_supplicant1)
+CONFIG_CTRL_IFACE_DBUS_NEW=y
+
+# Add introspection support for new DBus control interface
+CONFIG_CTRL_IFACE_DBUS_INTRO=y
+
+# Add support for loading EAP methods dynamically as shared libraries.
+# When this option is enabled, each EAP method can be either included
+# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
+# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
+# be loaded in the beginning of the wpa_supplicant configuration file
+# (see load_dynamic_eap parameter in the example file) before being used in
+# the network blocks.
+#
+# Note that some shared parts of EAP methods are included in the main program
+# and in order to be able to use dynamic EAP methods using these parts, the
+# main program must have been build with the EAP method enabled (=y or =dyn).
+# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
+# unless at least one of them was included in the main build to force inclusion
+# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
+# in the main build to be able to load these methods dynamically.
+#
+# Please also note that using dynamic libraries will increase the total binary
+# size. Thus, it may not be the best option for targets that have limited
+# amount of memory/flash.
+#CONFIG_DYNAMIC_EAP_METHODS=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
+CONFIG_DEBUG_FILE=y
+
+# Send debug messages to syslog instead of stdout
+#CONFIG_DEBUG_SYSLOG=y
+# Set syslog facility for debug messages
+#CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
+
+# Enable privilege separation (see README 'Privilege separation' for details)
+#CONFIG_PRIVSEP=y
+
+# Enable mitigation against certain attacks against TKIP by delaying Michael
+# MIC error reports by a random amount of time between 0 and 60 seconds
+#CONFIG_DELAYED_MIC_ERROR_REPORT=y
+
+# Enable tracing code for developer debugging
+# This tracks use of memory allocations and other registrations and reports
+# incorrect use with a backtrace of call (or allocation) location.
+#CONFIG_WPA_TRACE=y
+# For BSD, comment out these.
+#LIBS += -lexecinfo
+#LIBS_p += -lexecinfo
+#LIBS_c += -lexecinfo
+
+# Use libbfd to get more details for developer debugging
+# This enables use of libbfd to get more detailed symbols for the backtraces
+# generated by CONFIG_WPA_TRACE=y.
+#CONFIG_WPA_TRACE_BFD=y
+# For BSD, comment out these.
+#LIBS += -lbfd -liberty -lz
+#LIBS_p += -lbfd -liberty -lz
+#LIBS_c += -lbfd -liberty -lz
+
+# wpa_supplicant depends on strong random number generation being available
+# from the operating system. os_get_random() function is used to fetch random
+# data when needed, e.g., for key generation. On Linux and BSD systems, this
+# works by reading /dev/urandom. It should be noted that the OS entropy pool
+# needs to be properly initialized before wpa_supplicant is started. This is
+# important especially on embedded devices that do not have a hardware random
+# number generator and may by default start up with minimal entropy available
+# for random number generation.
+#
+# As a safety net, wpa_supplicant is by default trying to internally collect
+# additional entropy for generating random data to mix in with the data fetched
+# from the OS. This by itself is not considered to be very strong, but it may
+# help in cases where the system pool is not initialized properly. However, it
+# is very strongly recommended that the system pool is initialized with enough
+# entropy either by using hardware assisted random number generator or by
+# storing state over device reboots.
+#
+# wpa_supplicant can be configured to maintain its own entropy store over
+# restarts to enhance random number generation. This is not perfect, but it is
+# much more secure than using the same sequence of random numbers after every
+# reboot. This can be enabled with -e<entropy file> command line option. The
+# specified file needs to be readable and writable by wpa_supplicant.
+#
+# If the os_get_random() is known to provide strong random data (e.g., on
+# Linux/BSD, the board in question is known to have reliable source of random
+# data from /dev/urandom), the internal wpa_supplicant random pool can be
+# disabled. This will save some in binary size and CPU use. However, this
+# should only be considered for builds that are known to be used on devices
+# that meet the requirements described above.
+#CONFIG_NO_RANDOM_POOL=y
+
+# IEEE 802.11n (High Throughput) support (mainly for AP mode)
+CONFIG_IEEE80211N=y
+
+# Interworking (IEEE 802.11u)
+# This can be used to enable functionality to improve interworking with
+# external networks (GAS/ANQP to learn more about the networks and network
+# selection based on available credentials).
+#CONFIG_INTERWORKING=y
+
+#Additional flags
+CONFIG_LIBNL20=y
+CONFIG_P2P=y
+CONFIG_AP=y
+
+# To enable WFD
+CONFIG_WFD=y
+# To eanble customized WFD feature
+#CONFIG_CUSTOM_WFD=y
+
+#To enable Samsung Wi-Fi Direct static IP feature
+P2P_SKIP_DHCP_ADJUST=y
+
+# To enable WLAN HB
+CONFIG_WLAN_HB=y
+ 
+# To enable WiFi-Discovery
+#CONFIG_WIFI_DISC=y
+
+CONFIG_WPA_CLI_EDIT=y
+
+# To eanble hardware pbc
+#CONFIG_HARDWARE_PBC=y
+
+# To show PHY information via cli status
+CONFIG_PHY_INFO_DISPLAY=y
+
+# To enable debugfs command via cli status
+CONFIG_DEBUGFS_CLI_SUPPORT=y
+
+CONFIG_WIFI_DISPLAY=y
+
+
+## configuration for tizen environment ###
+P2P_LOOSE_ACTION_TOKEN=y
+CONFIG_SAMSUNG_SRID=y
+CONFIG_LOAD_SYSINFO=y
+
+# TIZEN_BOOTING_PERFOMANCE_TEST: To test the execution time at boot time. 
+# Only prints are added.
+TIZEN_BOOTING_PERFOMANCE_TEST=y
+
+# SAMSUNG_P2P_PREKEY: to Enable WPS_SKIP between Samsung Devices
+SAMSUNG_P2P_PREKEY=y
+
+# Enable TDLS support
+CONFIG_TDLS=y
+
+# CONFIG_WFD_TDLS: to Enable Vendor Specific TDLS Connection Management
+CONFIG_WFD_TDLS=y
+
+# TIZEN: Single Tizen Flag for multiple use case
+# 1. Event MSG modification as per MW Requirement
+# 2. TIZEN_PHY_FREQ added to get shared frequency and support KPI
+# 3. TIZEN_WPS_PBC added to notify PBC connection on wlan0 iface
+# 4. Flush by deauth and AP scan avoidance after AP Power off
+TIZEN=y
+
+# TIZEN_CONF_FILE: create default path to fetch configuration file
+TIZEN_CONF_FILE=n
+
+# TIZEN_P2P_DISCONNECT = p2p Disconnect wrapper for backward compatibility
+TIZEN_P2P_DISCONNECT=y
+
+# TIZEN_P2P_LISTEN: p2p listen synchronization when 2 supplicant process are running
+TIZEN_P2P_LISTEN=y
+
+# SAMSUNG_DEBUG_FILE: limit log size and break to multiple files
+SAMSUNG_DEBUG_FILE=y
+
+# SAMSUNG_PREFER_5G: To prefer 5Ghz Frequency if no freq parameter 
+# is passed while p2p connection
+SAMSUNG_PREFER_5G=n
+
+# SAMSUNG_KPI: Key Performance Indicator for wpa_supplicant at runtime 
+SAMSUNG_KPI=n
+
+# SAMSUNG_P2P_GROUP_ADD: To allow MW to configure user selected ssid and passphrase 
+SAMSUNG_P2P_GROUP_ADD=y
+
+#P2P_SAMSUNG_GO_INTENT : To enable requested go intent 
+P2P_SAMSUNG_GO_INTENT=y
diff -urN hostap_2_4.orig/configurations/tizen_hostapd.config hostap_2_4/configurations/tizen_hostapd.config
--- hostap_2_4.orig/configurations/tizen_hostapd.config	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/configurations/tizen_hostapd.config	2015-09-24 15:25:20.385038328 +0800
@@ -0,0 +1,475 @@
+# Example wpa_supplicant build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cases, these lines should use += in order not
+# to override previous values of the variables.
+
+
+# Uncomment following two lines and fix the paths if you have installed OpenSSL
+# or GnuTLS in non-default location
+#CFLAGS += -I/usr/local/openssl/include
+#LIBS += -L/usr/local/openssl/lib
+
+# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+# the kerberos files are not in the default include path. Following line can be
+# used to fix build issues on such systems (krb5.h not found).
+#CFLAGS += -I/usr/include/kerberos
+
+# Example configuration for various cross-compilation platforms
+
+#### sveasoft (e.g., for Linksys WRT54G) ######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
+#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
+###############################################################################
+
+#### openwrt (e.g., for Linksys WRT54G) #######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
+#	-I../WRT54GS/release/src/include
+#LIBS = -lssl
+###############################################################################
+
+
+# Driver interface for Host AP driver
+#CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for Agere driver
+#CONFIG_DRIVER_HERMES=y
+# Change include directories to match with the local setup
+#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
+#CFLAGS += -I../../include/wireless
+
+# Driver interface for madwifi driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_MADWIFI=y
+# Set include directory to the madwifi source tree
+#CFLAGS += -I../../madwifi
+
+# Driver interface for ndiswrapper
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_NDISWRAPPER=y
+
+# Driver interface for Atmel driver
+#CONFIG_DRIVER_ATMEL=y
+
+# Driver interface for old Broadcom driver
+# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
+# Linux wireless extensions and does not need (or even work) with the old
+# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
+#CONFIG_DRIVER_BROADCOM=y
+# Example path for wlioctl.h; change to match your configuration
+#CFLAGS += -I/opt/WRT54GS/release/src/include
+
+# Driver interface for Intel ipw2100/2200 driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_IPW=y
+
+# Driver interface for Ralink driver
+#CONFIG_DRIVER_RALINK=y
+
+# Driver interface for generic Linux wireless extensions
+# Note: WEXT is deprecated in the current Linux kernel version and no new
+# functionality is added to it. nl80211-based interface is the new
+# replacement for WEXT and its use allows wpa_supplicant to properly control
+# the driver to improve existing functionality like roaming and to support new
+# functionality.
+#CONFIG_DRIVER_WEXT=y
+
+# Driver interface for Linux drivers using the nl80211 kernel interface
+CONFIG_DRIVER_NL80211=y
+CONFIG_LIBNL20=y
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+#LIBS_p += -L/usr/local/lib
+#LIBS_c += -L/usr/local/lib
+
+# Driver interface for Windows NDIS
+#CONFIG_DRIVER_NDIS=y
+#CFLAGS += -I/usr/include/w32api/ddk
+#LIBS += -L/usr/local/lib
+# For native build using mingw
+#CONFIG_NATIVE_WINDOWS=y
+# Additional directories for cross-compilation on Linux host for mingw target
+#CFLAGS += -I/opt/mingw/mingw32/include/ddk
+#LIBS += -L/opt/mingw/mingw32/lib
+#CC=mingw32-gcc
+# By default, driver_ndis uses WinPcap for low-level operations. This can be
+# replaced with the following option which replaces WinPcap calls with NDISUIO.
+# However, this requires that WZC is disabled (net stop wzcsvc) before starting
+# wpa_supplicant.
+# CONFIG_USE_NDISUIO=y
+
+# Driver interface for development testing
+#CONFIG_DRIVER_TEST=y
+
+# Driver interface for wired Ethernet drivers
+#CONFIG_DRIVER_WIRED=y
+
+# Driver interface for the Broadcom RoboSwitch family
+#CONFIG_DRIVER_ROBOSWITCH=y
+
+# Driver interface for no driver (e.g., WPS ER only)
+#CONFIG_DRIVER_NONE=y
+
+# Solaris libraries
+#LIBS += -lsocket -ldlpi -lnsl
+#LIBS_c += -lsocket
+
+# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+# included)
+#CONFIG_IEEE8021X_EAPOL=y
+
+# EAP-MD5
+#CONFIG_EAP_MD5=y
+
+# EAP-MSCHAPv2
+#CONFIG_EAP_MSCHAPV2=y
+
+# EAP-TLS
+#CONFIG_EAP_TLS=y
+
+# EAL-PEAP
+#CONFIG_EAP_PEAP=y
+
+# EAP-TTLS
+#CONFIG_EAP_TTLS=y
+
+# EAP-FAST
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# EAP-GTC
+#CONFIG_EAP_GTC=y
+
+# EAP-OTP
+#CONFIG_EAP_OTP=y
+
+# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
+#CONFIG_EAP_SIM=y
+
+# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-PAX
+#CONFIG_EAP_PAX=y
+
+# LEAP
+#CONFIG_EAP_LEAP=y
+
+# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
+#CONFIG_EAP_AKA=y
+
+# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
+# This requires CONFIG_EAP_AKA to be enabled, too.
+#CONFIG_EAP_AKA_PRIME=y
+
+# Enable USIM simulator (Milenage) for EAP-AKA
+#CONFIG_USIM_SIMULATOR=y
+
+# EAP-SAKE
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-TNC and related Trusted Network Connect support (experimental)
+#CONFIG_EAP_TNC=y
+
+# Wi-Fi Protected Setup (WPS)
+CONFIG_WPS=y
+# Enable WSC 2.0 support
+CONFIG_WPS2=y
+# Enable WPS external registrar functionality
+#CONFIG_WPS_ER=y
+# Disable credentials for an open network by default when acting as a WPS
+# registrar.
+#CONFIG_WPS_REG_DISABLE_OPEN=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+#CONFIG_PKCS12=y
+
+# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+# engine.
+#CONFIG_SMARTCARD=y
+
+# PC/SC interface for smartcards (USIM, GSM SIM)
+# Enable this if EAP-SIM or EAP-AKA is included
+#CONFIG_PCSC=y
+
+# Development testing
+#CONFIG_EAPOL_TEST=y
+
+# Select control interface backend for external programs, e.g, wpa_cli:
+# unix = UNIX domain sockets (default for Linux/*BSD)
+# udp = UDP sockets using localhost (127.0.0.1)
+# named_pipe = Windows Named Pipe (default for Windows)
+# y = use default (backwards compatibility)
+# If this option is commented out, control interface is not included in the
+# build.
+CONFIG_CTRL_IFACE=unix
+
+# Include support for GNU Readline and History Libraries in wpa_cli.
+# When building a wpa_cli binary for distribution, please note that these
+# libraries are licensed under GPL and as such, BSD license may not apply for
+# the resulting binary.
+#CONFIG_READLINE=y
+
+# Include internal line edit mode in wpa_cli. This can be used as a replacement
+# for GNU Readline to provide limited command line editing and history support.
+#CONFIG_WPA_CLI_EDIT=y
+
+# Remove debugging code that is printing out debug message to stdout.
+# This can be used to reduce the size of the wpa_supplicant considerably
+# if debugging code is not needed. The size reduction can be around 35%
+# (e.g., 90 kB).
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
+# 35-50 kB in code size.
+#CONFIG_NO_WPA=y
+
+# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
+# save about 1 kB in code size when building only WPA-Personal (no EAP support)
+# or 6 kB if building for WPA-Enterprise.
+#CONFIG_NO_WPA2=y
+
+# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
+# This option can be used to reduce code size by removing support for
+# converting ASCII passphrases into PSK. If this functionality is removed, the
+# PSK can only be configured as the 64-octet hexstring (e.g., from
+# wpa_passphrase). This saves about 0.5 kB in code size.
+#CONFIG_NO_WPA_PASSPHRASE=y
+
+# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
+# This can be used if ap_scan=1 mode is never enabled.
+#CONFIG_NO_SCAN_PROCESSING=y
+
+# Select configuration backend:
+# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
+#	path is given on command line, not here; this option is just used to
+#	select the backend that allows configuration files to be used)
+# winreg = Windows registry (see win_example.reg for an example)
+CONFIG_BACKEND=file
+
+# Remove configuration write functionality (i.e., to allow the configuration
+# file to be updated based on runtime configuration changes). The runtime
+# configuration can still be changed, the changes are just not going to be
+# persistent over restarts. This option can be used to reduce code size by
+# about 3.5 kB.
+#CONFIG_NO_CONFIG_WRITE=y
+
+# Remove support for configuration blobs to reduce code size by about 1.5 kB.
+#CONFIG_NO_CONFIG_BLOBS=y
+
+# Select program entry point implementation:
+# main = UNIX/POSIX like main() function (default)
+# main_winsvc = Windows service (read parameters from registry)
+# main_none = Very basic example (development use only)
+CONFIG_MAIN=main
+
+# Select wrapper for operatins system and C library specific functions
+# unix = UNIX/POSIX like systems (default)
+# win32 = Windows systems
+# none = Empty template
+CONFIG_OS=unix
+
+# Select event loop implementation
+# eloop = select() loop (default)
+# eloop_win = Windows events and WaitForMultipleObject() loop
+# eloop_none = Empty template
+CONFIG_ELOOP=eloop
+
+# Select layer 2 packet implementation
+# linux = Linux packet socket (default)
+# pcap = libpcap/libdnet/WinPcap
+# freebsd = FreeBSD libpcap
+# winpcap = WinPcap with receive thread
+# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+# none = Empty template
+CONFIG_L2_PACKET=linux
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+# This version is an experimental implementation based on IEEE 802.11w/D1.0
+# draft and is subject to change since the standard has not yet been finalized.
+# Driver support is also needed for IEEE 802.11w.
+#CONFIG_IEEE80211W=y
+
+# Select TLS implementation
+# openssl = OpenSSL (default)
+# gnutls = GnuTLS
+# internal = Internal TLSv1 implementation (experimental)
+# none = Empty template
+CONFIG_TLS=openssl
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
+# can be enabled to get a stronger construction of messages when block ciphers
+# are used. It should be noted that some existing TLS v1.0 -based
+# implementation may not be compatible with TLS v1.1 message (ClientHello is
+# sent prior to negotiating which version will be used)
+#CONFIG_TLSV11=y
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
+# can be enabled to enable use of stronger crypto algorithms. It should be
+# noted that some existing TLS v1.0 -based implementation may not be compatible
+# with TLS v1.2 message (ClientHello is sent prior to negotiating which version
+# will be used)
+#CONFIG_TLSV12=y
+
+# If CONFIG_TLS=internal is used, additional library and include paths are
+# needed for LibTomMath. Alternatively, an integrated, minimal version of
+# LibTomMath can be used. See beginning of libtommath.c for details on benefits
+# and drawbacks of this option.
+#CONFIG_INTERNAL_LIBTOMMATH=y
+#ifndef CONFIG_INTERNAL_LIBTOMMATH
+#LTM_PATH=/usr/src/libtommath-0.39
+#CFLAGS += -I$(LTM_PATH)
+#LIBS += -L$(LTM_PATH)
+#LIBS_p += -L$(LTM_PATH)
+#endif
+# At the cost of about 4 kB of additional binary size, the internal LibTomMath
+# can be configured to include faster routines for exptmod, sqr, and div to
+# speed up DH and RSA calculation considerably
+#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+
+# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
+# This is only for Windows builds and requires WMI-related header files and
+# WbemUuid.Lib from Platform SDK even when building with MinGW.
+#CONFIG_NDIS_EVENTS_INTEGRATED=y
+#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
+
+# Add support for old DBus control interface
+# (fi.epitest.hostap.WPASupplicant)
+#CONFIG_CTRL_IFACE_DBUS=y
+
+# Add support for new DBus control interface
+# (fi.w1.hostap.wpa_supplicant1)
+#CONFIG_CTRL_IFACE_DBUS_NEW=y
+
+# Add introspection support for new DBus control interface
+#CONFIG_CTRL_IFACE_DBUS_INTRO=y
+
+# Add support for loading EAP methods dynamically as shared libraries.
+# When this option is enabled, each EAP method can be either included
+# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
+# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
+# be loaded in the beginning of the wpa_supplicant configuration file
+# (see load_dynamic_eap parameter in the example file) before being used in
+# the network blocks.
+#
+# Note that some shared parts of EAP methods are included in the main program
+# and in order to be able to use dynamic EAP methods using these parts, the
+# main program must have been build with the EAP method enabled (=y or =dyn).
+# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
+# unless at least one of them was included in the main build to force inclusion
+# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
+# in the main build to be able to load these methods dynamically.
+#
+# Please also note that using dynamic libraries will increase the total binary
+# size. Thus, it may not be the best option for targets that have limited
+# amount of memory/flash.
+#CONFIG_DYNAMIC_EAP_METHODS=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
+CONFIG_DEBUG_FILE=y
+
+# Send debug messages to syslog instead of stdout
+#CONFIG_DEBUG_SYSLOG=y
+# Set syslog facility for debug messages
+#CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
+
+# Enable privilege separation (see README 'Privilege separation' for details)
+#CONFIG_PRIVSEP=y
+
+# Enable mitigation against certain attacks against TKIP by delaying Michael
+# MIC error reports by a random amount of time between 0 and 60 seconds
+#CONFIG_DELAYED_MIC_ERROR_REPORT=y
+
+# Enable tracing code for developer debugging
+# This tracks use of memory allocations and other registrations and reports
+# incorrect use with a backtrace of call (or allocation) location.
+#CONFIG_WPA_TRACE=y
+# For BSD, comment out these.
+#LIBS += -lexecinfo
+#LIBS_p += -lexecinfo
+#LIBS_c += -lexecinfo
+
+# Use libbfd to get more details for developer debugging
+# This enables use of libbfd to get more detailed symbols for the backtraces
+# generated by CONFIG_WPA_TRACE=y.
+#CONFIG_WPA_TRACE_BFD=y
+# For BSD, comment out these.
+#LIBS += -lbfd -liberty -lz
+#LIBS_p += -lbfd -liberty -lz
+#LIBS_c += -lbfd -liberty -lz
+
+# wpa_supplicant depends on strong random number generation being available
+# from the operating system. os_get_random() function is used to fetch random
+# data when needed, e.g., for key generation. On Linux and BSD systems, this
+# works by reading /dev/urandom. It should be noted that the OS entropy pool
+# needs to be properly initialized before wpa_supplicant is started. This is
+# important especially on embedded devices that do not have a hardware random
+# number generator and may by default start up with minimal entropy available
+# for random number generation.
+#
+# As a safety net, wpa_supplicant is by default trying to internally collect
+# additional entropy for generating random data to mix in with the data fetched
+# from the OS. This by itself is not considered to be very strong, but it may
+# help in cases where the system pool is not initialized properly. However, it
+# is very strongly recommended that the system pool is initialized with enough
+# entropy either by using hardware assisted random number generator or by
+# storing state over device reboots.
+#
+# wpa_supplicant can be configured to maintain its own entropy store over
+# restarts to enhance random number generation. This is not perfect, but it is
+# much more secure than using the same sequence of random numbers after every
+# reboot. This can be enabled with -e<entropy file> command line option. The
+# specified file needs to be readable and writable by wpa_supplicant.
+#
+# If the os_get_random() is known to provide strong random data (e.g., on
+# Linux/BSD, the board in question is known to have reliable source of random
+# data from /dev/urandom), the internal wpa_supplicant random pool can be
+# disabled. This will save some in binary size and CPU use. However, this
+# should only be considered for builds that are known to be used on devices
+# that meet the requirements described above.
+#CONFIG_NO_RANDOM_POOL=y
+
+# IEEE 802.11n (High Throughput) support (mainly for AP mode)
+CONFIG_IEEE80211N=y
+
+# Interworking (IEEE 802.11u)
+# This can be used to enable functionality to improve interworking with
+# external networks (GAS/ANQP to learn more about the networks and network
+# selection based on available credentials).
+#CONFIG_INTERWORKING=y
+
+CONFIG_NO_RADIUS=y
+CONFIG_AP=y
+TIZEN_EXT=y
diff -urN hostap_2_4.orig/configurations/tizen_hostapd_new.config hostap_2_4/configurations/tizen_hostapd_new.config
--- hostap_2_4.orig/configurations/tizen_hostapd_new.config	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/configurations/tizen_hostapd_new.config	2015-09-24 15:25:20.385038328 +0800
@@ -0,0 +1,316 @@
+# Example hostapd build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cass, these lines should use += in order not
+# to override previous values of the variables.
+
+# Driver interface for Host AP driver
+CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for wired authenticator
+#CONFIG_DRIVER_WIRED=y
+
+# Driver interface for drivers using the nl80211 kernel interface
+CONFIG_DRIVER_NL80211=y
+
+# driver_nl80211.c requires libnl. If you are compiling it yourself
+# you may need to point hostapd to your version of libnl.
+#
+#CFLAGS += -I$<path to libnl include files>
+#LIBS += -L$<path to libnl library files>
+
+# Use libnl v2.0 (or 3.0) libraries.
+CONFIG_LIBNL20=y
+
+# Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
+#CONFIG_LIBNL32=y
+
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+#LIBS_p += -L/usr/local/lib
+#LIBS_c += -L/usr/local/lib
+
+# Driver interface for no driver (e.g., RADIUS server only)
+#CONFIG_DRIVER_NONE=y
+
+# IEEE 802.11F/IAPP
+CONFIG_IAPP=y
+
+# WPA2/IEEE 802.11i RSN pre-authentication
+CONFIG_RSN_PREAUTH=y
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+CONFIG_IEEE80211W=y
+
+# Integrated EAP server
+CONFIG_EAP=y
+
+# EAP Re-authentication Protocol (ERP) in integrated EAP server
+CONFIG_ERP=y
+
+# EAP-MD5 for the integrated EAP server
+CONFIG_EAP_MD5=y
+
+# EAP-TLS for the integrated EAP server
+CONFIG_EAP_TLS=y
+
+# EAP-MSCHAPv2 for the integrated EAP server
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-PEAP for the integrated EAP server
+CONFIG_EAP_PEAP=y
+
+# EAP-GTC for the integrated EAP server
+CONFIG_EAP_GTC=y
+
+# EAP-TTLS for the integrated EAP server
+CONFIG_EAP_TTLS=y
+
+# EAP-SIM for the integrated EAP server
+#CONFIG_EAP_SIM=y
+
+# EAP-AKA for the integrated EAP server
+#CONFIG_EAP_AKA=y
+
+# EAP-AKA' for the integrated EAP server
+# This requires CONFIG_EAP_AKA to be enabled, too.
+#CONFIG_EAP_AKA_PRIME=y
+
+# EAP-PAX for the integrated EAP server
+#CONFIG_EAP_PAX=y
+
+# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-pwd for the integrated EAP server (secure authentication with a password)
+#CONFIG_EAP_PWD=y
+
+# EAP-SAKE for the integrated EAP server
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK for the integrated EAP server
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-FAST for the integrated EAP server
+# Note: If OpenSSL is used as the TLS library, OpenSSL 1.0 or newer is needed
+# for EAP-FAST support. Older OpenSSL releases would need to be patched, e.g.,
+# with openssl-0.9.8x-tls-extensions.patch, to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# Wi-Fi Protected Setup (WPS)
+CONFIG_WPS=y
+# Enable UPnP support for external WPS Registrars
+#CONFIG_WPS_UPNP=y
+# Enable WPS support with NFC config method
+#CONFIG_WPS_NFC=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# Trusted Network Connect (EAP-TNC)
+#CONFIG_EAP_TNC=y
+
+# EAP-EKE for the integrated EAP server
+#CONFIG_EAP_EKE=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# RADIUS authentication server. This provides access to the integrated EAP
+# server from external hosts using RADIUS.
+#CONFIG_RADIUS_SERVER=y
+
+# Build IPv6 support for RADIUS operations
+CONFIG_IPV6=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Use the hostapd's IEEE 802.11 authentication (ACL), but without
+# the IEEE 802.11 Management capability (e.g., FreeBSD/net80211)
+#CONFIG_DRIVER_RADIUS_ACL=y
+
+# IEEE 802.11n (High Throughput) support
+CONFIG_IEEE80211N=y
+
+# Wireless Network Management (IEEE Std 802.11v-2011)
+# Note: This is experimental and not complete implementation.
+#CONFIG_WNM=y
+
+# IEEE 802.11ac (Very High Throughput) support
+#CONFIG_IEEE80211AC=y
+
+# Remove debugging code that is printing out debug messages to stdout.
+# This can be used to reduce the size of the hostapd considerably if debugging
+# code is not needed.
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Add support for writing debug log to a file: -f /tmp/hostapd.log
+# Disabled by default.
+CONFIG_DEBUG_FILE=y
+
+# Add support for sending all debug messages (regardless of debug verbosity)
+# to the Linux kernel tracing facility. This helps debug the entire stack by
+# making it easy to record everything happening from the driver up into the
+# same file, e.g., using trace-cmd.
+#CONFIG_DEBUG_LINUX_TRACING=y
+
+# Remove support for RADIUS accounting
+#CONFIG_NO_ACCOUNTING=y
+
+# Remove support for RADIUS
+CONFIG_NO_RADIUS=y
+
+# Remove support for VLANs
+#CONFIG_NO_VLAN=y
+
+# Enable support for fully dynamic VLANs. This enables hostapd to
+# automatically create bridge and VLAN interfaces if necessary.
+#CONFIG_FULL_DYNAMIC_VLAN=y
+
+# Use netlink-based kernel API for VLAN operations instead of ioctl()
+# Note: This requires libnl 3.1 or newer.
+#CONFIG_VLAN_NETLINK=y
+
+# Remove support for dumping internal state through control interface commands
+# This can be used to reduce binary size at the cost of disabling a debugging
+# option.
+#CONFIG_NO_DUMP_STATE=y
+
+# Enable tracing code for developer debugging
+# This tracks use of memory allocations and other registrations and reports
+# incorrect use with a backtrace of call (or allocation) location.
+#CONFIG_WPA_TRACE=y
+# For BSD, comment out these.
+#LIBS += -lexecinfo
+#LIBS_p += -lexecinfo
+#LIBS_c += -lexecinfo
+
+# Use libbfd to get more details for developer debugging
+# This enables use of libbfd to get more detailed symbols for the backtraces
+# generated by CONFIG_WPA_TRACE=y.
+#CONFIG_WPA_TRACE_BFD=y
+# For BSD, comment out these.
+#LIBS += -lbfd -liberty -lz
+#LIBS_p += -lbfd -liberty -lz
+#LIBS_c += -lbfd -liberty -lz
+
+# hostapd depends on strong random number generation being available from the
+# operating system. os_get_random() function is used to fetch random data when
+# needed, e.g., for key generation. On Linux and BSD systems, this works by
+# reading /dev/urandom. It should be noted that the OS entropy pool needs to be
+# properly initialized before hostapd is started. This is important especially
+# on embedded devices that do not have a hardware random number generator and
+# may by default start up with minimal entropy available for random number
+# generation.
+#
+# As a safety net, hostapd is by default trying to internally collect
+# additional entropy for generating random data to mix in with the data
+# fetched from the OS. This by itself is not considered to be very strong, but
+# it may help in cases where the system pool is not initialized properly.
+# However, it is very strongly recommended that the system pool is initialized
+# with enough entropy either by using hardware assisted random number
+# generator or by storing state over device reboots.
+#
+# hostapd can be configured to maintain its own entropy store over restarts to
+# enhance random number generation. This is not perfect, but it is much more
+# secure than using the same sequence of random numbers after every reboot.
+# This can be enabled with -e<entropy file> command line option. The specified
+# file needs to be readable and writable by hostapd.
+#
+# If the os_get_random() is known to provide strong random data (e.g., on
+# Linux/BSD, the board in question is known to have reliable source of random
+# data from /dev/urandom), the internal hostapd random pool can be disabled.
+# This will save some in binary size and CPU use. However, this should only be
+# considered for builds that are known to be used on devices that meet the
+# requirements described above.
+#CONFIG_NO_RANDOM_POOL=y
+
+# Select TLS implementation
+# openssl = OpenSSL (default)
+# gnutls = GnuTLS
+# internal = Internal TLSv1 implementation (experimental)
+# none = Empty template
+CONFIG_TLS=openssl
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
+# can be enabled to get a stronger construction of messages when block ciphers
+# are used.
+#CONFIG_TLSV11=y
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
+# can be enabled to enable use of stronger crypto algorithms.
+#CONFIG_TLSV12=y
+
+# If CONFIG_TLS=internal is used, additional library and include paths are
+# needed for LibTomMath. Alternatively, an integrated, minimal version of
+# LibTomMath can be used. See beginning of libtommath.c for details on benefits
+# and drawbacks of this option.
+#CONFIG_INTERNAL_LIBTOMMATH=y
+#ifndef CONFIG_INTERNAL_LIBTOMMATH
+#LTM_PATH=/usr/src/libtommath-0.39
+#CFLAGS += -I$(LTM_PATH)
+#LIBS += -L$(LTM_PATH)
+#LIBS_p += -L$(LTM_PATH)
+#endif
+# At the cost of about 4 kB of additional binary size, the internal LibTomMath
+# can be configured to include faster routines for exptmod, sqr, and div to
+# speed up DH and RSA calculation considerably
+#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+
+# Interworking (IEEE 802.11u)
+# This can be used to enable functionality to improve interworking with
+# external networks.
+#CONFIG_INTERWORKING=y
+
+# Hotspot 2.0
+#CONFIG_HS20=y
+
+# Enable SQLite database support in hlr_auc_gw, EAP-SIM DB, and eap_user_file
+#CONFIG_SQLITE=y
+
+# Testing options
+# This can be used to enable some testing options (see also the example
+# configuration file) that are really useful only for testing clients that
+# connect to this hostapd. These options allow, for example, to drop a
+# certain percentage of probe requests or auth/(re)assoc frames.
+#
+#CONFIG_TESTING_OPTIONS=y
+
+# Automatic Channel Selection
+# This will allow hostapd to pick the channel automatically when channel is set
+# to "acs_survey" or "0". Eventually, other ACS algorithms can be added in
+# similar way.
+#
+# Automatic selection is currently only done through initialization, later on
+# we hope to do background checks to keep us moving to more ideal channels as
+# time goes by. ACS is currently only supported through the nl80211 driver and
+# your driver must have survey dump capability that is filled by the driver
+# during scanning.
+#
+# You can customize the ACS survey algorithm with the hostapd.conf variable
+# acs_num_scans.
+#
+# Supported ACS drivers:
+# * ath9k
+# * ath5k
+# * ath10k
+#
+# For more details refer to:
+# http://wireless.kernel.org/en/users/Documentation/acs
+#
+#CONFIG_ACS=y
diff -urN hostap_2_4.orig/.gitignore hostap_2_4/.gitignore
--- hostap_2_4.orig/.gitignore	2015-09-24 15:25:20.369038328 +0800
+++ hostap_2_4/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-*.o
-*.d
-*.gcno
-*.gcda
-*.gcov
-*.pyc
-*~
-.config
-tests/hwsim/logs
-wpaspy/build
-wpa_supplicant/eapol_test
-wpa_supplicant/nfc_pw_token
-wpa_supplicant/preauth_test
-wpa_supplicant/wpa_cli
-wpa_supplicant/wpa_passphrase
-wpa_supplicant/wpa_supplicant
-wpa_supplicant/wpa_priv
-wpa_supplicant/wpa_gui/Makefile
-wpa_supplicant/wpa_gui/wpa_gui
-wpa_supplicant/wpa_gui-qt4/Makefile
-wpa_supplicant/wpa_gui-qt4/wpa_gui
-hostapd/hostapd
-hostapd/hostapd_cli
-hostapd/hlr_auc_gw
-hostapd/nt_password_hash
-mac80211_hwsim/tools/hwsim_test
-wlantest/libwlantest.a
-wlantest/test_vectors
-wlantest/wlantest
-wlantest/wlantest_cli
diff -urN hostap_2_4.orig/hostapd/hostapd.conf hostap_2_4/hostapd/hostapd.conf
--- hostap_2_4.orig/hostapd/hostapd.conf	2015-09-24 15:25:20.357038328 +0800
+++ hostap_2_4/hostapd/hostapd.conf	2015-09-24 15:25:20.377038328 +0800
@@ -3,7 +3,8 @@
 
 # AP netdevice name (without 'ap' postfix, i.e., wlan0 uses wlan0ap for
 # management frames with the Host AP driver); wlan0 with many nl80211 drivers
-interface=wlan0
+#interface=wlan0
+interface=p2p0
 
 # In case of atheros and nl80211 driver interfaces, an additional
 # configuration parameter, bridge, may be used to notify hostapd if the
@@ -22,7 +23,7 @@
 # default: hostap). nl80211 is used with all Linux mac80211 drivers.
 # Use driver=none if building hostapd as a standalone RADIUS server that does
 # not control any wireless/wired driver.
-# driver=hostap
+driver=nl80211
 
 # Driver interface parameters (mainly for development testing use)
 # driver_params=<params>
@@ -83,7 +84,7 @@
 ##### IEEE 802.11 related configuration #######################################
 
 # SSID to be used in IEEE 802.11 management frames
-ssid=test
+ssid=[TV]Samsung-AP
 # Alternative formats for configuring SSID
 # (double quoted string, hexdump, printf-escaped string)
 #ssid2="test"
@@ -139,7 +140,7 @@
 # If CONFIG_ACS build option is enabled, the channel can be selected
 # automatically at run time by setting channel=acs_survey or channel=0, both of
 # which will enable the ACS survey based algorithm.
-channel=1
+channel=6
 
 # ACS tuning - Automatic Channel Selection
 # See: http://wireless.kernel.org/en/users/Documentation/acs
@@ -876,7 +877,7 @@
 # authentication with external ACL for MAC addresses, and accounting
 
 # The own IP address of the access point (used as NAS-IP-Address)
-own_ip_addr=127.0.0.1
+#own_ip_addr=127.0.0.1
 
 # Optional NAS-Identifier string for RADIUS messages. When used, this should be
 # a unique to the NAS within the scope of the RADIUS server. For example, a
@@ -1061,7 +1062,7 @@
 # and/or WPA2 (full IEEE 802.11i/RSN):
 # bit0 = WPA
 # bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled)
-#wpa=1
+wpa=2
 
 # WPA pre-shared keys for WPA-PSK. This can be either entered as a 256-bit
 # secret in hex format (64 hex digits), wpa_psk, or as an ASCII passphrase
@@ -1070,7 +1071,7 @@
 # wpa_psk (dot11RSNAConfigPSKValue)
 # wpa_passphrase (dot11RSNAConfigPSKPassPhrase)
 #wpa_psk=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
-#wpa_passphrase=secret passphrase
+wpa_passphrase=12345678
 
 # Optionally, WPA PSKs can be read from a separate text file (containing list
 # of (PSK,MAC address) pairs. This allows more than one PSK to be configured.
@@ -1091,7 +1092,7 @@
 # entries are separated with a space. WPA-PSK-SHA256 and WPA-EAP-SHA256 can be
 # added to enable SHA256-based stronger algorithms.
 # (dot11RSNAConfigAuthenticationSuitesTable)
-#wpa_key_mgmt=WPA-PSK WPA-EAP
+wpa_key_mgmt=WPA-PSK
 
 # Set of accepted cipher suites (encryption algorithms) for pairwise keys
 # (unicast packets). This is a space separated list of algorithms:
@@ -1103,9 +1104,9 @@
 # TKIP will be used as the group cipher.
 # (dot11RSNAConfigPairwiseCiphersTable)
 # Pairwise cipher for WPA (v1) (default: TKIP)
-#wpa_pairwise=TKIP CCMP
+wpa_pairwise=CCMP
 # Pairwise cipher for RSN/WPA2 (default: use wpa_pairwise value)
-#rsn_pairwise=CCMP
+rsn_pairwise=CCMP
 
 # Time interval for rekeying GTK (broadcast/multicast encryption keys) in
 # seconds. (dot11RSNAConfigGroupRekeyTime)
diff -urN hostap_2_4.orig/packaging/dumpwifi.sh hostap_2_4/packaging/dumpwifi.sh
--- hostap_2_4.orig/packaging/dumpwifi.sh	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/packaging/dumpwifi.sh	2015-09-24 15:25:20.377038328 +0800
@@ -0,0 +1,53 @@
+#!/bin/sh
+echo "wpa_supplicant log dump - begin"
+
+USBPATH=/opt/storage/usb
+
+if [ ! -d $USBPATH ]; then
+  echo "USB memory not detected"
+  echo "wpa_supplicant log dump - Fail"
+  exit 0
+fi
+
+USBPATHSDIR=`ls $USBPATH/ | grep sd`
+USBTARGET=""
+
+for target_folder in $USBPATHSDIR; do
+  if [ -d $USBPATH/$target_folder ]; then
+   USBTARGET=$USBPATH/$target_folder
+   break
+  fi
+done
+
+if [ $USBTARGET == $USBPATH ]; then
+  echo "Can not found writeable USB memory"
+  echo "wpa_supplicant log dump - Fail"
+  exit 0
+fi
+
+
+
+echo "$USBTARGET"
+
+
+TEMPDIR=/var/log/temp
+TEMPTARGET=$TEMPDIR/wpa_supplicant
+
+mkdir -p $TEMPTARGET
+
+
+cp -rf /var/log/wpa_* $TEMPTARGET/
+cp -rf /var/log/p2p_* $TEMPTARGET/
+
+cd $TEMPDIR
+
+tar -czf Dumpsupplicant.gz ./wpa_supplicant 
+
+cp -rf Dumpsupplicant.gz $USBTARGET
+
+cd /
+
+rm -rf $TEMPDIR 
+
+echo "wpa_supplicant log dump - End"
+
diff -urN hostap_2_4.orig/packaging/wpa_supplicant.manifest hostap_2_4/packaging/wpa_supplicant.manifest
--- hostap_2_4.orig/packaging/wpa_supplicant.manifest	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/packaging/wpa_supplicant.manifest	2015-09-24 15:25:20.377038328 +0800
@@ -0,0 +1,27 @@
+<manifest>
+	<define>
+		<domain name="wpasupplicant"/>
+		<request>
+			<smack request="dbus" type="rwx"/>
+			<smack request="system::use_internet" type="rw"/>
+		</request>
+		<permit>
+			<smack permit="dbus" type="rwx"/>
+			<smack permit="system::use_internet" type="rw"/>
+		</permit>
+	</define>
+	<assign>
+		<filesystem path="/etc/dbus-1/system.d/wpa_supplicant.conf" label="_"/>
+		<filesystem path="/usr/lib/systemd/system/sysinit.target.wants/wpa_supplicant.service" label="_"/>
+		<filesystem path="/usr/lib/systemd/system/vdtizen-bootseq-idle.target.wants/wpa_supplicant_p2p.service" label="_"/>
+		<filesystem path="/usr/lib/systemd/system/wpa_supplicant.service" label="_"/>
+		<filesystem path="/usr/lib/systemd/system/wpa_supplicant_p2p.service" label="_"/>
+		<filesystem path="/usr/share/doc/wpasupplicant/README.wpa_supplicant.conf.gz" label="_"/>
+		<filesystem path="/etc/rc.d/init.d/wpa_supplicant" label="_" exec_label="none"/>
+		<filesystem path="/etc/rc.d/rc3.d/S62wpasupplicant" label="_" exec_label="none"/>
+		<filesystem path="/etc/rc.d/rc5.d/S62wpasupplicant" label="_" exec_label="none"/>
+	</assign>
+	<request>
+		<domain name="wpasupplicant"/>
+	</request>
+</manifest>
diff -urN hostap_2_4.orig/packaging/wpa_supplicant_p2p.service hostap_2_4/packaging/wpa_supplicant_p2p.service
--- hostap_2_4.orig/packaging/wpa_supplicant_p2p.service	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/packaging/wpa_supplicant_p2p.service	2015-09-24 15:25:20.377038328 +0800
@@ -0,0 +1,11 @@
+[Unit]
+Description=WPA Supplicant daemon
+Before=network.target
+
+[Service]
+EnvironmentFile=-/etc/sysconfig/wpa_supplicant
+ExecStart=/usr/sbin/wpa_supplicant -t -Dnl80211 -dd -c /opt/etc/wifi-direct/p2p_suppl_dtv.conf -g/var/run/wpa_global  -f/opt/var/log/p2p_supplicant.log $OPTIONS
+Restart=always
+
+[Install]
+WantedBy=vdtizen-bootseq-idle.target.wants
diff -urN hostap_2_4.orig/packaging/wpa_supplicant.service hostap_2_4/packaging/wpa_supplicant.service
--- hostap_2_4.orig/packaging/wpa_supplicant.service	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/packaging/wpa_supplicant.service	2015-09-24 15:25:20.377038328 +0800
@@ -0,0 +1,15 @@
+[Unit]
+Description=WPA Supplicant daemon
+Before=network.target
+After=dbus.service
+DefaultDependencies=no
+
+[Service]
+Type=dbus
+BusName=fi.w1.wpa_supplicant1
+EnvironmentFile=-/etc/sysconfig/wpa_supplicant
+ExecStart=/usr/sbin/wpa_supplicant -u -t -dd -O /var/run/wpa_supplicant -f /opt/var/log/wpa_supplicant.log $OPTIONS
+Restart=always
+
+[Install]
+WantedBy=sysinit.target
diff -urN hostap_2_4.orig/packaging/wpasupplicant.spec hostap_2_4/packaging/wpasupplicant.spec
--- hostap_2_4.orig/packaging/wpasupplicant.spec	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/packaging/wpasupplicant.spec	2015-09-24 15:25:20.377038328 +0800
@@ -0,0 +1,96 @@
+Name:	    wpasupplicant
+Summary:    Support for WPA and WPA2 (IEEE 802.11i / RSN)
+Version:    2.4+tv
+Release:    150727
+Group:      System/Network
+License:    BSD license
+Source0:    %{name}-%{version}.tar.gz
+Source1:        wpa_supplicant.service
+Source2:        wpa_supplicant_p2p.service
+Source1001:     wpa_supplicant.manifest
+
+BuildRequires: pkgconfig(openssl)
+BuildRequires: pkgconfig(libssl)
+BuildRequires: pkgconfig(libcrypto)
+BuildRequires: pkgconfig(dbus-1)
+BuildRequires: pkgconfig(libnl-2.0)
+BuildRequires: pkgconfig(capi-system-info)
+BuildRequires: pkgconfig(logger)
+
+Requires(post): /sbin/ldconfig
+Requires(postun): /sbin/ldconfig
+
+%description
+WPA and WPA2 are methods for securing wireless networks, the former
+using IEEE 802.1X, and the latter using IEEE 802.11i. This software
+provides key negotiation with the WPA Authenticator, and controls
+association with IEEE 802.11i networks.
+
+%prep
+%setup -q
+
+%build
+cp %{SOURCE1001} .
+cp -v configurations/tizen.config wpa_supplicant/.config
+cp -v configurations/tizen_hostapd_new.config hostapd/.config
+make %{?_smp_mflags} -C wpa_supplicant all
+make -C hostapd clean
+make %{?_smp_mflags} -C hostapd all
+
+%install
+mkdir -p %{buildroot}%{_sbindir}/systemd/
+mkdir -p %{buildroot}%{_sbindir}/dbus/
+
+cp -v wpa_supplicant/wpa_supplicant %{buildroot}%{_sbindir}/
+cp -v wpa_supplicant/wpa_cli %{buildroot}%{_sbindir}/
+cp -v hostapd/hostapd %{buildroot}%{_sbindir}/
+cp -v hostapd/hostapd_cli %{buildroot}%{_sbindir}/
+cp -v packaging/dumpwifi.sh %{buildroot}%{_sbindir}/
+
+# Configurations
+mkdir -p %{buildroot}%{_sysconfdir}/wpa_supplicant/
+cp -v wpa_supplicant/wpa_supplicant.conf %{buildroot}%{_sysconfdir}/wpa_supplicant/wpa_supplicant.conf
+cp -v hostapd/hostapd.conf %{buildroot}%{_sysconfdir}/wpa_supplicant/hostapd.conf
+
+# D-Bus
+mkdir -p %{buildroot}%{_sysconfdir}/dbus-1/system.d/
+cp wpa_supplicant/dbus/dbus-wpa_supplicant.conf %{buildroot}%{_sysconfdir}/dbus-1/system.d/wpa_supplicant.conf
+mkdir -p %{buildroot}%{_datadir}/dbus-1/services/
+
+# sanitise the example configuration
+mkdir -p %{buildroot}%{_defaultdocdir}/wpasupplicant
+sed 's/^\([^#]\+=.*\|}\)/#\1/' < ./wpa_supplicant/wpa_supplicant.conf | gzip > %{buildroot}%{_defaultdocdir}/wpasupplicant/README.wpa_supplicant.conf.gz
+
+# install systemd service file
+mkdir -p %{buildroot}%{_libdir}/systemd/system
+install -m 0644 %{SOURCE1} %{buildroot}%{_libdir}/systemd/system/
+install -m 0644 %{SOURCE2} %{buildroot}%{_libdir}/systemd/system/
+mkdir -p %{buildroot}%{_libdir}/systemd/system/sysinit.target.wants
+ln -s ../wpa_supplicant.service %{buildroot}%{_libdir}/systemd/system/sysinit.target.wants/wpa_supplicant.service
+mkdir -p %{buildroot}%{_libdir}/systemd/system/vdtizen-bootseq-idle.target.wants
+ln -s ../wpa_supplicant_p2p.service %{buildroot}%{_libdir}/systemd/system/vdtizen-bootseq-idle.target.wants/wpa_supplicant_p2p.service
+
+rm -rf %{buildroot}%{_sbindir}/systemd/
+rm -rf %{buildroot}%{_sbindir}/dbus/
+rm -rf %{buildroot}%{_sbindir}/wpa_passphrase
+
+%post
+/sbin/ldconfig
+
+%postun -p /sbin/ldconfig
+
+
+%files
+%manifest wpa_supplicant.manifest
+%{_sbindir}/wpa_cli
+%{_sbindir}/wpa_supplicant
+%{_sbindir}/hostapd
+%{_sbindir}/hostapd_cli
+%attr(555,-,-) %{_sbindir}/dumpwifi.sh
+%attr(644,-,-) %{_sysconfdir}/dbus-1/system.d/*.conf
+%attr(644,-,-) %{_sysconfdir}/wpa_supplicant/*.conf
+%{_defaultdocdir}/wpasupplicant/README.wpa_supplicant.*
+%{_libdir}/systemd/system/wpa_supplicant.service
+%{_libdir}/systemd/system/wpa_supplicant_p2p.service
+%{_libdir}/systemd/system/sysinit.target.wants/wpa_supplicant.service
+%{_libdir}/systemd/system/vdtizen-bootseq-idle.target.wants/wpa_supplicant_p2p.service
diff -urN hostap_2_4.orig/Release_note hostap_2_4/Release_note
--- hostap_2_4.orig/Release_note	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/Release_note	2015-09-24 15:25:20.385038328 +0800
@@ -0,0 +1,93 @@
+2.4.0.150423 :
+	Opensource wpa_supplicant 2.4 added as Base code
+2.4.0.150423.1:
+	Tizen Build Environment added [packaging/ configurations/]
+	Limit number of p2p interfaces to one [driver_nl80211.c]
+	Adding Release_note for Release traceback info
+2.4.0.150424:
+	Added Flag TIZEN for TIZEN Related changes like Event change etc.
+	Added IPALLOC_IN_EAPOL event messages to notify about IP[HEX Format] to MW
+2.4.0.150504:
+	Added SAMSUNG_P2P_PREKEY for SAMSUNG Supported devices[WPS-SKIP]
+	Although wps_skip is working but MIC is incorrect in 4-way Handshake
+	Some TIZEN related Events added.
+2.4.0.150505:
+	Added Static_IP feature for Samsung devices [SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP]
+2.4.0.150506:
+	Disable SAMSUNG_P2P_PREKEY for now. 4-Way Handshake is failing.
+2.4.0.150507:
+	Break Log files in 2MB chunks upto maximum of 3 files for each wpa_supplicant.log and
+	p2p_supplicant.log files [SAMSUNG_DEBUG_FILE].
+2.4.0.150507.1:
+	Prefer 5Ghz p2p connection when no frequency parameter is passed [SAMSUNG_PREFER_5G]
+2.4.0.150511
+	Added P2P_DISCOONECT ctrl_iface command for backword compatibility in TIZEN TV.
+	P2P_DISCONNECT : to disconnect a connected client.
+2.4.0.150514
+	Broadcom Specific TDLS functionalities added [CONFIG_WFD_TDLS]
+	There is no venor flag, so this code will be enabled for all Vendors but will work 
+	with BRCM driver only. TLDS functionality is supported at firmware level, Supplicant 
+	has very little role in actual connection [decision making]
+2.4.0.150522
+	TIZEN_BOOTING_PERFORMANCE_TEST added to print execution time of connection
+	TIZEN_CONF_FILE is added to force configuration file name to Tizen path
+	TIZEN_WPS_PBC added to provide events and notification on WPS PBC connection of wlan0
+	TIZEN_PHY_FREQ added to provide shared frequency info and to Support KPI calls
+	Meaningfull names of flags are added in wpas2.4
+2.4.0.150525
+	SAMSUNG_KPI flag added. WiFi Direct connecrtion is OK.
+	There seems to be problem with IP allocation. Check before final release.
+2.4.0.150526
+	TIZEN_P2P_LISTEN patch added for p2p_listen/scan co-existance
+	P2P-MCC-REQUIRED event added under TIZEN flag
+2.4.0.150602
+	Added Review Points [Remove extra prints, correct print statements]
+	Prevent bug fixes [thread safety and memory leak]
+2.4.0.150610
+	Integrated SAMSUNG_SRID Changes from 2.1 to 2.4
+	 1. Force Listen channel to 81:1 when save_config is send
+	 2. Add Single channel scan on Invitation
+	 3. Remove group for group already exist case while persistent invitation
+	 4. Interface_disabled check for MW event on calling interfaces command after instant On/Off
+	Prevent fix for usleep in os_unix.c
+	KPI included MSG_INFO correction using #undef and using default debug enums
+2.4.0.150611
+	Fixed Prekey problem. Prekey enabled and working.
+	regulatory domain 125: 165 support added
+	Ignoring PBC Overlap in P2P Provisioning
+	nl80211: Scan trigger retry after 100ms
+	Show all supported channels in Go negotiation packet
+2.4.0.150612
+	Added disable_wps_skip patch for p2p_group_add
+	enabled SAMSUNG_P2P_GROUP_ADD to allow ssid and passphrase in p2p_group_add command
+2.4.0.150617
+	Prevent fixes which was caused during Prekey Integration
+	Disable SAMSUNG_PRFER_5G so as to allow all channels for connection
+2.4.0.150629
+	Requested GO Intent Value Feature added on Control Interface and DBus interface
+	IP_Address signal on dbus for IP in EAPOL feature
+	WPS_PIN get equivalent "Start Get:pin" for DBus
+	MCCRequired Signal on P2P-MCC-Required Event
+2.4.0.150629
+	First Release for TIZEN 2.4
+2.4.1.150702
+	Hostapd intergrated with wpa_supplicant 2.4
+	Conf file updated to work with BRCM driver on p2p interface
+2.4.150707
+	Fixed Dbus configruation
+	Renaming version
+2.4.150709
+	Add listen_stop and resume to handle p2p0 and wlan0 commands are coming at the same time
+2.4.150710
+	Remove DBUS environment value and disable KPI - DF150709-01059
+	Added override socket
+2.4.150714
+	Increase log file size to 10 MB
+	RemoveClient method for p2p on Dbus interface
+	DEDICATED_P2P_DEVICE support
+2.4.150717
+	Added InterfaceAddress in p2p peer
+2.4.150722
+	Modified GroupAdd command with ssid and passphrase
+2.4.150727
+	Added IntendedAddress in p2p peer
diff -urN hostap_2_4.orig/src/ap/sta_info.c hostap_2_4/src/ap/sta_info.c
--- hostap_2_4.orig/src/ap/sta_info.c	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/ap/sta_info.c	2015-09-24 15:25:20.381038328 +0800
@@ -1021,10 +1021,35 @@
 #ifdef CONFIG_P2P
 		if (wpa_auth_get_ip_addr(sta->wpa_sm, ip_addr_buf) == 0) {
 			os_snprintf(ip_addr, sizeof(ip_addr),
+#ifdef TIZEN
+				    /* MW Requires ip address in HEX Format */
+				    " client_ip_addr=0x%02x%02x%02x%02x",
+#else
 				    " ip_addr=%u.%u.%u.%u",
+#endif /* TIZEN */				    
 				    ip_addr_buf[0], ip_addr_buf[1],
 				    ip_addr_buf[2], ip_addr_buf[3]);
 		}
+#ifdef TIZEN
+		/* 
+		* Add Go IP [HEX Format] in AP-STA-CONNECTTED Event to notify  
+        * about static IP of GO.
+		*/
+		if (hapd->conf->ip_addr_go[0] > 0) {
+			char go_ip_addr[32];
+			os_snprintf(go_ip_addr, sizeof(go_ip_addr), " go_ip_addr=0x%02x%02x%02x%02x",
+                                        hapd->conf->ip_addr_go[0],
+                                        hapd->conf->ip_addr_go[1],
+                                        hapd->conf->ip_addr_go[2],
+                                        hapd->conf->ip_addr_go[3]);
+			strncat(ip_addr, go_ip_addr, sizeof(ip_addr)-strlen(ip_addr)-1);
+			{
+				/* Notify on Dbus also */
+				extern void wpas_notify_connected_ip_address(void *msg_ctx, const char *ip_str);
+				wpas_notify_connected_ip_address(hapd->msg_ctx, ip_addr);
+			}
+		}
+#endif /* TIZEN */
 #endif /* CONFIG_P2P */
 
 		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_CONNECTED "%s%s",
diff -urN hostap_2_4.orig/src/common/ieee802_11_common.c hostap_2_4/src/common/ieee802_11_common.c
--- hostap_2_4.orig/src/common/ieee802_11_common.c	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/common/ieee802_11_common.c	2015-09-24 15:25:20.381038328 +0800
@@ -146,6 +146,22 @@
 		}
 		break;
 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        case OUI_SAMSUNG:
+                switch (pos[3]) {
+                case VENDOR_P2P_SKIP_DHCP_OUI_TYPE:
+                        elems->static_ip = pos;
+                        elems->static_ip_len = elen;
+                        break;
+                default:
+                        wpa_printf(MSG_EXCESSIVE, "Unknown Samsung "
+                                   "information element ignored "
+                                   "(type=%d len=%lu)",
+                                   pos[3], (unsigned long) elen);
+                        return -1;
+                }
+                break;
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
 	default:
 		wpa_printf(MSG_EXCESSIVE, "unknown vendor specific "
 			   "information element ignored (vendor OUI "
@@ -764,7 +780,13 @@
 			return -1;
 		return 5000 + 5 * chan;
 	case 124: /* channels 149,153,157,161 */
+		if (chan < 149 || chan > 161)
+			return -1;
+		return 5000 + 5 * chan;
 	case 125: /* channels 149,153,157,161,165,169 */
+		if (chan < 149 || chan > 169)
+			return -1;
+		return 5000 + 5 * chan;
 	case 126: /* channels 149,157; 40 MHz */
 	case 127: /* channels 153,161; 40 MHz */
 		if (chan < 149 || chan > 161)
diff -urN hostap_2_4.orig/src/common/ieee802_11_common.h hostap_2_4/src/common/ieee802_11_common.h
--- hostap_2_4.orig/src/common/ieee802_11_common.h	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/common/ieee802_11_common.h	2015-09-24 15:25:20.381038328 +0800
@@ -48,6 +48,9 @@
 	const u8 *osen;
 	const u8 *ampe;
 	const u8 *mic;
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        const u8 *static_ip;
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
 
 	u8 ssid_len;
 	u8 supp_rates_len;
@@ -83,6 +86,9 @@
 	u8 osen_len;
 	u8 ampe_len;
 	u8 mic_len;
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        u8 static_ip_len;
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
 };
 
 typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;
diff -urN hostap_2_4.orig/src/common/ieee802_11_defs.h hostap_2_4/src/common/ieee802_11_defs.h
--- hostap_2_4.orig/src/common/ieee802_11_defs.h	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/common/ieee802_11_defs.h	2015-09-24 15:25:20.381038328 +0800
@@ -1045,8 +1045,37 @@
 	P2P_ATTR_VENDOR_SPECIFIC = 221
 };
 
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+enum p2p_rgi_id {
+        RGI_VALUE = 0, 
+        RGI_CONFIRM = 1
+};
+#endif
+
 #define P2P_MAX_GO_INTENT 15
 
+#define OUI_SAMSUNG 0x0000f0 /* Samsung OUI */
+
+/* P2P Static IP specific settings */
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+#define SKIP_DHCP_VENDOR_TYPE 0x0000f00a
+#define VENDOR_P2P_SKIP_DHCP_OUI_TYPE 0x0a
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+/* RGI specific settings */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+#define GO_INTENT_REQ_VENDOR_TYPE 0x0000f03e
+#define VENDOR_P2P_GO_INTENT_REQ_OUI_TYPE 0x3e
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
+
+/* PREKEY Specific settings */
+#ifdef SAMSUNG_P2P_PREKEY
+#define PRE_KEY_VENDOR_TYPE 0x0000f011
+#define VENDOR_P2P_PRE_KEY_OUI_TYPE 0x11
+#define PRE_KEY_LENGTH   64
+#endif /*SAMSUNG_P2P_PREKEY */
+
 /* P2P Capability - Device Capability bitmap */
 #define P2P_DEV_CAPAB_SERVICE_DISCOVERY BIT(0)
 #define P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY BIT(1)
diff -urN hostap_2_4.orig/src/common/wpa_ctrl.h hostap_2_4/src/common/wpa_ctrl.h
--- hostap_2_4.orig/src/common/wpa_ctrl.h	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/common/wpa_ctrl.h	2015-09-24 15:25:20.381038328 +0800
@@ -249,6 +249,12 @@
 
 #define AP_CSA_FINISHED "AP-CSA-FINISHED "
 
+#ifdef CONFIG_WFD_TDLS
+#define TDLS_EVENT_PEER_FOUND "TDLS-PEER-FOUND "
+#define TDLS_PEER_CONNECTED "TDLS-PEER-CONNECTED "
+#define TDLS_PEER_DISCONNECTED "TDLS-PEER-DISCONNECTED "
+#endif /* CONFIG_WFD_TDLS */
+
 /* BSS Transition Management Response frame received */
 #define BSS_TM_RESP "BSS-TM-RESP "
 
@@ -297,6 +303,9 @@
 	NUM_VENDOR_ELEM_FRAMES
 };
 
+#ifdef SAMSUNG_P2P_PREKEY
+#define P2P_EVENT_P2P_WPS_SKIP "P2P-WPS-SKIP-STA"
+#endif /* SAMSUNG_P2P_PREKEY */
 
 /* wpa_supplicant/hostapd control interface access */
 
diff -urN hostap_2_4.orig/src/crypto/.gitignore hostap_2_4/src/crypto/.gitignore
--- hostap_2_4.orig/src/crypto/.gitignore	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/crypto/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-libcrypto.a
diff -urN hostap_2_4.orig/src/drivers/driver.h hostap_2_4/src/drivers/driver.h
--- hostap_2_4.orig/src/drivers/driver.h	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/drivers/driver.h	2015-09-24 15:25:20.377038328 +0800
@@ -411,6 +411,12 @@
 	 * wpa_scan_clone_params() and wpa_scan_free_params() get updated with
 	 * matching changes.
 	 */
+#ifdef SAMSUNG_SRID
+	/**
+	 * scan_trigger_failed - Report scan_trigger send_and_recv command fail
+	 */
+	u32 scan_trigger_failed;
+#endif /* SAMSUNG_SRID */	
 };
 
 /**
diff -urN hostap_2_4.orig/src/drivers/driver_nl80211.c hostap_2_4/src/drivers/driver_nl80211.c
--- hostap_2_4.orig/src/drivers/driver_nl80211.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/drivers/driver_nl80211.c	2015-09-24 15:25:20.377038328 +0800
@@ -38,6 +38,14 @@
 #include "rfkill.h"
 #include "driver_nl80211.h"
 
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+#include <sys/prctl.h>
+
+#ifndef PR_TASK_PERF_USER_TRACE
+#define PR_TASK_PERF_USER_TRACE 666
+#endif // PR_TASK_PERF_USER_TRACE
+
+#endif // TIZEN_BOOTING_PERFOMANCE_TEST
 
 #ifndef CONFIG_LIBNL20
 /*
@@ -964,6 +972,18 @@
 		}
 		wpa_printf(MSG_DEBUG, "nl80211: Interface down (%s/%s)",
 			   namebuf, ifname);
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+        {
+		char buf[100];
+		snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+		strncat(buf, namebuf, strlen(namebuf));
+		strncat(buf, ": Interface down", strlen(": Interface down"));
+
+		prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+	}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
+
 		if (os_strcmp(drv->first_bss->ifname, ifname) != 0) {
 			wpa_printf(MSG_DEBUG,
 				   "nl80211: Not the main interface (%s) - do not indicate interface down",
@@ -1027,6 +1047,17 @@
 			}
 
 			wpa_printf(MSG_DEBUG, "nl80211: Interface up");
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+        {
+		char buf[100];
+		snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+		strncat(buf, namebuf, strlen(namebuf));
+		strncat(buf, ": Interface up", strlen(": Interface up"));
+
+		prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+		}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */			
 			drv->if_disabled = 0;
 			wpa_supplicant_event(drv->ctx, EVENT_INTERFACE_ENABLED,
 					     NULL);
@@ -1871,6 +1902,15 @@
 			ret = -1;
 	}
 #endif /* CONFIG_TDLS */
+#ifdef CONFIG_WFD_TDLS
+       /* TDLS Action frame */
+       if (nl80211_register_action_frame(bss, (u8 *) "\x0c", 1) < 0)
+               ret = -1; 
+       /* TDLS Vendor Specific Action Probe response frame */
+       if (nl80211_register_action_frame(bss, (u8 *) "\x7f\x50\x6f\x9a\x05", 5) 
+	   < 0)
+               ret = -1; 
+#endif /*  CONFIG_WFD_TDLS */
 
 	/* FT Action frames */
 	if (nl80211_register_action_frame(bss, (u8 *) "\x06", 1) < 0)
@@ -5005,6 +5045,10 @@
 		capa->extended_capa_mask = drv->extended_capa_mask;
 		capa->extended_capa_len = drv->extended_capa_len;
 	}
+	if (capa->flags & WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE){
+		wpa_printf(MSG_DEBUG, "nl80211: Do not indicate P2P_DEVICE support [FORCEFULLY]");
+		capa->flags &= ~WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE;
+	}
 
 	return 0;
 }
diff -urN hostap_2_4.orig/src/drivers/driver_nl80211_scan.c hostap_2_4/src/drivers/driver_nl80211_scan.c
--- hostap_2_4.orig/src/drivers/driver_nl80211_scan.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/drivers/driver_nl80211_scan.c	2015-09-24 15:25:20.377038328 +0800
@@ -273,8 +273,19 @@
 			/* Restore AP mode when processing scan results */
 			drv->ap_scan_as_station = old_mode;
 			ret = 0;
-		} else
+		} else {
+#ifdef SAMSUNG_SRID
+			/* nl80211: Scan trigger retry after 100ms */
+                        if(params->scan_trigger_failed < 2)
+                        {
+                                params->scan_trigger_failed++;
+                                wpa_printf(MSG_DEBUG, "nl80211: Scan trigger retry after 100ms");
+                                os_sleep(0, 100000);
+                                ret = wpa_driver_nl80211_scan(bss, params);
+                        }
+#endif
 			goto fail;
+		}
 	}
 
 	drv->scan_state = SCAN_REQUESTED;
@@ -296,6 +307,9 @@
 			       drv, drv->ctx);
 
 fail:
+#ifdef SAMSUNG_SRID
+	params->scan_trigger_failed = 0;
+#endif /* SAMSUNG_SRID */	
 	nlmsg_free(msg);
 	return ret;
 }
diff -urN hostap_2_4.orig/src/drivers/drivers.mak hostap_2_4/src/drivers/drivers.mak
--- hostap_2_4.orig/src/drivers/drivers.mak	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/drivers/drivers.mak	2015-09-24 15:25:20.377038328 +0800
@@ -37,9 +37,10 @@
 NEED_RFKILL=y
 
 ifdef CONFIG_LIBNL32
-  DRV_LIBS += -lnl-3
-  DRV_LIBS += -lnl-genl-3
-  DRV_CFLAGS += -DCONFIG_LIBNL20
+  DRV_LIBS += ${INCLUDE_LIBNL32_LIB}
+  DRV_LIBS += ${INCLUDE_LIBNL32_GENL_LIB}
+  DRV_LIBS += -lpthread
+  DRV_CFLAGS += -DCONFIG_LIBNL20 -I${INCLUDE_LIBNL32_HEADER}
   ifdef LIBNL_INC
     DRV_CFLAGS += -I$(LIBNL_INC)
   else
diff -urN hostap_2_4.orig/src/drivers/driver_wext.c hostap_2_4/src/drivers/driver_wext.c
--- hostap_2_4.orig/src/drivers/driver_wext.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/drivers/driver_wext.c	2015-09-24 15:25:20.377038328 +0800
@@ -1864,6 +1864,7 @@
 static void wpa_driver_wext_disconnect(struct wpa_driver_wext_data *drv)
 {
 	struct iwreq iwr;
+	unsigned int seedp = 0;
 	const u8 null_bssid[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
 	u8 ssid[32];
 	int i;
@@ -1908,7 +1909,7 @@
 		 * after deauth/disassoc).
 		 */
 		for (i = 0; i < 32; i++)
-			ssid[i] = rand() & 0xFF;
+			ssid[i] = rand_r(&seedp) & 0xFF; /* Prevent fix for thread safety */
 		if (wpa_driver_wext_set_ssid(drv, ssid, 32) < 0) {
 			wpa_printf(MSG_DEBUG, "WEXT: Failed to set bogus "
 				   "SSID to disconnect");
diff -urN hostap_2_4.orig/src/drivers/.gitignore hostap_2_4/src/drivers/.gitignore
--- hostap_2_4.orig/src/drivers/.gitignore	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/drivers/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1,2 +0,0 @@
-build.wpa_supplicant
-build.hostapd
diff -urN hostap_2_4.orig/src/eap_peer/eap.c hostap_2_4/src/eap_peer/eap.c
--- hostap_2_4.orig/src/eap_peer/eap.c	2015-09-24 15:25:20.369038328 +0800
+++ hostap_2_4/src/eap_peer/eap.c	2015-09-24 15:25:20.385038328 +0800
@@ -2899,6 +2899,10 @@
 
 int eap_is_wps_pbc_enrollee(struct eap_peer_config *conf)
 {
+#ifdef SAMSUNG_P2P_PREKEY
+	if (conf->phase1 != NULL && os_strstr(conf->phase1, "pbc=skip_pbc") != NULL)
+		return 1; /* just using PBC for scan*/
+#endif /* SAMSUNG_P2P_PREKEY */
 	if (conf->identity_len != WSC_ID_ENROLLEE_LEN ||
 	    os_memcmp(conf->identity, WSC_ID_ENROLLEE, WSC_ID_ENROLLEE_LEN))
 		return 0; /* Not a WPS Enrollee */
diff -urN hostap_2_4.orig/src/eap_server/eap_server.c hostap_2_4/src/eap_server/eap_server.c
--- hostap_2_4.orig/src/eap_server/eap_server.c	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/eap_server/eap_server.c	2015-09-24 15:25:20.385038328 +0800
@@ -1549,10 +1549,11 @@
 
 static int eap_sm_nextId(struct eap_sm *sm, int id)
 {
+	unsigned int seedp = 0;
 	if (id < 0) {
 		/* RFC 3748 Ch 4.1: recommended to initialize Identifier with a
 		 * random number */
-		id = rand() & 0xff;
+		id = rand_r(&seedp) & 0xff; /* Prevent fix for thread safe */
 		if (id != sm->lastId)
 			return id;
 	}
diff -urN hostap_2_4.orig/src/KPI/Makefile hostap_2_4/src/KPI/Makefile
--- hostap_2_4.orig/src/KPI/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/src/KPI/Makefile	2015-09-24 15:25:20.385038328 +0800
@@ -0,0 +1,8 @@
+all:
+	@echo Nothing to be made.
+
+clean:
+	rm -f *~ *.o *.d *.gcno *.gcda *.gcov
+
+install:
+	@echo Nothing to be made.
diff -urN hostap_2_4.orig/src/KPI/supplicantkpi.c hostap_2_4/src/KPI/supplicantkpi.c
--- hostap_2_4.orig/src/KPI/supplicantkpi.c	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/src/KPI/supplicantkpi.c	2015-09-24 15:25:20.385038328 +0800
@@ -0,0 +1,190 @@
+#include "supplicantkpi.h"
+#include <sys/msg.h>
+
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+#include <sys/prctl.h>
+
+#ifndef PR_TASK_PERF_USER_TRACE
+#define PR_TASK_PERF_USER_TRACE 666
+#endif // PR_TASK_PERF_USER_TRACE
+
+#endif // TIZEN_BOOTING_PERFOMANCE_TEST
+
+
+static int bRunning = 0;
+int msqid = 0;
+
+int  procmsg(SKpiData* supplicantdata);
+int  sendkpilog(SKpiData* supplicantdata);
+
+void KPI_thread_Stop()
+{
+	SKpiData kpidata;
+
+	kpidata.type = 1;
+	kpidata.eventtype = SUPPLICANT_KPI_EVENT_NONE;
+	os_memset(kpidata.buff, 0, MAX_SKPIDATA_BUFF_SIZE);
+
+	if(msqid != 0)
+	{
+		bRunning = 0;
+		msgsnd(msqid, &kpidata, (sizeof(SKpiData)-sizeof(long)), IPC_NOWAIT);
+		//wpa_printf(MSG_ERROR, "[KPI] kpi thread Stopping");
+	}
+}
+
+
+void *supplicant_rcv_kpi_msg(void *arg)
+{
+	//thread function
+	//message queue needs to be implemented
+
+	SKpiData data;
+
+	if (( msqid = msgget( (key_t)1111, IPC_CREAT|0666)) == -1) {
+		//wpa_printf(MSG_ERROR, "[KPI] msgget() fail");
+		goto kpi_fail;
+	}
+
+	//wpa_printf(MSG_ERROR, "[KPI] kpi thread created");
+
+	bRunning = 1;
+
+	while(bRunning)
+	{
+		if(msgrcv(msqid, &data, sizeof(SKpiData)-sizeof(long), 0, 0) == -1)
+		{
+			//wpa_printf(MSG_ERROR, "[KPI] msgrcv() fail");
+			msqid = 0;
+			goto kpi_fail;
+		}
+		//wpa_printf(MSG_MSGDUMP, "[KPI] msgrcv() got a msg, eventtype: %d buff(%d): %s", data.eventtype, strlen(data.buff), data.buff);
+		os_sleep(3, 0);
+		procmsg(&data);
+
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+		{
+			char buf[1024];
+			os_snprintf(buf, strlen("Send KPI log")+1, "Send KPI log");
+			prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+		}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
+		//do something with received message
+	}
+
+	msqid = 0;
+
+	//wpa_printf(MSG_ERROR, "[KPI] kpi thread terminated");
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+		{
+			char buf[1024];
+			os_snprintf(buf, strlen("Terminate KPI log")+1, "Terminate KPI log");
+			prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+		}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
+kpi_fail:
+	return 0;
+}
+
+int procmsg( SKpiData* supplicantdata){
+
+	switch(supplicantdata->eventtype)
+	{
+		case SUPPLICANT_KPI_EVENT_NONE :
+		{
+			//wpa_printf(MSG_ERROR, "[KPI] KPI_EVENT_NONE error");
+			break;
+		}
+		case SUPPLICANT_KPI_EVENT_WIFI_ENV :
+		{
+			sendkpilog(supplicantdata);
+			break;
+		}
+		default :
+			//wpa_printf(MSG_ERROR, "[KPI] Unknown Event");
+			return -1;
+	}
+
+	return 0;
+}	
+
+int  sendkpilog(SKpiData* supplicantdata)
+{
+	//adding events and set event header
+	char*  eventName = "WIFI_ENV";
+	int eventQueueMax = 30;
+	int eventExpiration = 60;
+	int eventThreshold = 0;
+	int eventLogLevel = 5;
+
+	void* logger;
+
+	//creating CLogger object and setting service configuration
+	char* serviceName="15_wireless";
+	int queueMax = 30;
+	int expiration = 60;
+	int threshold = 0;
+	int logLevel = 10;
+	//char* serverURL = "https://lcprd1.samsungcloudsolution.net/openapi/log/15_wireless"; //product server
+	char* serverURL = "https://lcstg1.samsungcloudsolution.net/openapi/log/15_wireless"; //test server
+
+	//adding logs
+	char* log = "";
+	char* Time = "Time";
+	char* Category = "EV001";
+	char* Value ="150430";
+	char* Desc = (char*)supplicantdata->buff;
+
+	logger = CreateLogger();
+
+	//setenv("DBUS_SYSTEM_BUS_ADDRESS", "kdbus:path=/dev/kdbus/0-kdbus-system/bus", 1);
+	//setenv("DBUS_SESSION_BUS_ADDRESS", "kdbus:path=/dev/kdbus/5000-kdbus/bus", 1);
+
+	if(NULL == logger)
+	{
+		//wpa_printf(MSG_ERROR, "Fail to create logger instance.\n");
+		return -1;
+	}
+
+	if(0 == SetServiceConfInfo(logger,serviceName, queueMax, expiration, threshold, logLevel, serverURL))
+	{
+		//wpa_printf(MSG_ERROR, "Could not set service conf info.\n");
+		goto KPI_END;
+	}
+
+	if (0 == AddEventConfInfo(logger, eventName, eventQueueMax, eventExpiration, eventThreshold, eventLogLevel))
+	{
+		//wpa_printf(MSG_DEBUG, "Fail to AddEventConfInfo.\n");
+		goto KPI_END;
+	}
+
+	if(0 == SetEventHeader(logger, 0))
+	{
+		//wpa_printf(MSG_DEBUG, "Could not set event header\n");
+		goto KPI_END;
+	}
+
+	if (0 == AddEventLog(logger, eventName, Time, Category, Value, Desc))
+	{
+		//wpa_printf(MSG_DEBUG, "Could not add event log\n");
+		goto KPI_END;
+	}
+
+
+	if(0 == AddFullLog(logger, eventName, log))
+	{
+		//wpa_printf(MSG_DEBUG, "Could not add full log\n");
+		goto KPI_END;
+	}
+
+	FlushLog(logger);
+
+KPI_END:
+	DestroyLogger(logger);
+	free(logger);
+
+	//wpa_printf(MSG_ERROR, "[KPI] WIFI_ENV FlushLog(size = %d) done\n", strlen(Desc));
+	
+	return 0;
+}
+
diff -urN hostap_2_4.orig/src/KPI/supplicantkpi.h hostap_2_4/src/KPI/supplicantkpi.h
--- hostap_2_4.orig/src/KPI/supplicantkpi.h	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/src/KPI/supplicantkpi.h	2015-09-24 15:25:20.385038328 +0800
@@ -0,0 +1,29 @@
+#ifndef supplicantKPI_H
+#define supplicantKPI_H
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include <CLogger.h>
+#include <sys/ipc.h>
+
+
+#define MAX_SKPIDATA_SCAN_RESULT_BUFF_SIZE	1024
+#define MAX_SKPIDATA_APINFO_BUFF_SIZE	128
+#define MAX_SKPIDATA_BUFF_SIZE	(MAX_SKPIDATA_APINFO_BUFF_SIZE + MAX_SKPIDATA_SCAN_RESULT_BUFF_SIZE)
+
+typedef struct {
+	long type;
+	int  eventtype;
+	char buff[MAX_SKPIDATA_BUFF_SIZE];
+} SKpiData;
+
+typedef enum {
+	SUPPLICANT_KPI_EVENT_NONE=0,
+	SUPPLICANT_KPI_EVENT_WIFI_ENV
+}supplicantEvent;
+
+
+void *supplicant_rcv_kpi_msg(void *arg);
+void KPI_thread_Stop();
+
+#endif /* supplicantKPI_H */
diff -urN hostap_2_4.orig/src/Makefile hostap_2_4/src/Makefile
--- hostap_2_4.orig/src/Makefile	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/Makefile	2015-09-24 15:25:20.381038328 +0800
@@ -1,4 +1,4 @@
-SUBDIRS=ap common crypto drivers eapol_auth eapol_supp eap_common eap_peer eap_server l2_packet p2p pae radius rsn_supp tls utils wps
+SUBDIRS=ap common crypto drivers eapol_auth eapol_supp eap_common eap_peer eap_server KPI l2_packet p2p pae radius rsn_supp tls utils wps
 
 all:
 	for d in $(SUBDIRS); do [ -d $$d ] && $(MAKE) -C $$d; done
diff -urN hostap_2_4.orig/src/p2p/p2p_build.c hostap_2_4/src/p2p/p2p_build.c
--- hostap_2_4.orig/src/p2p/p2p_build.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/p2p/p2p_build.c	2015-09-24 15:25:20.381038328 +0800
@@ -725,3 +725,59 @@
 
 	return 0;
 }
+
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+void p2p_build_skip_dhcp_ie(struct p2p_data *p2p, struct wpabuf *buf, u32 ip_addr)
+{
+        u8 *len;
+
+        wpabuf_put_u8(buf, WLAN_EID_VENDOR_SPECIFIC);
+        len = wpabuf_put(buf, 1); 
+        wpabuf_put_be24(buf, OUI_SAMSUNG);
+        wpabuf_put_u8(buf, VENDOR_P2P_SKIP_DHCP_OUI_TYPE);
+
+        wpabuf_put_u8(buf, 0); // element type
+        wpabuf_put_be16(buf, 4); // element length
+
+        wpabuf_put_be32(buf, ip_addr);
+
+        wpa_printf(MSG_DEBUG, "P2P: Static IP * --> len (%d) ip: %x", 4, ip_addr);
+
+        p2p_buf_update_ie_hdr(buf, len);
+}
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+void p2p_build_req_go_intent_ie(struct p2p_data *p2p, struct wpabuf *buf, u8 go_intent, int ON_req_go_intent, struct wpabuf * requested_go_intent_attributes)
+{
+        u8 *len;
+
+        wpabuf_put_u8(buf, WLAN_EID_VENDOR_SPECIFIC);
+        len = wpabuf_put(buf, 1); 
+        wpabuf_put_be24(buf, OUI_SAMSUNG);
+        wpabuf_put_u8(buf, VENDOR_P2P_GO_INTENT_REQ_OUI_TYPE);
+        //if(!requested_go_intent_attributes && (ON_req_go_intent == 1 && enable_req_go_intent == 1))
+        if(!requested_go_intent_attributes)
+        {   
+                wpabuf_put_u8(buf, RGI_VALUE); // element type
+                wpabuf_put_be16(buf, 1); // element length //Req Go Intent
+                wpabuf_put_u8(buf, go_intent);
+                wpa_printf(MSG_DEBUG, "P2P: Requested GO Intent * --> len (%d) Req Go INtent: %x", 1, go_intent);
+        }   
+        else{
+                wpabuf_put_u8(buf, RGI_CONFIRM); // element type
+                wpabuf_put_be16(buf, 1); // element length //Req Go Intent
+                if(ON_req_go_intent == 1){ 
+                        wpa_printf(MSG_DEBUG, "P2P: RGI confirm * --> len (%d) confirm: %x", 1, 1); 
+                        wpabuf_put_u8(buf, 1); 
+                }   
+                else{
+                        wpa_printf(MSG_DEBUG, "P2P: RGI confirm * --> len (%d) confirm: %x", 1, 0); 
+                        wpabuf_put_u8(buf, 0); 
+                }   
+        }   
+
+        p2p_buf_update_ie_hdr(buf, len);
+}
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
+
diff -urN hostap_2_4.orig/src/p2p/p2p.c hostap_2_4/src/p2p/p2p.c
--- hostap_2_4.orig/src/p2p/p2p.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/p2p/p2p.c	2015-09-24 15:25:20.381038328 +0800
@@ -165,6 +165,14 @@
 		os_memcpy(p2p->intended_addr, intended_addr, ETH_ALEN);
 }
 
+int p2p_get_intended_addr(struct p2p_data *p2p, const u8 *dev_addr,
+			   u8 *intended_addr) {
+        struct p2p_device *dev = p2p_get_device(p2p, dev_addr);
+        if (dev == NULL || is_zero_ether_addr(dev->intended_addr))
+                return -1;
+        os_memcpy(intended_addr, dev->intended_addr, ETH_ALEN);
+        return 0;
+}
 
 u16 p2p_get_provisioning_info(struct p2p_data *p2p, const u8 *addr)
 {
@@ -273,7 +281,12 @@
 		p2p_dbg(p2p, "p2p_listen command pending already");
 		return;
 	}
-
+#ifdef SAMSUNG_SRID
+	if ((p2p->cfg->reg_class == 255)&&( p2p->cfg->channel == 255)) {
+		p2p_dbg(p2p, "Ignore P2P_LISTEN in DFS channel");
+		return;
+	}
+#endif /* SAMSUNG_SRID */
 	freq = p2p_channel_to_freq(p2p->cfg->reg_class, p2p->cfg->channel);
 	if (freq < 0) {
 		p2p_dbg(p2p, "Unknown regulatory class/channel");
@@ -320,7 +333,12 @@
 	struct wpabuf *ies;
 
 	p2p_dbg(p2p, "Going to listen(only) state");
-
+#ifdef SAMSUNG_SRID
+	if ((p2p->cfg->reg_class == 255)&&( p2p->cfg->channel == 255)) {
+		p2p_dbg(p2p, "Ignore P2P_LISTEN in DFS channel");
+		return -1;
+	}
+#endif /* SAMSUNG_SRID */
 	if (p2p->pending_listen_freq) {
 		/* We have a pending p2p_listen request */
 		p2p_dbg(p2p, "p2p_listen command pending already");
@@ -1796,7 +1814,12 @@
 					       p2p->op_channel);
 		os_memcpy(res.ssid, p2p->ssid, p2p->ssid_len);
 		res.ssid_len = p2p->ssid_len;
+#ifdef SAMSUNG_P2P_PREKEY
+		os_memset(res.passphrase , 0 , sizeof(res.passphrase));
+		p2p_get_hash_prekey(p2p->cfg->pre_Sendpassphrase , res.passphrase , p2p->cfg->passphrase_len);
+#else
 		p2p_random(res.passphrase, p2p->cfg->passphrase_len);
+#endif /* SAMSUNG_P2P_PREKEY */
 	} else {
 		res.freq = peer->oper_freq;
 		if (p2p->ssid_len) {
@@ -2843,6 +2866,12 @@
 			p2p->cfg->num_pref_chan = 0;
 	}
 
+#ifdef SAMSUNG_P2P_PREKEY
+	p2p->cfg->isPreKey = cfg->isPreKey;
+	os_memcpy(p2p->cfg->pre_Recvpassphrase , cfg->pre_Recvpassphrase , sizeof(cfg->pre_Recvpassphrase));
+	os_memcpy(p2p->cfg->pre_Sendpassphrase , cfg->pre_Sendpassphrase , sizeof(cfg->pre_Sendpassphrase));
+#endif /* SAMSUNG_P2P_PREKEY */
+
 	p2ps_gen_hash(p2p, P2PS_WILD_HASH_STR, p2p->wild_card_hash);
 
 	p2p->min_disc_int = 1;
@@ -4576,8 +4605,14 @@
 int p2p_set_listen_channel(struct p2p_data *p2p, u8 reg_class, u8 channel,
 			   u8 forced)
 {
-	if (p2p_channel_to_freq(reg_class, channel) < 0)
+	if (p2p_channel_to_freq(reg_class, channel) < 0) {
+#ifdef SAMSUNG_SRID
+		p2p_dbg(p2p, "Set Listen channel: fail unknown channel");
+		p2p->cfg->reg_class = -1;
+		p2p->cfg->channel = -1;
+#endif /* SAMSUNG_SRID */
 		return -1;
+	}
 
 	/*
 	 * Listen channel was set in configuration or set by control interface;
@@ -4860,6 +4895,23 @@
 	return &dev->info;
 }
 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+void p2p_set_static_ip(struct p2p_data *p2p, u32 static_ip)
+{
+        //wpa_printf(MSG_DEBUG, "P2P: Set static_ip: %x", static_ip);
+        //wpa_msg(p2p->cfg->msg_ctx, MSG_DEBUG, "P2P: Set static_ip: %x", static_ip);
+        p2p->cfg->static_ip = static_ip;
+}
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+void p2p_set_req_go_intent(struct p2p_data *p2p, u8 req_go_intent)
+{
+        wpa_printf(MSG_DEBUG, "P2P: Set requested_go_intent %x", req_go_intent);
+        p2p->cfg->requested_go_intent = req_go_intent;
+}
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
 
 int p2p_in_progress(struct p2p_data *p2p)
 {
@@ -5069,6 +5121,66 @@
 	p2p->cfg->debug_print(p2p->cfg->cb_ctx, MSG_ERROR, buf);
 }
 
+#ifdef SAMSUNG_P2P_PREKEY
+#include "crypto/sha1.h"
+
+char fix_p2p_prekey[64] = {
+        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
+        0x67, 0xc6, 0x69, 0x73, 0x51, 0xff, 0x4a, 0xec,
+        0x53, 0x41, 0x4d, 0xab, 0x53, 0x55, 0x4e, 0x47,
+        0x7c, 0x57, 0x49, 0x46, 0x49, 0xe8, 0xe7, 0x8d,
+        0x76, 0x5a, 0x2e, 0x43, 0x53, 0x4b, 0xc9, 0x9a,
+        0x66, 0x32, 0x0d, 0xb7, 0x4a, 0x4d, 0x43, 0x5a,
+        0x25, 0x5d, 0x05, 0x17, 0x58, 0x53, 0x42, 0x48,
+        0xab, 0xb2, 0xcd, 0xc6, 0x9b, 0xb4, 0x54, 0x11 
+
+};
+char fix_p2p_hash_init[32] = {
+        0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
+        0x76, 0x5a, 0x2e, 0x63, 0x33, 0x9f, 0xc9, 0x9a,
+        0x66, 0x32, 0x0d, 0xb7, 0x31, 0x58, 0xa3, 0x5a,
+        0x25, 0x5d, 0x05, 0x17, 0x58, 0xe9, 0x5e, 0xd4 
+};
+
+void p2p_set_check_prekey_out(char passphrase[64] , char out_passphrase[64])
+{
+        int i;
+
+        for(i=0;i<64;i++) {
+                out_passphrase[i] = passphrase[i] ^ fix_p2p_prekey[i];
+        }
+}
+
+void p2p_get_hash_prekey(char passphrase[PRE_KEY_LENGTH], char changeKey[] , int len)
+{
+        u8 hash_vlue[64];
+        int i=0;
+        u8 letters = 'Z' - 'A' + 1;
+        u8 numbers = 10;
+        u8 val;
+
+        if(pbkdf2_sha1((const char*)passphrase, (const u8 *) fix_p2p_hash_init, 32, 4096,
+                                (u8 *)hash_vlue, len) == 0) {
+                /* Character set: 'A'-'Z', 'a'-'z', '0'-'9' */
+                for (i=0;i<len;i++) {
+                        val = hash_vlue[i];
+                        val %= 2 * letters + numbers;
+                        if (val < letters)
+                                changeKey[i] = 'A' + val;
+                        else if (val < 2 * letters)
+                                changeKey[i] = 'a' + (val - letters);
+                        else
+                                changeKey[i] = '0' + (val - 2 * letters);
+                }
+        }
+        else {
+                for (i=0;i<len;i++) {
+                        changeKey[i] = passphrase[i];
+                }
+        }
+
+}
+#endif /*SAMSUNG_P2P_PREKEY */
 
 void p2p_loop_on_known_peers(struct p2p_data *p2p,
 			     void (*peer_callback)(struct p2p_peer_info *peer,
diff -urN hostap_2_4.orig/src/p2p/p2p_go_neg.c hostap_2_4/src/p2p/p2p_go_neg.c
--- hostap_2_4.orig/src/p2p/p2p_go_neg.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/p2p/p2p_go_neg.c	2015-09-24 15:25:20.381038328 +0800
@@ -322,10 +322,20 @@
 	p2p_buf_add_intended_addr(buf, p2p->intended_addr);
 	if (status || peer == NULL) {
 		p2p_buf_add_channel_list(buf, p2p->cfg->country,
+#ifdef SAMSUNG_SRID
+		/* Show all supported channels in Go negotiation packet */
+					&p2p->cfg->channels);
+#else		
 					 &p2p->channels);
+#endif /* SAMSUNG_SRID */		
 	} else if (peer->go_state == REMOTE_GO) {
 		p2p_buf_add_channel_list(buf, p2p->cfg->country,
+#ifdef SAMSUNG_SRID
+		/* Show all supported channels in Go negotiation packet */
+					&p2p->cfg->channels);
+#else		
 					 &p2p->channels);
+#endif	/* SAMSUNG_SRID */	
 	} else {
 		struct p2p_channels res;
 		p2p_channels_intersect(&p2p->channels, &peer->channels,
@@ -508,6 +518,11 @@
 	p2p_channels_intersect(&tmp, &p2p->cfg->channels, &intersection);
 	p2p_channels_dump(p2p, "intersection with local channel list",
 			  &intersection);
+#ifdef SAMSUNG_PREFER_5G        
+	if(p2p->prefer_5g)
+		p2p_channels_5g_prefer(&intersection);
+#endif /* SAMSUNG_PREFER_5G */
+
 	if (intersection.reg_classes == 0 ||
 	    intersection.reg_class[0].channels == 0) {
 		*status = P2P_SC_FAIL_NO_COMMON_CHANNELS;
@@ -912,7 +927,12 @@
 	else
 		p2p_buf_add_operating_channel(buf, (const char *) resp_chan,
 					      resp_chan[3], resp_chan[4]);
+#ifdef SAMSUNG_SRID
+	/* Filter channels based on driver supported all channels */
+	p2p_channels_intersect(&p2p->cfg->channels, &peer->channels, &res);
+#else	
 	p2p_channels_intersect(&p2p->channels, &peer->channels, &res);
+#endif /* SAMSUNG_SRID */	
 	p2p_buf_add_channel_list(buf, p2p->cfg->country, &res);
 	if (go) {
 		p2p_buf_add_group_id(buf, p2p->cfg->dev_addr, p2p->ssid,
diff -urN hostap_2_4.orig/src/p2p/p2p.h hostap_2_4/src/p2p/p2p.h
--- hostap_2_4.orig/src/p2p/p2p.h	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/p2p/p2p.h	2015-09-24 15:25:20.381038328 +0800
@@ -458,6 +458,34 @@
 	 */
 	u8 dev_addr[ETH_ALEN];
 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+	/**
+	 * static_ip - P2P static IP set by User
+	 */	
+        u32 static_ip;
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+	
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        u8 requested_go_intent;
+        int enable_req_go_intent;
+        int ON_req_go_intent;
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
+
+#ifdef SAMSUNG_P2P_PREKEY
+	enum samsung_prekey_state {
+	SAMSUNG_PREKEY_NONE,
+	SAMSUNG_PREKEY_SEND,
+	SAMSUNG_PREKEY_RECV,
+	SAMSUNG_PREKEY_SUPPORT,
+	SAMSUNG_PREKEY_SUPPORT_WPS_STARTED,
+	} isPreKey;
+	
+	char pre_Sendpassphrase[64];
+	char pre_Recvpassphrase[64];
+	int invitation_state;
+	int disable_skip_wps;
+#endif /* SAMSUNG_P2P_PREKEY */
+
 	/**
 	 * dev_name - Device Name
 	 */
@@ -791,7 +819,14 @@
 			      const u8 *dev_addr, const u8 *pri_dev_type,
 			      const char *dev_name, u16 supp_config_methods,
 			      u8 dev_capab, u8 group_capab,
-			      const u8 *group_id, size_t group_id_len);
+			      const u8 *group_id, size_t group_id_len
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+                              , u32 static_ip
+#endif
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        , u8 requested_go_intent, int ON_req_go_intent, struct wpabuf * requested_go_intent_attributes
+#endif
+				);
 
 	/**
 	 * prov_disc_resp - Callback on Provisiong Discovery Response
@@ -804,7 +839,14 @@
 	 * p2p_prov_disc_req(). This callback handler can be set to %NULL if
 	 * provision discovery is not used.
 	 */
-	void (*prov_disc_resp)(void *ctx, const u8 *peer, u16 config_methods);
+	void (*prov_disc_resp)(void *ctx, const u8 *peer, u16 config_methods
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+                              , u32 static_ip
+#endif
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        , u8 requested_go_intent , u8 rgi_confirm, int rgi_type, struct wpabuf * requested_go_intent_attributes
+#endif
+				);
 
 	/**
 	 * prov_disc_fail - Callback on Provision Discovery failure
@@ -1918,6 +1960,8 @@
 
 int p2p_get_interface_addr(struct p2p_data *p2p, const u8 *dev_addr,
 			   u8 *iface_addr);
+int p2p_get_intended_addr(struct p2p_data *p2p, const u8 *dev_addr,
+			   u8 *intended_addr);
 int p2p_get_dev_addr(struct p2p_data *p2p, const u8 *iface_addr,
 			   u8 *dev_addr);
 
@@ -2133,6 +2177,20 @@
 
 const char * p2p_wps_method_text(enum p2p_wps_method method);
 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+/**
+ * p2p_set_static_ip - Set static IP provided by user
+ * @p2p: P2P module context from p2p_init()
+ * @ip_addr: IP address to be set
+ */
+void p2p_set_static_ip(struct p2p_data *p2p, u32 ip_addr);
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+void p2p_set_req_go_intent(struct p2p_data *p2p, u8 req_go_intent);
+#endif
+
+
 /**
  * p2p_set_config_timeout - Set local config timeouts
  * @p2p: P2P module context from p2p_init()
diff -urN hostap_2_4.orig/src/p2p/p2p_i.h hostap_2_4/src/p2p/p2p_i.h
--- hostap_2_4.orig/src/p2p/p2p_i.h	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/p2p/p2p_i.h	2015-09-24 15:25:20.381038328 +0800
@@ -529,6 +529,11 @@
 	u16 authorized_oob_dev_pw_id;
 
 	struct wpabuf **vendor_elem;
+
+#ifdef SAMSUNG_PREFER_5G
+	u8 prefer_5g;
+#endif /* SAMSUNG_PREFER_5G */
+
 };
 
 /**
@@ -538,6 +543,16 @@
 	struct wpabuf *p2p_attributes;
 	struct wpabuf *wps_attributes;
 	struct wpabuf *wfd_subelems;
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        struct wpabuf *skip_dhcp_attributes;
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        struct wpabuf *requested_go_intent_attributes;
+        u8 requested_go_intent;
+        u8 rgi_confirm;
+        int rgi_type;
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
 
 	u8 dialog_token;
 
@@ -631,6 +646,13 @@
 	const u8 *persistent_dev;
 	const u8 *persistent_ssid;
 	size_t persistent_ssid_len;
+#ifdef SAMSUNG_P2P_PREKEY
+	struct wpabuf *pre_key_attributes;
+	char pre_hashvalue[64];
+#endif /* SAMSUNG_P2P_PREKEY */
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        u32 static_ip;
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
 };
 
 
@@ -674,6 +696,9 @@
 		       u8 *op_class, u8 *op_channel);
 int p2p_channel_random_social(struct p2p_channels *chans, u8 *op_class,
 			      u8 *op_channel);
+#ifdef SAMSUNG_PREFER_5G
+void p2p_channels_5g_prefer(struct p2p_channels *res);
+#endif /* SAMSUNG_PREFER_5G */
 
 /* p2p_parse.c */
 int p2p_parse_p2p_ie(const struct wpabuf *buf, struct p2p_message *msg);
@@ -685,6 +710,13 @@
 int p2p_attr_text(struct wpabuf *data, char *buf, char *end);
 int p2p_group_info_parse(const u8 *gi, size_t gi_len,
 			 struct p2p_group_info *info);
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+int p2p_parse_skip_dhcp_ie(const struct wpabuf *buf, struct p2p_message *msg);
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+int p2p_parse_go_intent_req_ie(const struct wpabuf *buf, struct p2p_message *msg);
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
 
 /* p2p_build.c */
 
@@ -859,4 +891,17 @@
 void p2p_err(struct p2p_data *p2p, const char *fmt, ...)
 PRINTF_FORMAT(2, 3);
 
+#ifdef SAMSUNG_P2P_PREKEY
+void p2p_get_hash_prekey(char passphrase[64], char changeKey[] , int len);
+void p2p_set_check_prekey_out(char passphrase[64] , char out_passphrase[64]);
+#endif /* SAMSUNG_P2P_PREKEY */
+
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+void p2p_build_skip_dhcp_ie(struct p2p_data *p2p, struct wpabuf *buf, u32 ip_addr);
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+void p2p_build_req_go_intent_ie(struct p2p_data *p2p, struct wpabuf *buf, u8 go_intent, int ON_req_go_intent, struct wpabuf * requested_go_intent_attributes);
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
+
 #endif /* P2P_I_H */
diff -urN hostap_2_4.orig/src/p2p/p2p_invitation.c hostap_2_4/src/p2p/p2p_invitation.c
--- hostap_2_4.orig/src/p2p/p2p_invitation.c	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/p2p/p2p_invitation.c	2015-09-24 15:25:20.381038328 +0800
@@ -153,6 +153,11 @@
 		p2p_buf_add_channel_list(buf, p2p->cfg->country, channels);
 	p2p_buf_update_ie_hdr(buf, len);
 
+#ifdef SAMSUNG_P2P_PREKEY
+	if(!p2p->cfg->disable_skip_wps)
+		p2p->cfg->invitation_state = 1;
+#endif /* SAMSUNG_P2P_PREKEY */
+
 #ifdef CONFIG_WIFI_DISPLAY
 	if (wfd_ie)
 		wpabuf_put_buf(buf, wfd_ie);
@@ -206,6 +211,16 @@
 			goto fail;
 		}
 	}
+#if defined(CONFIG_WIFI_DISPLAY) && defined(SAMSUNG_SRID)
+	/* Update WFD_IE every time */
+	if(dev != NULL && dev->info.wfd_subelems != NULL)
+	{
+		wpabuf_free(dev->info.wfd_subelems);
+		dev->info.wfd_subelems = NULL;
+	}
+	if (dev != NULL && msg.wfd_subelems)
+		dev->info.wfd_subelems = wpabuf_dup(msg.wfd_subelems);
+#endif /* CONFIG_WIFI_DISPLAY && SAMSUNG_SRID */
 
 	if (!msg.group_id || !msg.channel_list) {
 		p2p_dbg(p2p, "Mandatory attribute missing in Invitation Request from "
diff -urN hostap_2_4.orig/src/p2p/p2p_parse.c hostap_2_4/src/p2p/p2p_parse.c
--- hostap_2_4.orig/src/p2p/p2p_parse.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/p2p/p2p_parse.c	2015-09-24 15:25:20.381038328 +0800
@@ -497,6 +497,138 @@
 	return 0;
 }
 
+#ifdef SAMSUNG_P2P_PREKEY
+static int p2p_parse_pre_key_ie(const struct wpabuf *buf, struct p2p_message *msg)
+{
+        const u8 *pos = wpabuf_head_u8(buf);
+        const u8 *end = pos + wpabuf_len(buf);
+
+        u16 type, len;
+
+        while (pos < end) {
+                if (end - pos < 4) {
+                        wpa_printf(MSG_ERROR , "P2P: Invalid PRE_KEY attribute");
+                        return -1; 
+                }
+
+                type = WPA_GET_BE16(pos);
+                pos += 1;
+                len = WPA_GET_BE16(pos);
+                pos += 2;
+                wpa_printf(MSG_DEBUG, "P2P: attr type=0x%x len=%u", type, len);
+
+                if (len > end - pos) {
+                        wpa_printf(MSG_ERROR, "P2P: Attribute underflow");
+                        return -1; 
+                }
+                os_memset(msg->pre_hashvalue , 0 , sizeof(msg->pre_hashvalue));
+                os_memcpy(msg->pre_hashvalue , pos , len);
+
+                pos += len;
+        }
+    
+        return 0;
+}
+#endif /* SAMSUNG_P2P_PREKEY */
+
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+int p2p_parse_skip_dhcp_ie(const struct wpabuf *buf, struct p2p_message *msg)
+{
+        const u8 *pos = wpabuf_head_u8(buf);
+        const u8 *end = pos + wpabuf_len(buf);
+
+        u16 type, len;
+
+        wpa_printf(MSG_DEBUG, "P2P: Parsing SKIP_DHCP IE");
+
+        while (pos < end) {
+                if (end - pos < 4) {
+                        wpa_printf(MSG_DEBUG, "P2P: Invalid SKIP_DHCP attribute");
+                        return -1; 
+                }
+
+                type = WPA_GET_BE16(pos);
+                pos += 1;
+                len = WPA_GET_BE16(pos);
+                pos += 2;
+                wpa_printf(MSG_EXCESSIVE, "P2P: attr type=0x%x len=%u", type, len);
+
+                if (len > end - pos) {
+                        wpa_printf(MSG_DEBUG, "P2P: Attribute underflow");
+                        wpa_hexdump(MSG_MSGDUMP, "P2P: Data", pos, end - pos);
+                        return -1; 
+                }
+                msg->static_ip = WPA_GET_BE32(pos);
+
+                pos += len;
+        }
+
+        wpa_printf(MSG_DEBUG, "P2P: SKIP_DHCP Info: %x ", msg->static_ip);
+
+        return 0;
+}
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+int p2p_parse_go_intent_req_ie(const struct wpabuf *buf, struct p2p_message *msg)
+{
+        const u8 *pos = wpabuf_head_u8(buf);
+        const u8 *end = pos + wpabuf_len(buf);
+
+        u16 len;
+        u8 type;
+
+        msg->rgi_type = -1; //initialize
+        while (pos < end) {
+                if (end - pos < 4) {
+                        wpa_printf(MSG_ERROR , "P2P: Invalid REQUESTED_GO_INTENT attribute");
+                        return -1; 
+                }   
+
+                type = pos[0];
+                pos += 1;
+                len = WPA_GET_BE16(pos);
+                pos += 2;
+                wpa_printf(MSG_DEBUG, "P2P: attr type=0x%x len=%u", type, len);
+
+                if (len > end - pos) {
+                        wpa_printf(MSG_ERROR, "P2P: Attribute underflow");
+                        wpa_hexdump(MSG_MSGDUMP, "P2P: Data", pos, end - pos);
+                        return -1; 
+                }
+		switch(type){
+                        case RGI_VALUE:    
+                                if (len != 1) {
+                                        wpa_printf(MSG_DEBUG, "P2P: RGI - Invalid Version length %u",
+                                                        len);
+                                        return -1; 
+                                }   
+                                msg->rgi_type = type;
+                                msg->requested_go_intent = *pos;
+                                wpa_printf(MSG_DEBUG, "P2P: REQUESTED GO INTENT Info: %x ", msg->requested_go_intent);
+                                break;
+                        case RGI_CONFIRM:
+                                if (len != 1) {
+                                        wpa_printf(MSG_DEBUG, "P2P: RGI - Invalid Version length %u",
+                                                        len);
+                                        return -1; 
+                                }
+                                msg->rgi_type = type;
+                                msg->rgi_confirm = *pos;
+                                wpa_printf(MSG_DEBUG, "P2P: RGI_confirm: %x ", msg->rgi_confirm);
+                                break;
+                        default:
+                                msg->rgi_type = -1;
+                                wpa_printf(MSG_DEBUG, "P2P: RGI - Unsupported attribute type 0x%x "
+                                                "len=%u", type, len);
+                                break;
+                }
+                pos += len;
+        }
+
+        return 0;
+}
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
 
 /**
  * p2p_parse_ies - Parse P2P message IEs (both WPS and P2P IE)
@@ -541,6 +673,45 @@
 		return -1;
 	}
 
+#ifdef SAMSUNG_P2P_PREKEY
+	msg->pre_key_attributes = NULL;
+	msg->pre_key_attributes = ieee802_11_vendor_ie_concat(data, len, 
+							PRE_KEY_VENDOR_TYPE);
+	if (msg->pre_key_attributes &&
+		p2p_parse_pre_key_ie(msg->pre_key_attributes, msg)) {
+			wpa_printf(MSG_ERROR, "P2P: Failed to parse PRE_KEY IP IE data");
+			p2p_parse_free(msg);
+			return -1;
+	}
+#endif /* SAMSUNG_P2P_PREKEY */
+
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        msg->skip_dhcp_attributes = NULL;
+        msg->skip_dhcp_attributes = ieee802_11_vendor_ie_concat(data, len,
+                                                          SKIP_DHCP_VENDOR_TYPE);
+        if (msg->skip_dhcp_attributes &&
+                p2p_parse_skip_dhcp_ie(msg->skip_dhcp_attributes, msg)) {
+                wpa_printf(MSG_INFO, "P2P: Failed to parse SKIP_DHCP IP IE data");
+                if (msg->skip_dhcp_attributes)
+                        wpa_hexdump_buf(MSG_MSGDUMP, "P2P: STATELESS IP IE data",
+                                        msg->skip_dhcp_attributes);
+                p2p_parse_free(msg);
+                return -1;
+        }
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        msg->requested_go_intent_attributes = NULL;
+        msg->requested_go_intent_attributes = ieee802_11_vendor_ie_concat(data, len,
+                        GO_INTENT_REQ_VENDOR_TYPE);
+        if (msg->requested_go_intent_attributes &&
+                        p2p_parse_go_intent_req_ie(msg->requested_go_intent_attributes, msg)) {
+                wpa_printf(MSG_ERROR, "P2P: Failed to parse Requested Go Intent IP IE data");
+                p2p_parse_free(msg);
+                return -1;
+        }
+#endif /* SAMSUNG_GO_INTENT_REQUEST  */
+
 #ifdef CONFIG_WIFI_DISPLAY
 	if (elems.wfd) {
 		msg->wfd_subelems = ieee802_11_vendor_ie_concat(
@@ -618,6 +789,14 @@
 	wpabuf_free(msg->wfd_subelems);
 	msg->wfd_subelems = NULL;
 #endif /* CONFIG_WIFI_DISPLAY */
+#ifdef SAMSUNG_P2P_PREKEY
+	wpabuf_free(msg->pre_key_attributes);
+	msg->pre_key_attributes = NULL;
+#endif /* SAMSUNG_P2P_PREKEY */
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        wpabuf_free(msg->requested_go_intent_attributes);
+        msg->requested_go_intent_attributes = NULL;
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
 }
 
 
diff -urN hostap_2_4.orig/src/p2p/p2p_pd.c hostap_2_4/src/p2p/p2p_pd.c
--- hostap_2_4.orig/src/p2p/p2p_pd.c	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/p2p/p2p_pd.c	2015-09-24 15:25:20.381038328 +0800
@@ -39,6 +39,38 @@
 	p2p_buf_update_ie_hdr(buf, len);
 }
 
+#ifdef SAMSUNG_P2P_PREKEY
+static int p2p_build_p2p_prekey_ie(struct p2p_data *p2p, struct wpabuf *buf , char *passphrase, int key_len)
+{
+        u8 *len;
+        char change_passphrase[64];
+        p2p_dbg(p2p, "SRID p2p_build_p2p_prekey_ie");
+
+        os_memset(change_passphrase , 0 , 64);
+
+        if(os_strlen(passphrase) == 0) {
+                p2p_random(passphrase, PRE_KEY_LENGTH-1);
+        }
+
+        p2p_dbg(p2p, "Before  p2p_set_check_prekey_out");
+        p2p_set_check_prekey_out(passphrase , change_passphrase);
+
+        wpabuf_put_u8(buf, WLAN_EID_VENDOR_SPECIFIC);
+        len = wpabuf_put(buf, 1);
+        wpabuf_put_be24(buf, OUI_SAMSUNG);
+        wpabuf_put_u8(buf, VENDOR_P2P_PRE_KEY_OUI_TYPE);
+
+        wpabuf_put_u8(buf, 0); // element type
+        wpabuf_put_be16(buf, key_len); // element length
+
+        wpabuf_put_data(buf , change_passphrase , key_len);
+
+        p2p_buf_update_ie_hdr(buf, len);
+        p2p_dbg(p2p, "SRID p2p_buf_update_ie_hdr After");
+
+        return 0;
+}
+#endif /* SAMSUNG_P2P_PREKEY */
 
 static void p2ps_add_new_group_info(struct p2p_data *p2p, struct wpabuf *buf)
 {
@@ -178,7 +210,6 @@
 	if (p2p->p2ps_prov)
 		extra += os_strlen(p2p->p2ps_prov->info) + 1 +
 			sizeof(struct p2ps_provision);
-
 	buf = wpabuf_alloc(1000 + extra);
 	if (buf == NULL)
 		return NULL;
@@ -211,6 +242,23 @@
 	/* WPS IE with Config Methods attribute */
 	p2p_build_wps_ie_config_methods(buf, config_methods);
 
+#ifdef SAMSUNG_P2P_PREKEY
+	if(!p2p->cfg->disable_skip_wps && (p2p_build_p2p_prekey_ie(p2p, buf, 
+		p2p->cfg->pre_Sendpassphrase, PRE_KEY_LENGTH) == 0)) {
+		p2p->cfg->isPreKey = SAMSUNG_PREKEY_SEND;
+		p2p_dbg(p2p, "SRID build_p2p_prekey_ie........Change");
+	}
+#endif /* SAMSUNG_P2P_PREKEY */
+
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        p2p_build_skip_dhcp_ie(p2p, buf, p2p->cfg->static_ip);
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        if(p2p->cfg->ON_req_go_intent && p2p->cfg->enable_req_go_intent)
+                p2p_build_req_go_intent_ie(p2p, buf, p2p->cfg->requested_go_intent, p2p->cfg->ON_req_go_intent, NULL);
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
+
 #ifdef CONFIG_WIFI_DISPLAY
 	if (p2p->wfd_ie_prov_disc_req)
 		wpabuf_put_buf(buf, p2p->wfd_ie_prov_disc_req);
@@ -232,7 +280,11 @@
 						const u8 *group_id,
 						size_t group_id_len,
 						const u8 *persist_ssid,
-						size_t persist_ssid_len)
+						size_t persist_ssid_len
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+                        ,struct wpabuf * requested_go_intent_attributes
+#endif
+						)
 {
 	struct wpabuf *buf;
 	size_t extra = 0;
@@ -262,6 +314,9 @@
 	if (p2p->vendor_elem && p2p->vendor_elem[VENDOR_ELEM_P2P_PD_RESP])
 		extra += wpabuf_len(p2p->vendor_elem[VENDOR_ELEM_P2P_PD_RESP]);
 
+#ifdef SAMSUNG_P2P_PREKEY
+	extra += 96;
+#endif /* SAMSUNG_P2P_PREKEY */
 	buf = wpabuf_alloc(1000 + extra);
 	if (buf == NULL)
 		return NULL;
@@ -362,6 +417,25 @@
 	/* WPS IE with Config Methods attribute */
 	p2p_build_wps_ie_config_methods(buf, config_methods);
 
+#ifdef SAMSUNG_P2P_PREKEY
+	if(!p2p->cfg->disable_skip_wps && (p2p_build_p2p_prekey_ie(p2p, buf, 
+		p2p->cfg->pre_Sendpassphrase, PRE_KEY_LENGTH) == 0)) {
+		if(p2p->cfg->isPreKey == SAMSUNG_PREKEY_RECV) {
+			p2p->cfg->isPreKey = SAMSUNG_PREKEY_SUPPORT;
+			p2p_info(p2p,P2P_EVENT_P2P_WPS_SKIP);
+		}
+	}
+#endif /* SAMSUNG_P2P_PREKEY */
+
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        p2p_build_skip_dhcp_ie(p2p, buf, p2p->cfg->static_ip);
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        if( requested_go_intent_attributes || (!requested_go_intent_attributes && (p2p->cfg->ON_req_go_intent && p2p->cfg->enable_req_go_intent)))
+                p2p_build_req_go_intent_ie(p2p, buf, p2p->cfg->requested_go_intent, p2p->cfg->ON_req_go_intent, requested_go_intent_attributes);
+#endif
+
 #ifdef CONFIG_WIFI_DISPLAY
 	if (wfd_ie)
 		wpabuf_put_buf(buf, wfd_ie);
@@ -426,6 +500,23 @@
 		" with config methods 0x%x (freq=%d)",
 		MAC2STR(sa), msg.wps_config_methods, rx_freq);
 
+#ifdef SAMSUNG_P2P_PREKEY
+	if (!p2p->cfg->disable_skip_wps && (os_strlen(msg.pre_hashvalue) > 0)) {
+		if ((p2p->cfg->isPreKey == SAMSUNG_PREKEY_NONE)
+			|| (p2p->cfg->isPreKey == SAMSUNG_PREKEY_SEND))
+		{
+			os_memset(p2p->cfg->pre_Recvpassphrase , 0 , PRE_KEY_LENGTH);
+			p2p_set_check_prekey_out(msg.pre_hashvalue , p2p->cfg->pre_Recvpassphrase);
+			p2p->cfg->isPreKey = SAMSUNG_PREKEY_RECV;
+		}
+		else
+			wpa_printf(MSG_DEBUG, "P2P: Do not update pre-passphrase except for first PD request frame");
+	}
+	else {
+		os_memset(p2p->cfg->pre_Recvpassphrase , 0 , PRE_KEY_LENGTH);
+		p2p->cfg->isPreKey = SAMSUNG_PREKEY_NONE;
+	}
+#endif /* SAMSUNG_P2P_PREKEY */
 	dev = p2p_get_device(p2p, sa);
 	if (dev == NULL || (dev->flags & P2P_DEV_PROBE_REQ_ONLY)) {
 		p2p_dbg(p2p, "Provision Discovery Request from unknown peer "
@@ -436,10 +527,21 @@
 			p2p_dbg(p2p, "Provision Discovery Request add device failed "
 				MACSTR, MAC2STR(sa));
 		}
-	} else if (msg.wfd_subelems) {
+	}
+#if defined(CONFIG_WIFI_DISPLAY) && defined(SAMSUNG_SRID)
+	/* Update WFD_IE every time */
+	if(dev != NULL && dev->info.wfd_subelems != NULL) {
 		wpabuf_free(dev->info.wfd_subelems);
-		dev->info.wfd_subelems = wpabuf_dup(msg.wfd_subelems);
+		dev->info.wfd_subelems = NULL;
 	}
+	if (dev != NULL && msg.wfd_subelems)
+		dev->info.wfd_subelems = wpabuf_dup(msg.wfd_subelems);
+#else
+	else if (msg.wfd_subelems) {
+                wpabuf_free(dev->info.wfd_subelems);
+                dev->info.wfd_subelems = wpabuf_dup(msg.wfd_subelems);
+        }
+#endif /* CONFIG_WIFI_DISPLAY && SAMSUNG_SRID */
 
 	if (!(msg.wps_config_methods &
 	      (WPS_CONFIG_DISPLAY | WPS_CONFIG_KEYPAD |
@@ -659,7 +761,11 @@
 					config_methods, adv_id,
 					msg.group_id, msg.group_id_len,
 					msg.persistent_ssid,
-					msg.persistent_ssid_len);
+					msg.persistent_ssid_len
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+                    , msg.requested_go_intent_attributes
+#endif
+					);
 	if (resp == NULL) {
 		p2p_parse_free(&msg);
 		return;
@@ -781,7 +887,16 @@
 					msg.capability ? msg.capability[0] : 0,
 					msg.capability ? msg.capability[1] :
 					0,
-					msg.group_id, msg.group_id_len);
+					msg.group_id, msg.group_id_len
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+                    , msg.static_ip
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+                    , msg.requested_go_intent, 
+					p2p->cfg->ON_req_go_intent, 
+					msg.requested_go_intent_attributes
+#endif
+					);
 	}
 	p2p_parse_free(&msg);
 }
@@ -839,6 +954,18 @@
 		" with config methods 0x%x",
 		MAC2STR(sa), msg.wps_config_methods);
 
+#ifdef SAMSUNG_P2P_PREKEY
+	if(!p2p->cfg->disable_skip_wps && (os_strlen(msg.pre_hashvalue) > 0)) {
+		os_memset(p2p->cfg->pre_Recvpassphrase , 0, PRE_KEY_LENGTH);
+		p2p_set_check_prekey_out(msg.pre_hashvalue , p2p->cfg->pre_Recvpassphrase);
+		if(p2p->cfg->isPreKey == SAMSUNG_PREKEY_SEND)
+			p2p->cfg->isPreKey = SAMSUNG_PREKEY_SUPPORT;
+	}
+	else {
+		os_memset(p2p->cfg->pre_Recvpassphrase , 0 , PRE_KEY_LENGTH);
+		p2p->cfg->isPreKey = SAMSUNG_PREKEY_NONE;
+	}
+#endif /* SAMSUNG_P2P_PREKEY */
 	dev = p2p_get_device(p2p, sa);
 	if (dev == NULL || !dev->req_config_methods) {
 		p2p_dbg(p2p, "Ignore Provision Discovery Response from " MACSTR
@@ -880,7 +1007,9 @@
 			p2p->cfg->prov_disc_fail(p2p->cfg->cb_ctx, sa,
 						 P2P_PROV_DISC_REJECTED,
 						 adv_id, adv_mac, NULL);
+#ifndef SAMSUNG_GO_INTENT_REQUEST
 		p2p_parse_free(&msg);
+#endif
 		os_free(p2p->p2ps_prov);
 		p2p->p2ps_prov = NULL;
 		goto out;
@@ -949,7 +1078,9 @@
 			char *deferred_sess_resp = os_malloc(2 * info_len + 1);
 
 			if (!deferred_sess_resp) {
+#ifndef SAMSUNG_GO_INTENT_REQUEST
 				p2p_parse_free(&msg);
+#endif
 				os_free(p2p->p2ps_prov);
 				p2p->p2ps_prov = NULL;
 				goto out;
@@ -977,7 +1108,9 @@
 			p2p->cfg->prov_disc_fail(p2p->cfg->cb_ctx, sa,
 						 P2P_PROV_DISC_REJECTED, 0,
 						 NULL, NULL);
+#ifndef SAMSUNG_GO_INTENT_REQUEST
 		p2p_parse_free(&msg);
+#endif
 		os_free(p2p->p2ps_prov);
 		p2p->p2ps_prov = NULL;
 		goto out;
@@ -985,8 +1118,9 @@
 
 	/* Store the provisioning info */
 	dev->wps_prov_info = msg.wps_config_methods;
-
+#ifndef SAMSUNG_GO_INTENT_REQUEST
 	p2p_parse_free(&msg);
+#endif
 	success = 1;
 
 out:
@@ -997,16 +1131,31 @@
 			MACSTR, MAC2STR(dev->info.p2p_device_addr));
 		dev->flags &= ~P2P_DEV_PD_BEFORE_GO_NEG;
 		p2p_connect_send(p2p, dev);
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+                p2p_parse_free(&msg);
+#endif
 		return;
 	}
 	if (success && p2p->cfg->prov_disc_resp)
 		p2p->cfg->prov_disc_resp(p2p->cfg->cb_ctx, sa,
-					 report_config_methods);
+					 report_config_methods
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+                     , msg.static_ip
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+                     , msg.requested_go_intent, 
+					 msg.rgi_confirm, msg.rgi_type, 
+					 msg.requested_go_intent_attributes
+#endif
+					);
 
 	if (p2p->state == P2P_PD_DURING_FIND) {
 		p2p_clear_timeout(p2p);
 		p2p_continue_find(p2p);
 	}
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        p2p_parse_free(&msg);
+#endif
 }
 
 
diff -urN hostap_2_4.orig/src/p2p/p2p_utils.c hostap_2_4/src/p2p/p2p_utils.c
--- hostap_2_4.orig/src/p2p/p2p_utils.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/p2p/p2p_utils.c	2015-09-24 15:25:20.381038328 +0800
@@ -100,7 +100,14 @@
 		*channel = (freq - 5000) / 5;
 		return 0;
 	}
-
+#ifdef SAMSUNG_SRID	
+	/* check for channel 165 also */
+	if ( freq == 5825) {
+		*op_class = 125; /* 5 GHz, channels 165 */
+		*channel = (freq - 5000) / 5;
+		return 0;
+	}
+#endif /* SAMSUNG_SRID */
 	if (freq >= 58320 && freq <= 64800) {
 		if ((freq - 58320) % 2160)
 			return -1;
@@ -281,6 +288,48 @@
 	}
 }
 
+#ifdef SAMSUNG_PREFER_5G
+/**
+ * p2p_channels_5g_prefer - Filter out 2g channel if there is any 5g channel in the list
+ * @res: Data structure for returning the intersection of support channels
+ *
+ * This function can be used to filter out 2g channel if there is any 5g channel in the list
+ */
+void p2p_channels_5g_prefer(struct p2p_channels *res)
+{
+        size_t i;
+        struct p2p_channels tmp_list;
+        struct p2p_reg_class *res_reg, *tmp_reg;
+
+        os_memset(&tmp_list, 0, sizeof(tmp_list));
+
+      for (i = 0; i < res->reg_classes; i++) {
+                res_reg = &res->reg_class[i];
+                if((res_reg->reg_class == 115 ||
+                res_reg->reg_class == 118 ||
+                res_reg->reg_class == 124 ||
+                res_reg->reg_class == 125 ||
+                res_reg->reg_class == 116 ||
+                res_reg->reg_class == 117 ||
+                res_reg->reg_class == 119 ||
+                res_reg->reg_class == 120 ||
+                res_reg->reg_class == 126 ||
+                res_reg->reg_class == 127) &&  
+                res_reg->channels){
+                   tmp_reg = &(tmp_list.reg_class[tmp_list.reg_classes]);
+                   os_memcpy(tmp_reg, res_reg, sizeof(*tmp_reg));
+                   tmp_list.reg_classes++;
+                   if (tmp_list.reg_classes == P2P_MAX_REG_CLASSES)
+                                break;
+                }
+      }   
+
+      if(tmp_list.reg_classes)
+                os_memcpy(res, &tmp_list, sizeof(tmp_list));
+    
+      return;
+} 
+#endif /* SAMSUNG_PREFER_5G */
 
 /**
  * p2p_channels_includes - Check whether a channel is included in the list
diff -urN hostap_2_4.orig/src/radius/.gitignore hostap_2_4/src/radius/.gitignore
--- hostap_2_4.orig/src/radius/.gitignore	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/radius/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-libradius.a
diff -urN hostap_2_4.orig/src/tls/.gitignore hostap_2_4/src/tls/.gitignore
--- hostap_2_4.orig/src/tls/.gitignore	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/tls/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-libtls.a
diff -urN hostap_2_4.orig/src/utils/common.h hostap_2_4/src/utils/common.h
--- hostap_2_4.orig/src/utils/common.h	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/utils/common.h	2015-09-24 15:25:20.377038328 +0800
@@ -432,6 +432,13 @@
 #define COMPACT_MACSTR "%02x%02x%02x%02x%02x%02x"
 #endif
 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+#ifndef MAC2STR_SEC
+#define MAC2STR_SEC(a) (a)[0], (a)[4], (a)[5]
+#define MACSTR_SEC "%02X.%02X.%02X"
+#endif /* MAC2STR_SEC */
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
 #ifndef BIT
 #define BIT(x) (1 << (x))
 #endif
diff -urN hostap_2_4.orig/src/utils/.gitignore hostap_2_4/src/utils/.gitignore
--- hostap_2_4.orig/src/utils/.gitignore	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/utils/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-libutils.a
diff -urN hostap_2_4.orig/src/utils/includes.h hostap_2_4/src/utils/includes.h
--- hostap_2_4.orig/src/utils/includes.h	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/utils/includes.h	2015-09-24 15:25:20.377038328 +0800
@@ -47,4 +47,16 @@
 #endif /* CONFIG_TI_COMPILER */
 #endif /* CONFIG_NATIVE_WINDOWS */
 
+/* Prevent Bug Fix for thread safety*/
+#undef strerror
+#define str_buf_len 100
+char str_buf[str_buf_len];
+#define strerror strerror_tizen
+
+static inline char* strerror_tizen(int errnum)
+{
+	strerror_r(errnum,str_buf, str_buf_len);
+	return str_buf;
+}
+
 #endif /* INCLUDES_H */
diff -urN hostap_2_4.orig/src/utils/os_unix.c hostap_2_4/src/utils/os_unix.c
--- hostap_2_4.orig/src/utils/os_unix.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/utils/os_unix.c	2015-09-24 15:25:20.377038328 +0800
@@ -46,7 +46,7 @@
 	if (sec)
 		sleep(sec);
 	if (usec)
-		usleep(usec);
+		usleep((usec > 100000) ? 100000 : usec); /* Prevent Bug fix */
 }
 
 
@@ -101,7 +101,7 @@
 int os_mktime(int year, int month, int day, int hour, int min, int sec,
 	      os_time_t *t)
 {
-	struct tm tm, *tm1;
+	struct tm tm, *tm1, tm4, tm5;
 	time_t t_local, t1, t2;
 	os_time_t tz_offset;
 
@@ -121,10 +121,10 @@
 	t_local = mktime(&tm);
 
 	/* figure out offset to UTC */
-	tm1 = localtime(&t_local);
+	tm1 = localtime_r(&t_local, &tm4); /* Prevent fix for thread safety */
 	if (tm1) {
 		t1 = mktime(tm1);
-		tm1 = gmtime(&t_local);
+		tm1 = gmtime_r(&t_local, &tm5); /* Prevent fix for thread safety */
 		if (tm1) {
 			t2 = mktime(tm1);
 			tz_offset = t2 - t1;
@@ -140,10 +140,10 @@
 
 int os_gmtime(os_time_t t, struct os_tm *tm)
 {
-	struct tm *tm2;
+	struct tm *tm2, tm3;
 	time_t t2 = t;
 
-	tm2 = gmtime(&t2);
+	tm2 = gmtime_r(&t2, &tm3); /* Prevent fix for thread safety */
 	if (tm2 == NULL)
 		return -1;
 	tm->sec = tm2->tm_sec;
diff -urN hostap_2_4.orig/src/utils/wpa_debug.c hostap_2_4/src/utils/wpa_debug.c
--- hostap_2_4.orig/src/utils/wpa_debug.c	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/utils/wpa_debug.c	2015-09-24 15:25:20.377038328 +0800
@@ -59,8 +59,85 @@
 
 #ifdef CONFIG_DEBUG_FILE
 static FILE *out_file = NULL;
+static char *last_path = NULL;
 #endif /* CONFIG_DEBUG_FILE */
 
+#if defined(CONFIG_DEBUG_FILE) && defined(SAMSUNG_DEBUG_FILE)
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <time.h>
+
+#define MAX_SIZE_LOG_FILE 80
+#define MAX_LOG_SIZE    10 * 1024 * 1024
+#define MAX_LOG_COUNT   1
+#define vfprintf __wpa_log
+
+static void __wpa_log_update_file_revision(int rev)
+{
+    int next_log_rev = 0;
+    char log_file[MAX_SIZE_LOG_FILE] = {0};
+    char next_log_file[MAX_SIZE_LOG_FILE] = {0};
+
+    next_log_rev = rev + 1;
+
+    os_snprintf(log_file,MAX_SIZE_LOG_FILE,"%s.%d", last_path, rev);
+    os_snprintf(next_log_file,MAX_SIZE_LOG_FILE,"%s.%d", last_path, next_log_rev);
+
+    if (next_log_rev >= MAX_LOG_COUNT)
+        remove(next_log_file);
+
+    if (access(next_log_file, F_OK) == 0)
+        __wpa_log_update_file_revision(next_log_rev);
+
+    if (rename(log_file, next_log_file) != 0)
+        remove(log_file);
+}
+
+static void __wpa_log_make_backup(void)
+{
+	const int rev = 0;
+	char backup[MAX_SIZE_LOG_FILE]={0};
+
+	os_snprintf(backup,MAX_SIZE_LOG_FILE ,"%s.%d",last_path, rev);
+
+        if (access(backup, F_OK) == 0)
+        __wpa_log_update_file_revision(rev);
+
+        if (rename(last_path, backup) != 0)
+                remove(last_path);
+}
+
+static void __wpa_log(FILE *tmp_file, const char *format, va_list ap)
+{
+        int log_size = 0;
+        struct stat buf;
+        char str[256];
+
+        if (out_file == NULL)
+                out_file = (FILE *)fopen(last_path, "a+");
+
+        if (out_file == NULL)
+                return;
+
+        fstat(fileno(out_file), &buf);
+        log_size = buf.st_size;
+
+        if (log_size >= MAX_LOG_SIZE) {
+                fclose(out_file);
+                out_file = NULL;
+
+                __wpa_log_make_backup();
+                out_file = (FILE *)fopen(last_path, "a+");
+
+                if (out_file == NULL)
+                    return;
+        }
+        if (vsnprintf(str, sizeof(str), format, ap) > 0){
+                fprintf(out_file, "%s",str);
+        }
+}
+#endif /* CONFIG_DEBUG_FILE && SAMSUNG_DEBUG_FILE */
 
 void wpa_debug_print_timestamp(void)
 {
@@ -509,9 +586,6 @@
 }
 
 
-#ifdef CONFIG_DEBUG_FILE
-static char *last_path = NULL;
-#endif /* CONFIG_DEBUG_FILE */
 
 int wpa_debug_reopen_file(void)
 {
@@ -639,6 +713,40 @@
 	os_free(buf);
 }
 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+void wpa_msg_sec(void *ctx, int level, const char *fmt, ...)
+{
+        va_list ap; 
+        char *buf;
+        const int buflen = 2048;
+        int len;
+        char prefix[130];
+
+        buf = os_malloc(buflen);
+        if (buf == NULL) {
+                wpa_printf(MSG_ERROR, "wpa_msg: Failed to allocate message "
+                           "buffer");
+                return;
+        }
+        va_start(ap, fmt);
+        prefix[0] = '\0';
+        if (wpa_msg_ifname_cb) {
+                const char *ifname = wpa_msg_ifname_cb(ctx);
+                if (ifname) {
+                        int res = os_snprintf(prefix, sizeof(prefix), "%s: ",
+                                              ifname);
+                        if (res < 0 || res >= (int) sizeof(prefix))
+                                prefix[0] = '\0';
+                }
+        }
+        len = vsnprintf(buf, buflen, fmt, ap);
+        va_end(ap);
+
+        if (wpa_msg_cb)
+                wpa_msg_cb(ctx, level,0, buf, len); //SRID : : Cross Check
+        os_free(buf);
+}
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
 
 void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
 {
diff -urN hostap_2_4.orig/src/utils/wpa_debug.h hostap_2_4/src/utils/wpa_debug.h
--- hostap_2_4.orig/src/utils/wpa_debug.h	2015-09-24 15:25:20.361038328 +0800
+++ hostap_2_4/src/utils/wpa_debug.h	2015-09-24 15:25:20.377038328 +0800
@@ -159,6 +159,9 @@
 
 
 #ifdef CONFIG_NO_WPA_MSG
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+#define wpa_msg_sec(args...) do { } while (0)
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
 #define wpa_msg(args...) do { } while (0)
 #define wpa_msg_ctrl(args...) do { } while (0)
 #define wpa_msg_global(args...) do { } while (0)
@@ -183,6 +186,10 @@
  */
 void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+void wpa_msg_sec(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
 /**
  * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
  * @ctx: Pointer to context data; this is the ctx variable registered
diff -urN hostap_2_4.orig/src/wps/wps_registrar.c hostap_2_4/src/wps/wps_registrar.c
--- hostap_2_4.orig/src/wps/wps_registrar.c	2015-09-24 15:25:20.365038328 +0800
+++ hostap_2_4/src/wps/wps_registrar.c	2015-09-24 15:25:20.381038328 +0800
@@ -1802,8 +1802,9 @@
 static struct wpabuf * wps_build_m2(struct wps_data *wps)
 {
 	struct wpabuf *msg;
+#ifdef CONFIG_WPS_NFC	
 	int config_in_m2 = 0;
-
+#endif
 	if (random_get_bytes(wps->nonce_r, WPS_NONCE_LEN) < 0)
 		return NULL;
 	wpa_hexdump(MSG_DEBUG, "WPS: Registrar Nonce",
@@ -1867,7 +1868,11 @@
 	}
 
 	wps->int_reg = 1;
+#ifdef CONFIG_WPS_NFC
 	wps->state = config_in_m2 ? RECV_DONE : RECV_M3;
+#else
+	wps->state = RECV_M3;	/* Prevent bug fixing */
+#endif /* CONFIG_WPS_NFC */
 	return msg;
 }
 
diff -urN hostap_2_4.orig/wpa_supplicant/bss.c hostap_2_4/wpa_supplicant/bss.c
--- hostap_2_4.orig/wpa_supplicant/bss.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/bss.c	2015-09-24 15:25:20.373038328 +0800
@@ -855,6 +855,17 @@
 	return 0;
 }
 
+#ifdef TIZEN
+/**
+ * wpa_bss_flush_by_deauth - Flush BSS entry of disconnected AP
+ * @wpa_s: Pointer to wpa_supplicant data
+ */
+void wpa_bss_flush_by_deauth(struct wpa_supplicant *wpa_s)
+{
+            if(wpa_s->current_bss)
+                    wpa_bss_remove(wpa_s, wpa_s->current_bss, "disconnect");
+}
+#endif /* TIZEN */
 
 /**
  * wpa_bss_flush - Flush all unused BSS entries
diff -urN hostap_2_4.orig/wpa_supplicant/bss.h hostap_2_4/wpa_supplicant/bss.h
--- hostap_2_4.orig/wpa_supplicant/bss.h	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/bss.h	2015-09-24 15:25:20.373038328 +0800
@@ -111,6 +111,9 @@
 int wpa_bss_init(struct wpa_supplicant *wpa_s);
 void wpa_bss_deinit(struct wpa_supplicant *wpa_s);
 void wpa_bss_flush(struct wpa_supplicant *wpa_s);
+#ifdef TIZEN
+void wpa_bss_flush_by_deauth(struct wpa_supplicant *wpa_s);
+#endif /* TIZEN */
 void wpa_bss_flush_by_age(struct wpa_supplicant *wpa_s, int age);
 struct wpa_bss * wpa_bss_get(struct wpa_supplicant *wpa_s, const u8 *bssid,
 			     const u8 *ssid, size_t ssid_len);
diff -urN hostap_2_4.orig/wpa_supplicant/.config hostap_2_4/wpa_supplicant/.config
--- hostap_2_4.orig/wpa_supplicant/.config	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/.config	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,548 @@
+# Example wpa_supplicant build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cases, these lines should use += in order not
+# to override previous values of the variables.
+
+
+# Uncomment following two lines and fix the paths if you have installed OpenSSL
+# or GnuTLS in non-default location
+#CFLAGS += -I/usr/local/openssl/include
+#LIBS += -L/usr/local/openssl/lib
+
+# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+# the kerberos files are not in the default include path. Following line can be
+# used to fix build issues on such systems (krb5.h not found).
+#CFLAGS += -I/usr/include/kerberos
+
+# Example configuration for various cross-compilation platforms
+
+#### sveasoft (e.g., for Linksys WRT54G) ######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
+#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
+###############################################################################
+
+#### openwrt (e.g., for Linksys WRT54G) #######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
+#	-I../WRT54GS/release/src/include
+#LIBS = -lssl
+###############################################################################
+
+
+# Driver interface for Host AP driver
+CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for Agere driver
+#CONFIG_DRIVER_HERMES=y
+# Change include directories to match with the local setup
+#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
+#CFLAGS += -I../../include/wireless
+
+# Driver interface for madwifi driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_MADWIFI=y
+# Set include directory to the madwifi source tree
+#CFLAGS += -I../../madwifi
+
+# Driver interface for ndiswrapper
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_NDISWRAPPER=y
+
+# Driver interface for Atmel driver
+CONFIG_DRIVER_ATMEL=y
+
+# Driver interface for old Broadcom driver
+# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
+# Linux wireless extensions and does not need (or even work) with the old
+# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
+#CONFIG_DRIVER_BROADCOM=y
+# Example path for wlioctl.h; change to match your configuration
+#CFLAGS += -I/opt/WRT54GS/release/src/include
+
+# Driver interface for Intel ipw2100/2200 driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_IPW=y
+
+# Driver interface for Ralink driver
+#CONFIG_DRIVER_RALINK=y
+
+# Driver interface for generic Linux wireless extensions
+# Note: WEXT is deprecated in the current Linux kernel version and no new
+# functionality is added to it. nl80211-based interface is the new
+# replacement for WEXT and its use allows wpa_supplicant to properly control
+# the driver to improve existing functionality like roaming and to support new
+# functionality.
+CONFIG_DRIVER_WEXT=y
+
+# Driver interface for Linux drivers using the nl80211 kernel interface
+CONFIG_DRIVER_NL80211=y
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+#LIBS_p += -L/usr/local/lib
+#LIBS_c += -L/usr/local/lib
+
+# Driver interface for Windows NDIS
+#CONFIG_DRIVER_NDIS=y
+#CFLAGS += -I/usr/include/w32api/ddk
+#LIBS += -L/usr/local/lib
+# For native build using mingw
+#CONFIG_NATIVE_WINDOWS=y
+# Additional directories for cross-compilation on Linux host for mingw target
+#CFLAGS += -I/opt/mingw/mingw32/include/ddk
+#LIBS += -L/opt/mingw/mingw32/lib
+#CC=mingw32-gcc
+# By default, driver_ndis uses WinPcap for low-level operations. This can be
+# replaced with the following option which replaces WinPcap calls with NDISUIO.
+# However, this requires that WZC is disabled (net stop wzcsvc) before starting
+# wpa_supplicant.
+# CONFIG_USE_NDISUIO=y
+
+# Driver interface for development testing
+#CONFIG_DRIVER_TEST=y
+
+# Driver interface for wired Ethernet drivers
+CONFIG_DRIVER_WIRED=y
+
+# Driver interface for the Broadcom RoboSwitch family
+#CONFIG_DRIVER_ROBOSWITCH=y
+
+# Driver interface for no driver (e.g., WPS ER only)
+#CONFIG_DRIVER_NONE=y
+
+# Solaris libraries
+#LIBS += -lsocket -ldlpi -lnsl
+#LIBS_c += -lsocket
+
+# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+# included)
+CONFIG_IEEE8021X_EAPOL=y
+
+# EAP-MD5
+CONFIG_EAP_MD5=y
+
+# EAP-MSCHAPv2
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-TLS
+CONFIG_EAP_TLS=y
+
+# EAL-PEAP
+CONFIG_EAP_PEAP=y
+
+# EAP-TTLS
+CONFIG_EAP_TTLS=y
+
+# EAP-FAST
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# EAP-GTC
+CONFIG_EAP_GTC=y
+
+# EAP-OTP
+CONFIG_EAP_OTP=y
+
+# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
+#CONFIG_EAP_SIM=y
+
+# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-pwd (secure authentication using only a password)
+#CONFIG_EAP_PWD=y
+
+# EAP-PAX
+#CONFIG_EAP_PAX=y
+
+# LEAP
+CONFIG_EAP_LEAP=y
+
+# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
+#CONFIG_EAP_AKA=y
+
+# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
+# This requires CONFIG_EAP_AKA to be enabled, too.
+#CONFIG_EAP_AKA_PRIME=y
+
+# Enable USIM simulator (Milenage) for EAP-AKA
+#CONFIG_USIM_SIMULATOR=y
+
+# EAP-SAKE
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-TNC and related Trusted Network Connect support (experimental)
+#CONFIG_EAP_TNC=y
+
+# Wi-Fi Protected Setup (WPS)
+CONFIG_WPS=y
+# Enable WSC 2.0 support
+CONFIG_WPS2=y
+# Enable WPS external registrar functionality
+CONFIG_WPS_ER=y
+# Disable credentials for an open network by default when acting as a WPS
+# registrar.
+#CONFIG_WPS_REG_DISABLE_OPEN=y
+# Enable WPS support with NFC config method
+#CONFIG_WPS_NFC=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# EAP-EKE
+#CONFIG_EAP_EKE=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+# engine.
+CONFIG_SMARTCARD=y
+
+# PC/SC interface for smartcards (USIM, GSM SIM)
+# Enable this if EAP-SIM or EAP-AKA is included
+#CONFIG_PCSC=y
+
+# Support HT overrides (disable HT/HT40, mask MCS rates, etc.)
+#CONFIG_HT_OVERRIDES=y
+
+# Support VHT overrides (disable VHT, mask MCS rates, etc.)
+#CONFIG_VHT_OVERRIDES=y
+
+# Development testing
+#CONFIG_EAPOL_TEST=y
+
+# Select control interface backend for external programs, e.g, wpa_cli:
+# unix = UNIX domain sockets (default for Linux/*BSD)
+# udp = UDP sockets using localhost (127.0.0.1)
+# named_pipe = Windows Named Pipe (default for Windows)
+# udp-remote = UDP sockets with remote access (only for tests systems/purpose)
+# y = use default (backwards compatibility)
+# If this option is commented out, control interface is not included in the
+# build.
+CONFIG_CTRL_IFACE=y
+
+# Include support for GNU Readline and History Libraries in wpa_cli.
+# When building a wpa_cli binary for distribution, please note that these
+# libraries are licensed under GPL and as such, BSD license may not apply for
+# the resulting binary.
+#CONFIG_READLINE=y
+
+# Include internal line edit mode in wpa_cli. This can be used as a replacement
+# for GNU Readline to provide limited command line editing and history support.
+CONFIG_WPA_CLI_EDIT=y
+
+# Remove debugging code that is printing out debug message to stdout.
+# This can be used to reduce the size of the wpa_supplicant considerably
+# if debugging code is not needed. The size reduction can be around 35%
+# (e.g., 90 kB).
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
+# 35-50 kB in code size.
+#CONFIG_NO_WPA=y
+
+# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
+# This option can be used to reduce code size by removing support for
+# converting ASCII passphrases into PSK. If this functionality is removed, the
+# PSK can only be configured as the 64-octet hexstring (e.g., from
+# wpa_passphrase). This saves about 0.5 kB in code size.
+#CONFIG_NO_WPA_PASSPHRASE=y
+
+# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
+# This can be used if ap_scan=1 mode is never enabled.
+#CONFIG_NO_SCAN_PROCESSING=y
+
+# Select configuration backend:
+# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
+#	path is given on command line, not here; this option is just used to
+#	select the backend that allows configuration files to be used)
+# winreg = Windows registry (see win_example.reg for an example)
+CONFIG_BACKEND=file
+
+# Remove configuration write functionality (i.e., to allow the configuration
+# file to be updated based on runtime configuration changes). The runtime
+# configuration can still be changed, the changes are just not going to be
+# persistent over restarts. This option can be used to reduce code size by
+# about 3.5 kB.
+#CONFIG_NO_CONFIG_WRITE=y
+
+# Remove support for configuration blobs to reduce code size by about 1.5 kB.
+#CONFIG_NO_CONFIG_BLOBS=y
+
+# Select program entry point implementation:
+# main = UNIX/POSIX like main() function (default)
+# main_winsvc = Windows service (read parameters from registry)
+# main_none = Very basic example (development use only)
+#CONFIG_MAIN=main
+
+# Select wrapper for operatins system and C library specific functions
+# unix = UNIX/POSIX like systems (default)
+# win32 = Windows systems
+# none = Empty template
+#CONFIG_OS=unix
+
+# Select event loop implementation
+# eloop = select() loop (default)
+# eloop_win = Windows events and WaitForMultipleObject() loop
+# eloop_none = Empty template
+#CONFIG_ELOOP=eloop
+
+# Should we use poll instead of select? Select is used by default.
+#CONFIG_ELOOP_POLL=y
+
+# Select layer 2 packet implementation
+# linux = Linux packet socket (default)
+# pcap = libpcap/libdnet/WinPcap
+# freebsd = FreeBSD libpcap
+# winpcap = WinPcap with receive thread
+# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+# none = Empty template
+#CONFIG_L2_PACKET=linux
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection), also known as PMF
+# Driver support is also needed for IEEE 802.11w.
+CONFIG_IEEE80211W=y
+
+# Select TLS implementation
+# openssl = OpenSSL (default)
+# gnutls = GnuTLS
+# internal = Internal TLSv1 implementation (experimental)
+# none = Empty template
+#CONFIG_TLS=openssl
+CONFIG_TLS=internal
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
+# can be enabled to get a stronger construction of messages when block ciphers
+# are used. It should be noted that some existing TLS v1.0 -based
+# implementation may not be compatible with TLS v1.1 message (ClientHello is
+# sent prior to negotiating which version will be used)
+#CONFIG_TLSV11=y
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
+# can be enabled to enable use of stronger crypto algorithms. It should be
+# noted that some existing TLS v1.0 -based implementation may not be compatible
+# with TLS v1.2 message (ClientHello is sent prior to negotiating which version
+# will be used)
+#CONFIG_TLSV12=y
+
+# If CONFIG_TLS=internal is used, additional library and include paths are
+# needed for LibTomMath. Alternatively, an integrated, minimal version of
+# LibTomMath can be used. See beginning of libtommath.c for details on benefits
+# and drawbacks of this option.
+CONFIG_INTERNAL_LIBTOMMATH=y
+#ifndef CONFIG_INTERNAL_LIBTOMMATH
+#LTM_PATH=/usr/src/libtommath-0.39
+#CFLAGS += -I$(LTM_PATH)
+#LIBS += -L$(LTM_PATH)
+#LIBS_p += -L$(LTM_PATH)
+#endif
+# At the cost of about 4 kB of additional binary size, the internal LibTomMath
+# can be configured to include faster routines for exptmod, sqr, and div to
+# speed up DH and RSA calculation considerably
+#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+
+# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
+# This is only for Windows builds and requires WMI-related header files and
+# WbemUuid.Lib from Platform SDK even when building with MinGW.
+#CONFIG_NDIS_EVENTS_INTEGRATED=y
+#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
+
+# Add support for old DBus control interface
+# (fi.epitest.hostap.WPASupplicant)
+#CONFIG_CTRL_IFACE_DBUS=y
+
+# Add support for new DBus control interface
+# (fi.w1.hostap.wpa_supplicant1)
+#CONFIG_CTRL_IFACE_DBUS_NEW=y
+
+# Add introspection support for new DBus control interface
+#CONFIG_CTRL_IFACE_DBUS_INTRO=y
+
+# Add support for loading EAP methods dynamically as shared libraries.
+# When this option is enabled, each EAP method can be either included
+# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
+# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
+# be loaded in the beginning of the wpa_supplicant configuration file
+# (see load_dynamic_eap parameter in the example file) before being used in
+# the network blocks.
+#
+# Note that some shared parts of EAP methods are included in the main program
+# and in order to be able to use dynamic EAP methods using these parts, the
+# main program must have been build with the EAP method enabled (=y or =dyn).
+# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
+# unless at least one of them was included in the main build to force inclusion
+# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
+# in the main build to be able to load these methods dynamically.
+#
+# Please also note that using dynamic libraries will increase the total binary
+# size. Thus, it may not be the best option for targets that have limited
+# amount of memory/flash.
+#CONFIG_DYNAMIC_EAP_METHODS=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
+#CONFIG_DEBUG_FILE=y
+
+# Send debug messages to syslog instead of stdout
+#CONFIG_DEBUG_SYSLOG=y
+# Set syslog facility for debug messages
+#CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
+
+# Add support for sending all debug messages (regardless of debug verbosity)
+# to the Linux kernel tracing facility. This helps debug the entire stack by
+# making it easy to record everything happening from the driver up into the
+# same file, e.g., using trace-cmd.
+#CONFIG_DEBUG_LINUX_TRACING=y
+
+# Add support for writing debug log to Android logcat instead of standard
+# output
+#CONFIG_ANDROID_LOG=y
+
+# Enable privilege separation (see README 'Privilege separation' for details)
+#CONFIG_PRIVSEP=y
+
+# Enable mitigation against certain attacks against TKIP by delaying Michael
+# MIC error reports by a random amount of time between 0 and 60 seconds
+#CONFIG_DELAYED_MIC_ERROR_REPORT=y
+
+# Enable tracing code for developer debugging
+# This tracks use of memory allocations and other registrations and reports
+# incorrect use with a backtrace of call (or allocation) location.
+#CONFIG_WPA_TRACE=y
+# For BSD, uncomment these.
+#LIBS += -lexecinfo
+#LIBS_p += -lexecinfo
+#LIBS_c += -lexecinfo
+
+# Use libbfd to get more details for developer debugging
+# This enables use of libbfd to get more detailed symbols for the backtraces
+# generated by CONFIG_WPA_TRACE=y.
+#CONFIG_WPA_TRACE_BFD=y
+# For BSD, uncomment these.
+#LIBS += -lbfd -liberty -lz
+#LIBS_p += -lbfd -liberty -lz
+#LIBS_c += -lbfd -liberty -lz
+
+# wpa_supplicant depends on strong random number generation being available
+# from the operating system. os_get_random() function is used to fetch random
+# data when needed, e.g., for key generation. On Linux and BSD systems, this
+# works by reading /dev/urandom. It should be noted that the OS entropy pool
+# needs to be properly initialized before wpa_supplicant is started. This is
+# important especially on embedded devices that do not have a hardware random
+# number generator and may by default start up with minimal entropy available
+# for random number generation.
+#
+# As a safety net, wpa_supplicant is by default trying to internally collect
+# additional entropy for generating random data to mix in with the data fetched
+# from the OS. This by itself is not considered to be very strong, but it may
+# help in cases where the system pool is not initialized properly. However, it
+# is very strongly recommended that the system pool is initialized with enough
+# entropy either by using hardware assisted random number generator or by
+# storing state over device reboots.
+#
+# wpa_supplicant can be configured to maintain its own entropy store over
+# restarts to enhance random number generation. This is not perfect, but it is
+# much more secure than using the same sequence of random numbers after every
+# reboot. This can be enabled with -e<entropy file> command line option. The
+# specified file needs to be readable and writable by wpa_supplicant.
+#
+# If the os_get_random() is known to provide strong random data (e.g., on
+# Linux/BSD, the board in question is known to have reliable source of random
+# data from /dev/urandom), the internal wpa_supplicant random pool can be
+# disabled. This will save some in binary size and CPU use. However, this
+# should only be considered for builds that are known to be used on devices
+# that meet the requirements described above.
+#CONFIG_NO_RANDOM_POOL=y
+
+# IEEE 802.11n (High Throughput) support (mainly for AP mode)
+CONFIG_IEEE80211N=y
+
+# Wireless Network Management (IEEE Std 802.11v-2011)
+# Note: This is experimental and not complete implementation.
+#CONFIG_WNM=y
+
+# Interworking (IEEE 802.11u)
+# This can be used to enable functionality to improve interworking with
+# external networks (GAS/ANQP to learn more about the networks and network
+# selection based on available credentials).
+#CONFIG_INTERWORKING=y
+
+# Hotspot 2.0
+#CONFIG_HS20=y
+
+# Disable roaming in wpa_supplicant
+#CONFIG_NO_ROAMING=y
+
+# AP mode operations with wpa_supplicant
+# This can be used for controlling AP mode operations with wpa_supplicant. It
+# should be noted that this is mainly aimed at simple cases like
+# WPA2-Personal while more complex configurations like WPA2-Enterprise with an
+# external RADIUS server can be supported with hostapd.
+CONFIG_AP=y
+
+# P2P (Wi-Fi Direct)
+# This can be used to enable P2P support in wpa_supplicant. See README-P2P for
+# more information on P2P operations.
+CONFIG_P2P=y
+
+# Enable TDLS support
+CONFIG_TDLS=y
+
+# Autoscan
+# This can be used to enable automatic scan support in wpa_supplicant.
+#See wpa_supplicant.conf for more information on autoscan usage.
+#
+# Enabling directly a module will enable autoscan support.
+# For exponential module:
+#CONFIG_AUTOSCAN_EXPONENTIAL=y
+# For periodic module:
+#CONFIG_AUTOSCAN_PERIODIC=y
+
+# Password (and passphrase, etc.) backend for external storage
+# These optional mechanisms can be used to add support for storing passwords
+# and other secrets in external (to wpa_supplicant) location. This allows, for
+# example, operating system specific key storage to be used
+#
+# External password backend for testing purposes (developer use)
+#CONFIG_EXT_PASSWORD_TEST=y
+
+#11AC support
+CONFIG_IEEE80211AC=y
+
+# driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
+# shipped with your distribution yet. If that is the case, you need to build
+# newer libnl version and point the hostapd build to use it.eap_
+#LIBS += -L$(LIBNL)/lib
+CONFIG_LIBNL20=y
+CONFIG_LIBNL32=y
+
+#WIFI Display support
+CONFIG_WIFI_DISPLAY=y
diff -urN hostap_2_4.orig/wpa_supplicant/config.c hostap_2_4/wpa_supplicant/config.c
--- hostap_2_4.orig/wpa_supplicant/config.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/config.c	2015-09-24 15:25:20.373038328 +0800
@@ -4189,6 +4189,9 @@
 	{ INT(key_mgmt_offload), 0},
 	{ INT(passive_scan), 0 },
 	{ INT(reassoc_same_bss_optim), 0 },
+#ifdef SAMSUNG_P2P_PREKEY
+	{ INT(disable_skip_wps), 0 },
+#endif
 };
 
 #undef FUNC
diff -urN hostap_2_4.orig/wpa_supplicant/config_file.c hostap_2_4/wpa_supplicant/config_file.c
--- hostap_2_4.orig/wpa_supplicant/config_file.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/config_file.c	2015-09-24 15:25:20.373038328 +0800
@@ -1063,12 +1063,37 @@
 	}
 #endif /* CONFIG_WPS */
 #ifdef CONFIG_P2P
+#ifdef SAMSUNG_SRID
+	/* 
+	 * Always save 81:1 in .conf file for listen regulatory class and listen 
+	 * channel. This will avoid wrong settings if TV is rebooted and conf 
+	 * file was updated to some other channels.
+	 */
+        if (config->p2p_listen_reg_class) {
+                if(config->p2p_listen_reg_class != 81 ) 
+                        config->p2p_listen_reg_class = 81;
+                fprintf(f, "p2p_listen_reg_class=%u\n",
+                        config->p2p_listen_reg_class);
+	}
+        if (config->p2p_listen_channel){
+                if(config->p2p_listen_channel != 1 )
+                        config->p2p_listen_channel = 1; 
+                fprintf(f, "p2p_listen_channel=%u\n",
+                        config->p2p_listen_channel);
+	}
+#else	
 	if (config->p2p_listen_reg_class)
 		fprintf(f, "p2p_listen_reg_class=%u\n",
 			config->p2p_listen_reg_class);
 	if (config->p2p_listen_channel)
 		fprintf(f, "p2p_listen_channel=%u\n",
 			config->p2p_listen_channel);
+#endif /* SAMSUNG_SRID */
+#ifdef SAMSUNG_P2P_PREKEY
+	if (config->disable_skip_wps)
+		fprintf(f, "disable_skip_wps=%u\n",
+			config->disable_skip_wps);
+#endif
 	if (config->p2p_oper_reg_class)
 		fprintf(f, "p2p_oper_reg_class=%u\n",
 			config->p2p_oper_reg_class);
diff -urN hostap_2_4.orig/wpa_supplicant/config.h hostap_2_4/wpa_supplicant/config.h
--- hostap_2_4.orig/wpa_supplicant/config.h	2015-09-24 15:25:20.349038329 +0800
+++ hostap_2_4/wpa_supplicant/config.h	2015-09-24 15:25:20.373038328 +0800
@@ -25,7 +25,12 @@
 #define DEFAULT_P2P_OPTIMIZE_LISTEN_CHAN 0
 #define DEFAULT_BSS_MAX_COUNT 200
 #define DEFAULT_BSS_EXPIRATION_AGE 180
+#ifdef SAMSUNG_SRID
+/* Bss expiration count to 1 */
 #define DEFAULT_BSS_EXPIRATION_SCAN_COUNT 2
+#else
+#define DEFAULT_BSS_EXPIRATION_SCAN_COUNT 2
+#endif /* SAMSUNG_SRID */
 #define DEFAULT_MAX_NUM_STA 128
 #define DEFAULT_ACCESS_NETWORK_TYPE 15
 #define DEFAULT_SCAN_CUR_FREQ 0
@@ -1163,6 +1168,13 @@
 	 * reassoc_same_bss_optim - Whether to optimize reassoc-to-same-BSS
 	 */
 	int reassoc_same_bss_optim;
+
+#ifdef SAMSUNG_P2P_PREKEY
+	/**
+	* disable_skip_wps - disable prekey function
+	**/
+	int disable_skip_wps;
+#endif
 };
 
 
diff -urN hostap_2_4.orig/wpa_supplicant/ctrl_iface.c hostap_2_4/wpa_supplicant/ctrl_iface.c
--- hostap_2_4.orig/wpa_supplicant/ctrl_iface.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/ctrl_iface.c	2015-09-24 15:25:20.373038328 +0800
@@ -36,6 +36,7 @@
 #include "ap.h"
 #include "p2p_supplicant.h"
 #include "p2p/p2p.h"
+#include "p2p/p2p_i.h"
 #include "hs20_supplicant.h"
 #include "wifi_display.h"
 #include "notify.h"
@@ -50,6 +51,289 @@
 #include "drivers/driver.h"
 #include "mesh.h"
 
+#ifdef TIZEN_PHY_FREQ // CONFIG_PHY_INFO_DISPLAY /* Display phy info in wpa_cli status */
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#define SIOCGIWNAME		0x8B01		/* get name == wireless protocol */
+#define SIOCGIWFREQ		0x8B05		/* get channel/frequency (Hz) */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+#define SIOCGIWRATE		0x8B21		/* get default bit rate (bps) */
+
+#define IW_QUAL_DBM		0x08	/* Level + Noise are dBm */
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+
+struct	iw_param
+{
+  s32		value;		/* The value of the parameter itself */
+  u8		fixed;		/* Hardware should not use auto select */
+  u8		disabled;	/* Disable the feature */
+  u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void		*pointer;	/* Pointer to the data  (in user space) */
+  u16		length;		/* number of fields or size in bytes */
+  u16		flags;		/* Optional params */
+};
+
+#ifdef __KERNEL__
+#ifdef CONFIG_COMPAT
+
+#include <linux/compat.h>
+
+struct compat_iw_point {
+	compat_caddr_t pointer;
+	u16 length;
+	u16 flags;
+};
+#endif
+#endif
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	u8		level;		/* signal level (dBm) */
+	u8		noise;		/* noise level (dBm) */
+	u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	u32		nwid;		/* Rx : Wrong nwid/essid */
+	u32		code;		/* Rx : Unable to code/decode (WEP) */
+	u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	u32		retries;	/* Tx : Max MAC retries num reached */
+	u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	s32		m;		/* Mantissa */
+	s16		e;		/* Exponent */
+	u8		i;		/* List index (when in range struct) */
+	u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Range of parameters
+ */
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	u32		min_nwid;	/* Minimal NWID we are able to set */
+	u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	u16		old_num_channels;
+	u8		old_num_frequency;
+
+	/* Scan capabilities */
+	u8		scan_capa; 	/* IW_SCAN_CAPA_* bit field */
+
+	/* Wireless event capability bitmasks */
+	u32		event_capa[6];
+
+	/* signal level threshold range */
+	s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	u8		num_bitrates;	/* Number of entries in the list */
+	s32		bitrate[32];	/* list, in bps */
+
+	/* RTS threshold */
+	s32		min_rts;	/* Minimal RTS threshold */
+	s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	s32		min_frag;	/* Minimal frag threshold */
+	s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	s32		min_pmp;	/* Minimal PM period */
+	s32		max_pmp;	/* Maximal PM period */
+	s32		min_pmt;	/* Minimal PM timeout */
+	s32		max_pmt;	/* Maximal PM timeout */
+	u16		pmp_flags;	/* How to decode max/min PM period */
+	u16		pmt_flags;	/* How to decode max/min PM timeout */
+	u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	u16	encoding_size[8];	/* Different token sizes */
+	u8	num_encoding_sizes;	/* Number of entry in the list */
+	u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	u16		txpower_capa;	/* What options are supported */
+	u8		num_txpower;	/* Number of entries in the list */
+	s32		txpower[8];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	u16		retry_capa;	/* What retry options are supported */
+	u16		retry_flags;	/* How to decode max/min retry limit */
+	u16		r_time_flags;	/* How to decode max/min retry life */
+	s32		min_retry;	/* Minimal number of retries */
+	s32		max_retry;	/* Maximal number of retries */
+	s32		min_r_time;	/* Minimal retry lifetime */
+	s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	u16		num_channels;	/* Number of channels [0; num - 1] */
+	u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[32];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+
+	u32		enc_capa;	/* IW_ENC_CAPA_* bit field */
+};
+
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+typedef struct wpa_supplicant_phy_info
+{
+	/* ieee80211 mode */
+	char		name[IFNAMSIZ + 1];	
+	/* bit rate in bps */  
+	int		has_bitrate;
+	struct iw_param	bitrate;		
+	/* stats */
+	int		has_stats;
+	struct iw_statistics	stats;
+	/* freq */
+    int		has_freq;
+ 	double freq;
+	int freq_flags;
+	/* range */
+	int		has_range;	
+	struct iw_range	range;
+}wpa_supplicant_phy_info;
+
+#define KILO	1e3
+#define MEGA	1e6
+#define GIGA	1e9
+#endif/* TIZEN_PHY_FREQ //CONFIG_PHY_INFO_DISPLAY */
+
+
 static int wpa_supplicant_global_iface_list(struct wpa_global *global,
 					    char *buf, int len);
 static int wpa_supplicant_global_iface_interfaces(struct wpa_global *global,
@@ -57,6 +341,12 @@
 static int * freq_range_to_channel_list(struct wpa_supplicant *wpa_s,
 					char *val);
 
+#ifdef TIZEN_PHY_FREQ
+   static void wpa_supplicant_phy_sock_deinit(int skfd);
+   static int wpa_supplicant_phy_sock_init(const char *caller);
+   static int wpa_supplicant_phy_freq_ioctl(int skfd, char *ifname, struct wpa_supplicant_phy_info *info);
+#endif /* TIZEN_PHY_FREQ */
+
 static int set_bssid_filter(struct wpa_supplicant *wpa_s, char *val)
 {
 	char *pos;
@@ -464,6 +754,62 @@
 	return ret;
 }
 
+//Tizen: Allow P2P framework to get the AP channel frequency from the P2P supplicant
+#ifdef TIZEN_PHY_FREQ
+int wpa_suppicant_get_freq_phy_device(struct wpa_supplicant *wpa_s)
+  {
+          int ret=-1, skfd;
+          struct wpa_supplicant_phy_info phy_info;
+  
+          os_memset(&phy_info, 0, sizeof(phy_info));
+  
+          if ((skfd = wpa_supplicant_phy_sock_init(__func__)) < 0)
+          {
+                  wpa_printf(MSG_INFO, "%s: socket error: %d", __func__, errno);
+                  return 0;
+          }
+  
+          wpa_printf(MSG_INFO, "wpa_s->ifname : [%s]", wpa_s->ifname);
+  
+          if(!strncmp("wlan0", wpa_s->ifname, strlen(wpa_s->ifname))) {
+                  if(wpa_supplicant_phy_freq_ioctl(skfd, "p2p0", &phy_info) != 0) {
+                          wpa_supplicant_phy_sock_deinit(skfd);
+                          return 0;
+                  }
+          } else if(!strncmp("p2p0", wpa_s->ifname, strlen(wpa_s->ifname))) {
+                  if(wpa_supplicant_phy_freq_ioctl(skfd, "wlan0", &phy_info) != 0) {
+                          wpa_supplicant_phy_sock_deinit(skfd);
+                          return 0;
+                  }
+          } else {
+                  wpa_supplicant_phy_sock_deinit(skfd);
+                  return 0;
+          }
+  
+          char vbuf[16] = {0};
+          snprintf(vbuf, sizeof(vbuf), "%g%c", (phy_info.freq / MEGA),'M');
+          ret = atoi(vbuf);
+  
+          wpa_supplicant_phy_sock_deinit(skfd);
+          return ret;
+  }
+
+
+static int wpa_supplicant_get_freq(struct wpa_supplicant *wpa_s, char *buf,
+                                                       size_t buflen)
+{
+       int ap_freq = 0;
+       int ret = -1;
+       ap_freq = wpa_suppicant_get_freq_phy_device(wpa_s);
+       wpa_printf(MSG_DEBUG, "ap_freq=%d",ap_freq);
+       if(ap_freq  > 0)
+               ret = os_snprintf(buf, buflen, "freq=%dHz\n", ap_freq);
+
+       return ret;
+}
+#endif /* TIZEN_PHY_FREQ */
+
+
 
 static int wpa_supplicant_ctrl_iface_get(struct wpa_supplicant *wpa_s,
 					 char *cmd, char *buf, size_t buflen)
@@ -497,6 +843,14 @@
 				       wpa_s->last_gtk_len);
 		return res;
 #endif /* CONFIG_TESTING_GET_GTK */
+#ifdef TIZEN_PHY_FREQ
+    } else if (os_strcasecmp(cmd, "freq") == 0) {
+		res = wpa_supplicant_get_freq(wpa_s, buf, buflen);
+		if (res < 0)
+			wpa_printf(MSG_INFO, "%s: get  freq failed", __func__);
+		else
+			wpa_printf(MSG_INFO, "%s: freq ", buf);
+#endif /* TIZEN_PHY_FREQ */
 	} else if (os_strcmp(cmd, "tls_library") == 0) {
 		res = tls_get_library_version(buf, buflen);
 	} else {
@@ -552,6 +906,78 @@
 }
 #endif /* CONFIG_PEERKEY */
 
+#ifdef CONFIG_WFD_TDLS
+int wifi_display_update_tdls_wfd_ie(struct wpa_supplicant *wpa_s, int action_code)
+{
+        struct wpabuf *e, *buf, *wfd_ie;
+        size_t len = 0; 
+        int ret; 
+
+        if (wpa_s->global->wfd_subelem[WFD_SUBELEM_DEVICE_INFO]) {
+                        e = wpa_s->global->wfd_subelem[WFD_SUBELEM_DEVICE_INFO];
+        } else {
+                wpa_printf(MSG_ERROR, "There is no wfd subelem!. set it first");
+                return -1;
+        }
+        if (e->buf[0] == WFD_SUBELEM_DEVICE_INFO) {
+                wpa_printf(MSG_DEBUG, "Device Info = 0x%04x", WPA_GET_BE16(&e->buf[3]));
+
+                if (0x80 != (WPA_GET_BE16(&e->buf[3]) & 0x80)) {
+                        wpa_printf(MSG_ERROR, "Can not set WFD info as TDLS "
+                                                                        " preferred connectivity BIT not set");
+                        return -1;
+                } else {
+                        if (wpa_s->global->wfd_subelem[WFD_SUBELEM_DEVICE_INFO])
+                                len += wpabuf_len(wpa_s->global->wfd_subelem[
+                                                          WFD_SUBELEM_DEVICE_INFO]);
+                        if (wpa_s->global->wfd_subelem[WFD_SUBELEM_ASSOCIATED_BSSID])
+                                len += wpabuf_len(wpa_s->global->wfd_subelem[
+                                                          WFD_SUBELEM_ASSOCIATED_BSSID]);
+                        if (wpa_s->global->wfd_subelem[WFD_SUBELEM_LOCAL_IP_ADDRESS])
+                                len += wpabuf_len(wpa_s->global->wfd_subelem[
+                                                          WFD_SUBELEM_LOCAL_IP_ADDRESS]);
+
+                        /*TDLS WFD IE header + data*/
+                        buf = wpabuf_alloc(len);
+                        if (buf == NULL)
+                                return -1;
+
+                        if (wpa_s->global->wfd_subelem[WFD_SUBELEM_DEVICE_INFO])
+                                wpabuf_put_buf(buf,
+                                        wpa_s->global->wfd_subelem[WFD_SUBELEM_DEVICE_INFO]);
+                        if (wpa_s->global->wfd_subelem[WFD_SUBELEM_ASSOCIATED_BSSID])
+                                wpabuf_put_buf(buf,
+                                        wpa_s->global->wfd_subelem[WFD_SUBELEM_ASSOCIATED_BSSID]);
+                        if (wpa_s->global->wfd_subelem[WFD_SUBELEM_LOCAL_IP_ADDRESS])
+                                wpabuf_put_buf(buf,
+                                        wpa_s->global->wfd_subelem[WFD_SUBELEM_LOCAL_IP_ADDRESS]);
+                        /* Add wfd ie header */
+                        wfd_ie = wifi_display_encaps(buf);
+
+                        ret = wpa_drv_send_tdls_mgmt(wpa_s, broadcast_ether_addr, action_code,
+                                                                1, 0, 0, 0, wpabuf_head(wfd_ie), wpabuf_len(wfd_ie));
+                        if (ret)
+                                wpa_printf(MSG_ERROR, "Failed to set TDLS Wfd IE");
+
+                        wpabuf_free(wfd_ie);
+                }
+        }
+        return 0;
+}
+int wifi_set_tdls_mode(struct wpa_supplicant *wpa_s, char *cmd)
+{
+        int ret, oper_mode;
+
+        oper_mode = atoi(cmd);
+
+        ret = wpa_drv_send_tdls_mgmt(wpa_s, broadcast_ether_addr, oper_mode,
+                        1, 0, 0, 0, NULL, 0);
+	if(ret)
+		wpa_printf(MSG_ERROR, "Failed to set TDLS mode");
+
+        return 0;
+}
+#endif /* CONFIG_WFD_TDLS */
 
 #ifdef CONFIG_TDLS
 
@@ -869,6 +1295,12 @@
 		return -1;
 	}
 
+#ifdef SAMSUNG_P2P_PREKEY
+	if(!wpa_s->global->p2p->cfg->disable_skip_wps
+			&& (wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT))
+		wpa_s->global->p2p->cfg->isPreKey = SAMSUNG_PREKEY_SUPPORT_WPS_STARTED;
+#endif /* SAMSUNG_P2P_PREKEY */
+
 #ifdef CONFIG_AP
 	if (wpa_s->ap_iface)
 		return wpa_supplicant_ap_wps_pbc(wpa_s, _bssid, _p2p_dev_addr);
@@ -1694,6 +2126,379 @@
 #endif /* IEEE8021X_EAPOL */
 }
 
+#ifdef TIZEN_PHY_FREQ //CONFIG_PHY_INFO_DISPLAY /* Display phy info in wpa_cli status */
+void wpa_supplicant_phy_bitrate_unit_convert(char *buffer, int buflen, int bitrate)
+{
+	double	rate = bitrate;
+	char		scale;
+	int		divisor;
+
+	if(rate >= GIGA)
+	{
+		scale = 'G';
+		divisor = GIGA;
+	}
+  	else
+	{
+		if(rate >= MEGA)
+		{
+			scale = 'M';
+			divisor = MEGA;
+		}
+		else
+		{
+			scale = 'k';
+			divisor = KILO;
+		}
+	}
+	snprintf(buffer, buflen, "%g%c", rate / divisor, scale);
+}
+
+void wpa_supplicant_phy_freq_unit_convert(char *buffer, int buflen, double freq)
+{
+	char scale;
+	int divisor;
+
+	if(freq >= GIGA)
+	{
+		scale = 'G';
+		divisor = GIGA;
+	}
+  	else
+	{
+		if(freq >= MEGA)
+		{
+			scale = 'M';
+			divisor = MEGA;
+		}
+		else
+		{
+			scale = 'k';
+			divisor = KILO;
+		}
+	}
+	snprintf(buffer, buflen, "%g%c", freq / divisor, scale);
+}
+
+void wpa_supplicant_phy_80211mode_convert(char *dst, char *src)
+{
+	/* convert from driver standard string to customized string */
+	if (os_strncmp(src, "IEEE 802.11abgn", 15) == 0)
+		strncpy(dst, "802.11a/b/g/n", IFNAMSIZ);		
+	else if (os_strncmp(src, "IEEE 802.11bgn", 14) == 0)
+		strncpy(dst, "802.11b/g/n", IFNAMSIZ);
+	else if (os_strncmp(src, "IEEE 802.11ng", 13) == 0)
+		strncpy(dst, "802.11b/g/n", IFNAMSIZ);
+	else if (os_strncmp(src, "IEEE 802.11na", 13) == 0)
+		strncpy(dst, "802.11a/n", IFNAMSIZ);
+	else if (os_strncmp(src, "IEEE 802.11a", 12) == 0)
+		strncpy(dst, "802.11a", IFNAMSIZ);
+	else if (os_strncmp(src, "IEEE 802.11b", 12) == 0)
+		strncpy(dst, "802.11b", IFNAMSIZ);	
+	else if (os_strncmp(src, "IEEE 802.11g", 12) == 0)
+		strncpy(dst, "802.11b/g", IFNAMSIZ); 	
+	else
+    	strncpy(dst, "802.11", IFNAMSIZ);
+
+	dst[IFNAMSIZ] = '\0';
+	return;
+}
+
+double wpa_supplicant_phy_freq_convert(struct iw_freq *in)
+{
+	int i;
+	double res = (double) in->m;
+	
+	for(i = 0; i < in->e; i++)
+		res *= 10;
+
+	return(res);
+}
+
+int wpa_supplicant_phy_sock_init(const char *caller)
+{
+	int sockfd;
+	char buf[50];
+
+	if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+    		os_snprintf(buf, 50, "%s: socket err caller: %s", __func__, caller);
+    		perror(buf);
+	}
+
+	return sockfd;
+}
+
+void wpa_supplicant_phy_sock_deinit(int skfd)
+{
+	close(skfd);
+}
+
+static int wpa_supplicant_phy_range_ioctl(int skfd, 
+			char *ifname, struct wpa_supplicant_phy_info *info)
+{
+	struct iwreq wrq;
+
+	memset(&wrq, 0, sizeof(struct iwreq));
+
+	/* Get range */
+	wrq.u.data.pointer = (caddr_t) &(info->range);
+	wrq.u.data.length = sizeof(struct iw_range);
+	wrq.u.data.flags = 0;
+  
+	strncpy(wrq.ifr_name, ifname, IFNAMSIZ-1);
+	wrq.ifr_name[IFNAMSIZ-1] = '\0';	/* Prevent Bug Fix */
+
+	if(ioctl(skfd, SIOCGIWRANGE, &wrq) < 0)
+	{
+        wpa_printf(MSG_INFO, "%s: ioctl failed", __func__); 				
+		return -1;
+	}
+	else
+	{
+		info->has_range = 1;
+	}	
+	
+	return 0;
+}
+
+static int wpa_supplicant_phy_80211mode_ioctl(int skfd, char *ifname, 
+					struct wpa_supplicant_phy_info *info)
+{
+	struct iwreq wrq;
+
+	memset(&wrq, 0, sizeof(struct iwreq));
+	
+	/* Get wireless name */
+
+	memset(&wrq, 0, sizeof(struct iwreq)); 
+	strncpy(wrq.ifr_name, ifname, IFNAMSIZ-1);
+	wrq.ifr_name[IFNAMSIZ-1] = '\0';	/* Prevent Bug Fix */
+	
+	if(ioctl(skfd, SIOCGIWNAME, &wrq) < 0)
+	{
+        wpa_printf(MSG_INFO, "%s: ioctl failed", __func__);	
+		return -1;
+	}
+	else
+	{
+    	wpa_supplicant_phy_80211mode_convert(info->name, wrq.u.name);
+	}
+	
+	return 0;
+}
+
+static int wpa_supplicant_phy_rate_ioctl(int skfd, char *ifname, 
+					struct wpa_supplicant_phy_info *info)
+{
+	struct iwreq wrq;
+	
+	memset(&wrq, 0, sizeof(struct iwreq));
+
+	/* Get bit rate */
+	memset(&wrq, 0, sizeof(struct iwreq));
+	strncpy(wrq.ifr_name, ifname, IFNAMSIZ - 1);
+	wrq.ifr_name[IFNAMSIZ-1] = '\0';	/* Prevent Bug Fix */
+	
+	if(ioctl(skfd, SIOCGIWRATE, &wrq) < 0)
+	{
+        wpa_printf(MSG_INFO, "%s: ioctl failed", __func__);		
+		return -1;
+	}
+	else
+	{
+		info->has_bitrate = 1;
+		memcpy(&(info->bitrate), &(wrq.u.bitrate), sizeof(struct iw_param));		
+	}	
+
+	return 0;
+}
+
+static int wpa_supplicant_phy_stats_ioctl(int skfd, char *ifname, 
+					struct wpa_supplicant_phy_info *info)
+{
+	struct iwreq wrq;
+	
+	memset(&wrq, 0, sizeof(struct iwreq));
+
+	/* Get stats */
+	memset(&wrq, 0, sizeof(struct iwreq));
+	wrq.u.data.pointer = (caddr_t) &(info->stats);
+	wrq.u.data.length = sizeof(struct iw_statistics);
+	wrq.u.data.flags = 1;		/* Clear updated flag */
+	strncpy(wrq.ifr_name, ifname, IFNAMSIZ - 1);
+	wrq.ifr_name[IFNAMSIZ-1] = '\0';	/* Prevent Bug Fix */
+	
+	if(ioctl(skfd, SIOCGIWSTATS, &wrq) < 0)
+	{        
+		wpa_printf(MSG_INFO, "%s: ioctl failed", __func__);
+		return -1;
+	}
+	else
+	{
+		info->has_stats = 1;
+	}
+
+	return 0;
+}
+
+static int wpa_supplicant_phy_freq_ioctl(int skfd, char *ifname, 
+					struct wpa_supplicant_phy_info *info)
+{
+	struct iwreq wrq;
+	
+	memset(&wrq, 0, sizeof(struct iwreq));
+
+	/* Get channel/freq */
+	memset(&wrq, 0, sizeof(struct iwreq));
+	strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+	wrq.ifr_name[strlen(wrq.ifr_name)] = '\0';
+	
+	if(ioctl(skfd, SIOCGIWFREQ, &wrq) < 0)
+	{
+        wpa_printf(MSG_INFO, "%s: ioctl failed", __func__);		
+		return -1;
+	}
+	else
+	{	
+		info->has_freq = 1;		
+      	info->freq = wpa_supplicant_phy_freq_convert(&(wrq.u.freq));
+		info->freq_flags = wrq.u.freq.flags;
+	}	
+	return 0;
+}
+
+static int wpa_supplicant_phy_status(struct wpa_supplicant *wpa_s, char *buf, 
+					size_t buflen, int verbose)
+{
+	int ret, skfd;
+	struct wpa_supplicant_phy_info phy_info;
+	char buffer[128] = {0};	/* Temporary buffer */
+	int reply_len = 0;
+	struct wpa_ssid *ssid = wpa_s->current_ssid;
+	
+	os_memset(&phy_info, 0, sizeof(phy_info));
+	if ((skfd = wpa_supplicant_phy_sock_init(__func__)) < 0)
+	{
+        	wpa_printf(MSG_INFO, "%s: socket error: %d", __func__, errno); 
+        	return -1;
+	}	
+
+	/* Range info */
+	wpa_supplicant_phy_range_ioctl(skfd, wpa_s->ifname, &phy_info);
+
+	/* Display device name and wireless name (name of the protocol used) */	
+	if (wpa_supplicant_phy_80211mode_ioctl(skfd, wpa_s->ifname, &phy_info) != 0) 
+		ret = os_snprintf(buf, buflen, "protocol_caps=N/A\n");
+	else
+		ret = os_snprintf(buf, buflen, "protocol_caps=%s\n", phy_info.name);
+
+	if (ret < 0 || ret >= buflen)
+		goto sock_deinit;
+	
+	buf += ret;
+	buflen -= ret;
+	reply_len += ret;
+	
+	/* Display the currently used/set bit-rate */
+	if(ssid) {
+		if(ssid->mode == WPAS_MODE_P2P_GO || ssid->mode == WPAS_MODE_AP) {
+			/* Get Operation freq first */
+			if (wpa_supplicant_phy_freq_ioctl(skfd, wpa_s->ifname, &phy_info) != 0)
+				ret = os_snprintf(buf, buflen, "rate=N/A\n");
+			else {
+				if(phy_info.has_freq) {
+					char vbuf[16] = {0};
+					wpa_supplicant_phy_freq_unit_convert(vbuf, sizeof(vbuf), phy_info.freq);
+					
+					if(strncmp(vbuf, "2", 1) == 0) /* 2.4GHz */
+						ret = os_snprintf(buf, buflen, "rate=%s\nbandwidth=%s\nGI=%s\n",
+						        "130M", "20MHz", "long");
+					else if(strncmp(vbuf, "5", 1) == 0) /* 5GHz */
+					    if ((int)(phy_info.freq / MEGA) >= 5825)
+							ret = os_snprintf(buf, buflen, "rate=%s\nbandwidth=%s\nGI=%s\n",
+						        "130M", "20MHz", "long");
+						else
+							ret = os_snprintf(buf, buflen, "rate=%s\nbandwidth=%s\nGI=%s\n",
+						        "300M", "40MHz", "short");
+					else /* Can not get correct band, rate is N/A */
+						ret = os_snprintf(buf, buflen, "rate=N/A\n");
+				} else
+					ret = os_snprintf(buf, buflen, "rate=N/A\n");
+			}
+		} else { /* Station or p2p-client mode */
+			if (wpa_supplicant_phy_rate_ioctl(skfd, wpa_s->ifname, &phy_info) != 0)
+				ret = os_snprintf(buf, buflen, "rate=N/A\n");		
+			else {
+				if(phy_info.has_bitrate) {
+					wpa_supplicant_phy_bitrate_unit_convert(buffer, sizeof(buffer), phy_info.bitrate.value);
+
+					ret = os_snprintf(buf, buflen, "rate=%s\nbandwidth=%s\nGI=%s\n",
+					        buffer, phy_info.bitrate.flags & 0x2 ? "40MHz" : "20MHz",
+					        phy_info.bitrate.flags & 0x4 ? "short" : "long");
+				}
+			}
+		}
+	} else
+		ret = os_snprintf(buf, buflen, "rate=N/A\n");
+	
+	if (ret < 0 || ret >= buflen)
+		goto sock_deinit;
+	
+	buf += ret;
+	buflen -= ret;
+	reply_len += ret;	
+
+	/* Display statistics */	
+	if (wpa_supplicant_phy_stats_ioctl(skfd, wpa_s->ifname, &phy_info) != 0) 			
+		ret = os_snprintf(buf, buflen, "signal_level=N/A\n");
+	else
+	{
+		if(phy_info.has_stats)
+		{  
+			if((phy_info.stats.qual.level != 0) || (phy_info.stats.qual.updated & (IW_QUAL_DBM )))
+			{
+				/* Deal with quality : always a relative value */
+				if(!(phy_info.stats.qual.updated & IW_QUAL_QUAL_INVALID))
+				{
+				
+					ret = os_snprintf(buf, buflen, "signal_level=%d dBm\n", (phy_info.stats.qual.level - 0x100));
+				}  
+			}
+		}
+	}
+	
+	if (ret < 0 || ret >= buflen)
+		goto sock_deinit;
+	
+	buf += ret;
+	reply_len += ret;	
+
+	/* Display the currently freq (unit: MHz)*/					
+	if (wpa_supplicant_phy_freq_ioctl(skfd, wpa_s->ifname, &phy_info) != 0)
+		ret = os_snprintf(buf, buflen, "freq=N/A\n");
+	else
+	{
+		if(phy_info.has_freq)
+		{
+			char	vbuf[16] = {0};
+			wpa_supplicant_phy_freq_unit_convert(vbuf, sizeof(vbuf), phy_info.freq);	
+			ret = os_snprintf(buf, buflen, "freq=%sHz\n", vbuf);	
+		}
+	}
+	
+	if (ret < 0 || ret >= buflen)
+		goto sock_deinit;
+	
+	buf += ret;
+	buflen -= ret;
+	reply_len += ret;
+
+sock_deinit:	
+	wpa_supplicant_phy_sock_deinit(skfd);
+	
+	return reply_len;
+}
+#endif /* TIZEN_PHY_FREQ // CONFIG_PHY_INFO_DISPLAY */
 
 static int wpa_supplicant_ctrl_iface_status(struct wpa_supplicant *wpa_s,
 					    const char *params,
@@ -1997,6 +2802,17 @@
 		}
 	}
 #endif /* ANDROID */
+#ifdef TIZEN_PHY_FREQ // CONFIG_PHY_INFO_DISPLAY /* Display phy info in wpa_cli status */
+	        if (wpa_s->wpa_state >= WPA_ASSOCIATED){
+	                res = wpa_supplicant_phy_status(wpa_s, pos, end - pos, verbose);
+		        if (res < 0){
+                	        wpa_printf(MSG_INFO, "%s: get phy status failed", __func__);
+	                	return pos - buf;
+			}
+		        pos += res;
+		    }
+#endif/* TIZEN_PHY_FREQ CONFIG_PHY_INFO_DISPLAY */
+
 
 	return pos - buf;
 }
@@ -5473,7 +6289,35 @@
 {
 	int freq = 0, ht40, vht;
 	char *pos;
-
+#ifdef SAMSUNG_P2P_GROUP_ADD
+	/* Accept ssid and passphrase from command line */
+	/* Currently ssid and passphrase feature is disabled becasue it can 
+	 * Alos be enabled using default methods:
+	 * ADD_NETWORK
+	 * 0
+	 * SET_NETWORK 0 ssid "Purushottam"
+	 * SET_NETWORK 0 psk "12345678"
+	 * SET_NETWORK 0 mode 3 
+	 * SET_NETWORK 0 disabled 2
+	 * P2P_GROUP_ADD persistent=0 freq=2412
+	 */
+	int persistent_group = 0;
+	char *ssid, *passphrase, *tmp;
+	ssid = os_strstr(cmd, "ssid=");
+	passphrase = os_strstr(cmd, "passphrase=");
+	if(ssid){
+		ssid += 5;
+		tmp = os_strstr(ssid, " ");
+		if(tmp)
+			*tmp = '\0';
+	}
+	if(passphrase){
+		passphrase += 11;
+		tmp = os_strstr(passphrase, " ");
+		if(tmp)
+			*tmp = '\0';
+	}
+#endif /* SAMSUNG_P2P_GROUP_ADD */
 	pos = os_strstr(cmd, "freq=");
 	if (pos)
 		freq = atoi(pos + 5);
@@ -5485,6 +6329,15 @@
 	if (os_strncmp(cmd, "persistent=", 11) == 0)
 		return p2p_ctrl_group_add_persistent(wpa_s, cmd + 11, freq,
 						     ht40, vht);
+#ifdef SAMSUNG_P2P_GROUP_ADD
+	if (os_strcmp(cmd, "persistent") == 0 ||
+	    os_strncmp(cmd, "persistent ", 11) == 0)
+		persistent_group  = 1;	
+
+	if(persistent_group || (os_strncmp(cmd, "freq=", 5) == 0) || ht40)
+		return wpas_p2p_group_add(wpa_s, persistent_group, freq, 
+			ht40, vht, ssid, passphrase);
+#else		
 	if (os_strcmp(cmd, "persistent") == 0 ||
 	    os_strncmp(cmd, "persistent ", 11) == 0)
 		return wpas_p2p_group_add(wpa_s, 1, freq, ht40, vht);
@@ -5492,6 +6345,7 @@
 		return wpas_p2p_group_add(wpa_s, 0, freq, ht40, vht);
 	if (ht40)
 		return wpas_p2p_group_add(wpa_s, 0, freq, ht40, vht);
+#endif /* SAMSUNG_P2P_GROUP_ADD */
 
 	wpa_printf(MSG_DEBUG, "CTRL: Invalid P2P_GROUP_ADD parameters '%s'",
 		   cmd);
@@ -5788,6 +6642,53 @@
 		return 0;
 	}
 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+        if (os_strcmp(cmd, "static_ip") == 0) { 
+                p2p_set_static_ip(wpa_s->global->p2p, inet_addr(param));
+                return 0;
+        }
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        if (os_strcmp(cmd, "RGI_value") == 0) {
+                int go_intent = atoi(param);
+                if(go_intent < -1 || go_intent > 15)
+                {
+                        wpa_printf(MSG_DEBUG, "Invalid Requested GO Intent: "
+                        "%d", go_intent);
+                        return -1;
+                }
+                else if(go_intent == -1){
+                        if(wpa_s->global->p2p->cfg->ON_req_go_intent == 0){
+                                wpa_printf(MSG_DEBUG, "Invalid Request, RGI is disable");
+                                return -1;
+                        }
+                        else
+                                wpa_s->global->p2p->cfg->enable_req_go_intent = 0;
+                }
+                else {
+                        wpa_s->global->p2p->cfg->enable_req_go_intent = 1;
+                        p2p_set_req_go_intent(wpa_s->global->p2p, go_intent);
+                }
+                return 0;
+        }
+
+        if (os_strcmp(cmd, "RGI_enable") == 0) {
+                int enable = atoi(param);
+                if(enable == 1)
+                        wpa_s->global->p2p->cfg->ON_req_go_intent = 1;
+                else if(enable == 0){
+			wpa_s->global->p2p->cfg->ON_req_go_intent = 0;
+                }
+                else {
+                        wpa_printf(MSG_DEBUG, "Invalid RGI enable value: "
+                        "%d", enable);
+                        return -1;
+                }
+                return 0;
+        }
+#endif /* SAMSUNG_GO_INTENT_REQUEST */
+
 	if (os_strcmp(cmd, "disallow_freq") == 0)
 		return p2p_ctrl_disallow_freq(wpa_s, param);
 
@@ -5902,12 +6803,19 @@
 	const char *pos;
 	u8 peer[ETH_ALEN];
 	int iface_addr = 0;
-
+	
 	pos = cmd;
 	if (os_strncmp(pos, "iface=", 6) == 0) {
 		iface_addr = 1;
 		pos += 6;
 	}
+#ifdef TIZEN_P2P_DISCONNECT
+	char *peer_addr = os_strstr(cmd, "peer_addr=");
+	if (peer_addr) {
+		iface_addr = 1;
+		pos = peer_addr + 10;
+	}
+#endif /* TIZEN_P2P_DISCONNECT */
 	if (hwaddr_aton(pos, peer))
 		return -1;
 
@@ -8066,7 +8974,11 @@
 		if (wpas_p2p_group_remove(wpa_s, buf + 17))
 			reply_len = -1;
 	} else if (os_strcmp(buf, "P2P_GROUP_ADD") == 0) {
+#ifdef SAMSUNG_P2P_GROUP_ADD		
+		if (wpas_p2p_group_add(wpa_s, 0, 0, 0, 0, NULL, NULL))
+#else		
 		if (wpas_p2p_group_add(wpa_s, 0, 0, 0, 0))
+#endif			
 			reply_len = -1;
 	} else if (os_strncmp(buf, "P2P_GROUP_ADD ", 14) == 0) {
 		if (p2p_ctrl_group_add(wpa_s, buf + 14))
@@ -8133,6 +9045,21 @@
 	} else if (os_strcmp(buf, "P2P_EXT_LISTEN") == 0) {
 		if (p2p_ctrl_ext_listen(wpa_s, "") < 0)
 			reply_len = -1;
+#ifdef TIZEN_P2P_LISTEN
+         } else if (os_strcmp(buf, "P2P_LISTEN_RESUME") == 0) { 
+                extern void wpa_check_p2p_listen_resume(struct wpa_supplicant *wpa_s);
+                wpa_check_p2p_listen_resume(wpa_s);
+                reply_len = 2; 
+         } else if (os_strncmp(buf, "P2P_LISTEN_STOP ", 16) == 0) { 
+                reply_len = wpas_check_p2p_listen_stop(wpa_s, buf + 16); 
+                if(reply_len == 0)
+                        reply_len = 2; 
+#endif /* TIZEN_P2P_LISTEN */			
+#ifdef TIZEN_P2P_DISCONNECT
+	} else if (os_strncmp(buf, "P2P_DISCONNECT ", 15) == 0) {
+		if (p2p_ctrl_remove_client(wpa_s, buf + 15) < 0)
+			reply_len = -1;
+#endif /* TIZEN_P2P_DISCONNECT */
 	} else if (os_strncmp(buf, "P2P_REMOVE_CLIENT ", 18) == 0) {
 		if (p2p_ctrl_remove_client(wpa_s, buf + 18) < 0)
 			reply_len = -1;
@@ -8144,6 +9071,18 @@
 	} else if (os_strncmp(buf, "WFD_SUBELEM_GET ", 16) == 0) {
 		reply_len = wifi_display_subelem_get(wpa_s->global, buf + 16,
 						     reply, reply_size);
+#ifdef CONFIG_WFD_TDLS
+        } else if (os_strncmp(buf, "WFD_SET_TDLS_IE ", 16) == 0) {
+                int action_code;
+
+                action_code = atoi(buf+16);
+
+                if (wifi_display_update_tdls_wfd_ie(wpa_s, action_code) < 0)
+                        reply_len = -1;
+        } else if (os_strncmp(buf, "WFD_SET_TDLS_MODE ", 18) == 0) {
+                if (wifi_set_tdls_mode(wpa_s, buf + 18) < 0)
+                        reply_len = -1;
+#endif /* CONFIG_WFD_TDLS */
 #endif /* CONFIG_WIFI_DISPLAY */
 #ifdef CONFIG_INTERWORKING
 	} else if (os_strcmp(buf, "FETCH_ANQP") == 0) {
@@ -8635,6 +9574,12 @@
 	end = buf + len;
 
 	while (wpa_s) {
+#ifdef SAMSUNG_SRID
+                /* To notify disabled state of Driver [Interface down] */
+                if(wpa_s->interface_disabled)
+                        res = os_snprintf(pos, end - pos, "%s FAIL\n", wpa_s->ifname);
+                else
+#endif /* SAMSUNG_SRID */
 		res = os_snprintf(pos, end - pos, "%s\n", wpa_s->ifname);
 		if (os_snprintf_error(end - pos, res)) {
 			*pos = '\0';
@@ -8688,6 +9633,9 @@
 		"P2P_CANCEL",
 		"P2P_PRESENCE_REQ",
 		"P2P_EXT_LISTEN",
+#ifdef TIZEN_P2P_LISTEN
+		"P2P_LISTEN_RESUME",
+#endif /* TIZEN_P2P_LISTEN */
 		NULL
 	};
 	static const char * prefix[] = {
@@ -8716,6 +9664,12 @@
 		"P2P_UNAUTHORIZE ",
 		"P2P_PRESENCE_REQ ",
 		"P2P_EXT_LISTEN ",
+#ifdef TIZEN_P2P_LISTEN
+		"P2P_LISTEN_STOP ",
+#endif /* TIZEN_P2P_LISTEN */
+#ifdef TIZEN_P2P_DISCONNECT
+		"P2P_DISCONNECT ",
+#endif /* TIZEN_P2P_DISCONNECT */
 		"P2P_REMOVE_CLIENT ",
 		"WPS_NFC_TOKEN ",
 		"WPS_NFC_TAG_READ ",
@@ -8989,3 +9943,77 @@
 	*resp_len = reply_len;
 	return reply;
 }
+
+#ifdef SAMSUNG_KPI
+int KPIGetStatus(struct wpa_supplicant *wpa_s, char *pBuf)
+{
+        int skfd;
+
+        char tempbuf[100] = {0,};
+        struct wpa_supplicant_phy_info phy_info;
+
+        os_memset(&phy_info, 0, sizeof(phy_info));
+
+        os_snprintf(pBuf, strlen("mac=00:00:00")+1, "mac=%02x:%02x:%02x", wpa_s->bssid[0],wpa_s->bssid[1], wpa_s->bssid[2]);
+
+        if ((skfd = wpa_supplicant_phy_sock_init(__func__)) < 0) 
+        {
+                wpa_printf(MSG_INFO, "%s: socket error: %d", __func__, errno);
+                return -1;
+        }
+
+        if (wpa_supplicant_phy_stats_ioctl(skfd, wpa_s->ifname, &phy_info) != 0)
+                os_snprintf(tempbuf, strlen(";rssi=N/A")+1, ";rssi=N/A");
+        else
+        {
+                if(phy_info.has_stats)
+                {
+                        if((phy_info.stats.qual.level != 0) || (phy_info.stats.qual.updated & (IW_QUAL_DBM )))
+                        {
+                                /* Deal with quality : always a relative value */
+                                if(!(phy_info.stats.qual.updated & IW_QUAL_QUAL_INVALID))
+                                {
+
+                                        os_snprintf(tempbuf, strlen(";rssi=0000")+1, ";rssi=%4d", (phy_info.stats.qual.level - 0x100));
+                                }
+                        }
+                }
+        }
+        strncat(pBuf, tempbuf, strlen(tempbuf));
+
+        /* Display the currently freq (unit: MHz)*/
+        if (wpa_supplicant_phy_freq_ioctl(skfd, wpa_s->ifname, &phy_info) != 0)
+                os_snprintf(tempbuf, strlen(";freq=N/A")+1, ";freq=N/A");
+        else
+        {
+                if(phy_info.has_freq)
+                {
+                        os_snprintf(tempbuf, strlen(";freq=0000")+1, ";freq=%4g", phy_info.freq/MEGA);
+                }
+        }
+        strncat(pBuf, tempbuf, strlen(tempbuf));
+
+        /* Display device name and wireless name (name of the protocol used) */
+        if (wpa_supplicant_phy_80211mode_ioctl(skfd, wpa_s->ifname, &phy_info) != 0)
+                os_snprintf(tempbuf, strlen(";prot=N/A")+1, ";prot=N/A");
+        else
+                os_snprintf(tempbuf, strlen(";prot=")+ strlen(phy_info.name)+1, ";prot=%s", phy_info.name);
+        strncat(pBuf, tempbuf, strlen(tempbuf));
+
+        if (wpa_supplicant_phy_rate_ioctl(skfd, wpa_s->ifname, &phy_info) != 0)
+                os_snprintf(tempbuf, strlen(";bw=N/A;")+1, ";bw=N/A;");
+        else {
+                if(phy_info.has_bitrate) {
+                        os_snprintf(tempbuf, strlen(";bw=00;")+1, ";bw=%s;",
+                                phy_info.bitrate.flags & 0x2 ? "40" : "20");
+                }
+        }
+        strncat(pBuf, tempbuf, strlen(tempbuf));
+
+        wpa_supplicant_phy_sock_deinit(skfd);
+
+        return 0;
+}
+
+#endif /* SAMSUNG_KPI */
+
diff -urN hostap_2_4.orig/wpa_supplicant/ctrl_iface.h hostap_2_4/wpa_supplicant/ctrl_iface.h
--- hostap_2_4.orig/wpa_supplicant/ctrl_iface.h	2015-09-24 15:25:20.349038329 +0800
+++ hostap_2_4/wpa_supplicant/ctrl_iface.h	2015-09-24 15:25:20.373038328 +0800
@@ -115,6 +115,10 @@
 
 void wpas_ctrl_radio_work_flush(struct wpa_supplicant *wpa_s);
 
+#ifdef CONFIG_WFD_TDLS
+int wifi_display_update_tdls_wfd_ie(struct wpa_supplicant *wpa_s, int action_code);
+#endif
+
 #else /* CONFIG_CTRL_IFACE */
 
 static inline struct ctrl_iface_priv *
@@ -156,4 +160,8 @@
 
 #endif /* CONFIG_CTRL_IFACE */
 
+#ifdef SAMSUNG_KPI
+int KPIGetStatus(struct wpa_supplicant *wpa_s, char *pBuf);
+#endif /* SAMSUNG_KPI */
+
 #endif /* CTRL_IFACE_H */
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/dbus_new.c hostap_2_4/wpa_supplicant/dbus/dbus_new.c
--- hostap_2_4.orig/wpa_supplicant/dbus/dbus_new.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/dbus_new.c	2015-09-24 15:25:20.373038328 +0800
@@ -218,6 +218,61 @@
 	dbus_message_unref(msg);
 }
 
+#ifdef TIZEN_P2P_LISTEN
+/**
+ * wpas_dbus_signal_stop_listen - send stop listen signal
+ * @wpa_s: %wpa_supplicant network interface data
+ * @success: indicates p2p listen needs to be stopped.
+ */
+void wpas_dbus_signal_stop_listen(struct wpa_supplicant *wpa_s, int scan_triggered)
+{
+        struct wpas_dbus_priv *iface;
+        DBusMessage *msg;
+        dbus_bool_t scan;
+
+        iface = wpa_s->global->dbus;
+
+        /* Do nothing if the control interface is not turned on */
+        if (iface == NULL)
+                return;
+
+        msg = dbus_message_new_signal(wpa_s->dbus_new_path,
+                                      WPAS_DBUS_NEW_IFACE_INTERFACE,
+                                      "StopListen");
+        if (msg == NULL)
+                return;
+
+        scan = scan_triggered ? TRUE : FALSE;
+        if (dbus_message_append_args(msg, DBUS_TYPE_BOOLEAN, &scan,
+                                     DBUS_TYPE_INVALID))
+                dbus_connection_send(iface->con, msg, NULL);
+        else
+                 wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
+        dbus_message_unref(msg);
+}
+
+/**
+ * wpas_dbus_signal_resume_listen - send resume listen signal
+ * @wpa_s: %wpa_supplicant network interface data
+ * @success: indicates p2p listen needs to be resumed.
+ */
+void wpas_dbus_signal_resume_listen(struct wpa_supplicant *wpa_s)
+{
+        struct wpas_dbus_priv *iface;
+        DBusMessage *msg;
+        iface = wpa_s->global->dbus;
+        /* Do nothing if the control interface is not turned on */
+        if (iface == NULL)
+                return;
+        msg = dbus_message_new_signal(wpa_s->dbus_new_path,
+                                      WPAS_DBUS_NEW_IFACE_INTERFACE,
+                                      "ResumeListen");
+        if (msg == NULL)
+                return;
+        dbus_connection_send(iface->con, msg, NULL);
+        dbus_message_unref(msg);
+}
+#endif /* TIZEN_P2P_LISTEN */
 
 /**
  * wpas_dbus_signal_bss - Send a BSS related event signal
@@ -559,6 +614,47 @@
 	dbus_message_unref(msg);
 }
 
+#ifdef TIZEN_WPS_PBC
+/**
+ * wpas_dbus_signal_wps_connected - Signals Connected WPS event
+ * @wpa_s: %wpa_supplicant network interface data
+ * @ssid: %Connected AP Name
+ *
+ * Sends WPSConnected dbus signal with name "success" and empty ssid as arguments
+ */
+void wpas_dbus_signal_wps_connected(struct wpa_supplicant *wpa_s, u8 *ssid)
+{
+
+        DBusMessage *msg;
+        DBusMessageIter iter, dict_iter;
+        struct wpas_dbus_priv *iface;
+        char *key = "success";
+
+        iface = wpa_s->global->dbus;
+
+        /* Do nothing if the control interface is not turned on */
+        if (iface == NULL)
+                return;
+
+        msg = dbus_message_new_signal(wpa_s->dbus_new_path,
+                                      WPAS_DBUS_NEW_IFACE_WPS, "WPSConnected");
+        if (msg == NULL)
+                return;
+
+	dbus_message_iter_init_append(msg, &iter);
+
+        if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &key) ||
+            !wpa_dbus_dict_open_write(&iter, &dict_iter) ||
+            !wpa_dbus_dict_append_byte_array(&dict_iter, "SSID", (const char *)ssid, strlen((const char*)ssid)) ||
+            !wpa_dbus_dict_close_write(&iter, &dict_iter))
+                wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
+        else
+                dbus_connection_send(iface->con, msg, NULL);
+
+        dbus_message_unref(msg);
+}
+#endif /* TIZEN_WPS_PBC */
+
 
 /**
  * wpas_dbus_signal_wps_event_fail - Signals Fail WPS event
@@ -574,7 +670,11 @@
 	DBusMessage *msg;
 	DBusMessageIter iter, dict_iter;
 	struct wpas_dbus_priv *iface;
+#ifdef TIZEN_WPS_PBC
+    char *key = "failed";
+#else
 	char *key = "fail";
+#endif /* TIZEN_WPS_PBC */
 
 	iface = wpa_s->global->dbus;
 
@@ -592,6 +692,10 @@
 	if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &key) ||
 	    !wpa_dbus_dict_open_write(&iter, &dict_iter) ||
 	    !wpa_dbus_dict_append_int32(&dict_iter, "msg", fail->msg) ||
+#ifdef TIZEN_WPS_PBC
+              !wpa_dbus_dict_append_int32(&dict_iter, "config_error", fail->config_error) ||
+              !wpa_dbus_dict_append_int32(&dict_iter, "error_indication", fail->error_indication) ||
+#endif /* TIZEN_WPS_PBC */
 	    !wpa_dbus_dict_close_write(&iter, &dict_iter))
 		wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
 	else
@@ -965,7 +1069,11 @@
 					      const u8 *dev_addr, int request,
 					      enum p2p_prov_disc_status status,
 					      u16 config_methods,
-					      unsigned int generated_pin)
+					      unsigned int generated_pin
+#ifdef TIZEN
+					    , char *params
+#endif
+)
 {
 	DBusMessage *msg;
 	DBusMessageIter iter;
@@ -1041,11 +1149,16 @@
 		error_ret = !dbus_message_iter_append_basic(&iter,
 						    DBUS_TYPE_INT32,
 						    &status);
-	else
+	else {
 		error_ret = (add_pin &&
 				 !dbus_message_iter_append_basic(&iter,
 							DBUS_TYPE_STRING,
 							&p_pin));
+                if(!dbus_message_iter_append_basic(&iter,
+                                                        DBUS_TYPE_STRING,
+                                                        &params))
+			error_ret = 1; 		
+	}
 
 error:
 	if (!error_ret)
@@ -1783,8 +1896,157 @@
 	dbus_message_unref(msg);
 }
 
+#ifdef TIZEN
+void wpas_dbus_signal_p2p_mcc_required(struct wpa_supplicant *wpa_s,
+                                  const u8 *p2p_dev_addr, 
+		                  int p2p_connect_freq, int go_neg_freq)
+{
+        DBusMessage *msg;
+        DBusMessageIter iter, dict_iter;
+	struct wpas_dbus_priv *iface;
+	char peer_obj_path[WPAS_DBUS_OBJECT_PATH_MAX], *path;
+
+	iface = wpa_s->global->dbus;
+	
+	/* Do nothing if the control interface is not turned on */                  
+	        if (iface == NULL)                                  
+	                return;
+	
+	if (wpa_s->p2p_mgmt)
+		wpa_s = wpa_s->parent;
+
+	/* Check if this is a known peer */ 
+	if (!p2p_peer_known(wpa_s->global->p2p, p2p_dev_addr))
+		return;
+
+
+	msg = dbus_message_new_signal(wpa_s->dbus_new_path,
+                                      WPAS_DBUS_NEW_IFACE_P2PDEVICE,
+                                      "MCCRequired");
+	if (msg == NULL)
+                return;
+
+	os_snprintf(peer_obj_path, WPAS_DBUS_OBJECT_PATH_MAX,
+		    "%s/" WPAS_DBUS_NEW_P2P_PEERS_PART "/"
+		    COMPACT_MACSTR, wpa_s->dbus_new_path, MAC2STR(p2p_dev_addr));
+
+	path = peer_obj_path;
+	
+	dbus_message_iter_init_append(msg, &iter);
+
+	if (!wpa_dbus_dict_open_write(&iter, &dict_iter) ||
+	    !wpa_dbus_dict_append_object_path(&dict_iter, "peer_object",
+	    				      path) ||
+	    !wpa_dbus_dict_append_uint16(&dict_iter, "p2p_connect_freq",
+	    				 p2p_connect_freq) ||
+	    !wpa_dbus_dict_append_uint16(&dict_iter, "go_neg_freq",
+	    				 go_neg_freq) ||
+	    !wpa_dbus_dict_close_write(&iter, &dict_iter))
+	    	wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
+	else
+		dbus_connection_send(iface->con, msg, NULL);
+	dbus_message_unref(msg);
+}
+
+
+void wpas_dbus_signal_p2p_connected_ip_address(struct wpa_supplicant *wpa_s,
+					       const char *ip_str)
+{
+        DBusMessage *msg;
+        DBusMessageIter iter;
+	struct wpas_dbus_priv *iface;
+
+	iface = wpa_s->global->dbus;
+	
+	/* Do nothing if the control interface is not turned on */                  
+        if (iface == NULL)                                  
+                return;
+	
+	if (wpa_s->p2p_mgmt)
+		wpa_s = wpa_s->parent;
+
+	msg = dbus_message_new_signal(wpa_s->dbus_new_path,
+                                      WPAS_DBUS_NEW_IFACE_P2PDEVICE,
+                                      "IPAddress");
+	if (msg == NULL)
+                return;
+
+	dbus_message_iter_init_append(msg, &iter);
+
+	if(!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &ip_str))
+		wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
+	else		
+		dbus_connection_send(iface->con, msg, NULL);
+	
+	dbus_message_unref(msg);
+}
+#endif /* TIZEN */
+
 #endif /* CONFIG_P2P */
 
+#ifdef CONFIG_WFD_TDLS
+void wpas_dbus_signal_tdls_peer(struct wpa_supplicant *wpa_s,
+                const char *peer, const char *wfdie, const char *sig_name)
+{
+        struct wpas_dbus_priv *iface;
+        DBusMessage *msg;
+        DBusMessageIter iter;
+
+        iface = wpa_s->global->dbus;
+
+        /* Do nothing if the control interface is not turned on */
+        if (iface == NULL)
+                return;
+
+        msg = dbus_message_new_signal(wpa_s->dbus_new_path,
+                                      WPAS_DBUS_NEW_IFACE_INTERFACE,
+                        sig_name);
+
+        if (msg == NULL)
+                return;
+
+        dbus_message_iter_init_append(msg, &iter);
+
+        if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &peer)
+                        || !dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &wfdie))
+                goto nomem;
+
+        dbus_connection_send(iface->con, msg, NULL);
+
+nomem:
+        dbus_message_unref(msg);
+}
+
+void wpas_dbus_signal_tdls_disconnected(struct wpa_supplicant *wpa_s,
+                                const char *peer)
+{
+        struct wpas_dbus_priv *iface;
+        DBusMessage *msg;
+        DBusMessageIter iter;
+
+        iface = wpa_s->global->dbus;
+
+        /* Do nothing if the control interface is not turned on */
+        if (iface == NULL)
+                return;
+
+        msg = dbus_message_new_signal(wpa_s->dbus_new_path,
+                                      WPAS_DBUS_NEW_IFACE_INTERFACE,
+                                      "TDLSDisconnected");
+        if (msg == NULL)
+                return;
+
+        dbus_message_iter_init_append(msg, &iter);
+
+        if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &peer))
+                goto nomem;
+
+        dbus_connection_send(iface->con, msg, NULL);
+
+nomem:
+        dbus_message_unref(msg);
+}
+#endif /* CONFIG_WFD_TDLS */
 
 /**
  * wpas_dbus_signal_prop_changed - Signals change of property
@@ -2558,6 +2820,14 @@
 		  END_ARGS
 	  }
 	},
+#ifdef TIZEN_WPS_PBC
+         { "Cancel", WPAS_DBUS_NEW_IFACE_WPS,
+           (WPADBusMethodHandler) &wpas_dbus_handler_wps_cancel,
+           {
+                   END_ARGS
+           }
+         },
+ #endif /* TIZEN_WPS_PBC */
 #endif /* CONFIG_WPS */
 #ifdef CONFIG_P2P
 	{ "Find", WPAS_DBUS_NEW_IFACE_P2PDEVICE,
@@ -2637,6 +2907,13 @@
 		  END_ARGS
 	  }
 	},
+        { "RemoveClient", WPAS_DBUS_NEW_IFACE_P2PDEVICE,
+          (WPADBusMethodHandler) wpas_dbus_handler_p2p_remove_client,
+          {
+                  { "args", "a{sv}", ARG_IN },
+                  END_ARGS
+          }
+        },
 	{ "Flush", WPAS_DBUS_NEW_IFACE_P2PDEVICE,
 	  (WPADBusMethodHandler) wpas_dbus_handler_p2p_flush,
 	  {
@@ -2794,6 +3071,29 @@
 	  }
 	},
 #endif /* CONFIG_TDLS */
+#ifdef CONFIG_WFD_TDLS
+        { "WFDSubelemSet", WPAS_DBUS_NEW_IFACE_INTERFACE,
+          (WPADBusMethodHandler) wpas_dbus_handler_wfd_subelem_set,
+          {
+                  { "value", "s", ARG_IN },
+                  END_ARGS
+          }
+        },
+        { "WFDTDLSModeSet", WPAS_DBUS_NEW_IFACE_INTERFACE,
+          (WPADBusMethodHandler) wpas_dbus_handler_wfd_TDLS_mode_set,
+          {
+                  { "mode", "i", ARG_IN },
+                  END_ARGS
+          }
+        },
+        { "WFDTDLSIeSet", WPAS_DBUS_NEW_IFACE_INTERFACE,
+          (WPADBusMethodHandler) wpas_dbus_handler_wfd_TDLS_ie_set,
+          {
+                  { "ie", "i", ARG_IN },
+                  END_ARGS
+          }
+        },
+#endif /* CONFIG_WFD_TDLS */
 	{ NULL, NULL, NULL, { END_ARGS } }
 };
 
@@ -3018,6 +3318,9 @@
 	  {
 		  { "peer_object", "o", ARG_OUT },
 		  { "pin", "s", ARG_OUT },
+#ifdef TIZEN
+		  { "params", "s", ARG_OUT },
+#endif
 		  END_ARGS
 	  }
 	},
@@ -3025,30 +3328,45 @@
 	  {
 		  { "peer_object", "o", ARG_OUT },
 		  { "pin", "s", ARG_OUT },
+#ifdef TIZEN
+		  { "params", "s", ARG_OUT },
+#endif
 		  END_ARGS
 	  }
 	},
 	{ "ProvisionDiscoveryRequestEnterPin", WPAS_DBUS_NEW_IFACE_P2PDEVICE,
 	  {
 		  { "peer_object", "o", ARG_OUT },
+#ifdef TIZEN
+		  { "params", "s", ARG_OUT },
+#endif
 		  END_ARGS
 	  }
 	},
 	{ "ProvisionDiscoveryResponseEnterPin", WPAS_DBUS_NEW_IFACE_P2PDEVICE,
 	  {
 		  { "peer_object", "o", ARG_OUT },
+#ifdef TIZEN
+		  { "params", "s", ARG_OUT },
+#endif
 		  END_ARGS
 	  }
 	},
 	{ "ProvisionDiscoveryPBCRequest", WPAS_DBUS_NEW_IFACE_P2PDEVICE,
 	  {
 		  { "peer_object", "o", ARG_OUT },
+#ifdef TIZEN
+		  { "params", "s", ARG_OUT },
+#endif
 		  END_ARGS
 	  }
 	},
 	{ "ProvisionDiscoveryPBCResponse", WPAS_DBUS_NEW_IFACE_P2PDEVICE,
 	  {
 		  { "peer_object", "o", ARG_OUT },
+#ifdef TIZEN
+		  { "params", "s", ARG_OUT },
+#endif
 		  END_ARGS
 	  }
 	},
@@ -3170,6 +3488,28 @@
 		  END_ARGS
 	  }
 	},
+#ifdef CONFIG_WFD_TDLS
+        { "TDLSPeerFound", WPAS_DBUS_NEW_IFACE_INTERFACE,
+          {
+                  { "peer", "s", ARG_OUT },
+                  { "wfdie", "s", ARG_OUT },
+                  END_ARGS
+          }
+        },
+        { "TDLSConnected", WPAS_DBUS_NEW_IFACE_INTERFACE,
+          {
+                  { "peer", "s", ARG_OUT },
+                  { "wfdie", "s", ARG_OUT },
+                  END_ARGS
+          }
+        },
+        { "TDLSDisconnected", WPAS_DBUS_NEW_IFACE_INTERFACE,
+          {
+                  { "peer", "s", ARG_OUT },
+                  END_ARGS
+          }
+        },
+#endif /* CONFIG_WFD_TDLS */
 	{ NULL, NULL, { END_ARGS } }
 };
 
@@ -3305,6 +3645,14 @@
 	  wpas_dbus_getter_p2p_peer_groups,
 	  NULL
 	},
+	{ "InterfaceAddress", WPAS_DBUS_NEW_IFACE_P2P_PEER, "ay",
+	  wpas_dbus_getter_p2p_peer_interface_address,
+          NULL 
+        },
+	{ "IntendedAddress", WPAS_DBUS_NEW_IFACE_P2P_PEER, "ay",
+	  wpas_dbus_getter_p2p_peer_intended_address,
+          NULL 
+        },
 	{ NULL, NULL, NULL, NULL, NULL }
 };
 
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/dbus_new.h hostap_2_4/wpa_supplicant/dbus/dbus_new.h
--- hostap_2_4.orig/wpa_supplicant/dbus/dbus_new.h	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/dbus_new.h	2015-09-24 15:25:20.373038328 +0800
@@ -152,6 +152,13 @@
 void wpas_dbus_signal_wps_event_fail(struct wpa_supplicant *wpa_s,
 				     struct wps_event_fail *fail);
 void wpas_dbus_signal_wps_event_success(struct wpa_supplicant *wpa_s);
+#ifdef TIZEN_P2P_LISTEN
+void wpas_dbus_signal_stop_listen(struct wpa_supplicant *wpa_s, int scan_triggered);
+void wpas_dbus_signal_resume_listen(struct wpa_supplicant *wpa_s);
+#endif /* TIZEN_P2P_LISTEN */
+#ifdef TIZEN_WPS_PBC
+ void wpas_dbus_signal_wps_connected(struct wpa_supplicant *wpa_s, u8 *ssid);
+#endif /* TIZEN_WPS_PBC */
 int wpas_dbus_register_network(struct wpa_supplicant *wpa_s,
 			       struct wpa_ssid *ssid);
 int wpas_dbus_unregister_network(struct wpa_supplicant *wpa_s, int nid);
@@ -182,7 +189,11 @@
 					      const u8 *dev_addr, int request,
 					      enum p2p_prov_disc_status status,
 					      u16 config_methods,
-					      unsigned int generated_pin);
+					      unsigned int generated_pin
+#ifdef TIZEN
+					    , char *params
+#endif
+		);
 void wpas_dbus_signal_p2p_go_neg_req(struct wpa_supplicant *wpa_s,
 				     const u8 *src, u16 dev_passwd_id);
 void wpas_dbus_signal_p2p_group_started(struct wpa_supplicant *wpa_s,
@@ -213,6 +224,13 @@
 				const u8 *member);
 void wpas_dbus_signal_p2p_wps_failed(struct wpa_supplicant *wpa_s,
 				     struct wps_event_fail *fail);
+#ifdef TIZEN
+void wpas_dbus_signal_p2p_mcc_required(struct wpa_supplicant *wpa_s, 
+				       const u8 *p2p_dev_addr, 
+				       int p2p_connect_freq, int go_neg_freq);
+void wpas_dbus_signal_p2p_connected_ip_address(struct wpa_supplicant *wpa_s,
+                                               const char *ip_str);
+#endif /* TIZEN */
 void wpas_dbus_signal_certification(struct wpa_supplicant *wpa_s,
 				    int depth, const char *subject,
 				    const char *altsubject[],
@@ -229,6 +247,14 @@
 void wpas_dbus_signal_sta_deauthorized(struct wpa_supplicant *wpa_s,
 				       const u8 *sta);
 
+#ifdef CONFIG_WFD_TDLS
+void wpas_dbus_signal_tdls_peer(struct wpa_supplicant *wpa_s,
+                                const char *peer, const char *wfdie,
+				                                const char *sig_name);
+void wpas_dbus_signal_tdls_disconnected(struct wpa_supplicant *wpa_s,
+                                const char *peer);
+#endif /* CONFIG_WFD_TDLS */
+
 #else /* CONFIG_CTRL_IFACE_DBUS_NEW */
 
 static inline int wpas_dbus_register_interface(struct wpa_supplicant *wpa_s)
@@ -373,7 +399,11 @@
 					 const u8 *dev_addr, int request,
 					 enum p2p_prov_disc_status status,
 					 u16 config_methods,
-					 unsigned int generated_pin)
+					 unsigned int generated_pin
+#ifdef TIZEN
+					    , char *params
+#endif
+		)
 {
 }
 
@@ -482,6 +512,20 @@
 				struct wps_event_fail *fail)
 {
 }
+#ifdef TIZEN
+static inline void 
+wpas_dbus_signal_p2p_mcc_required(struct wpa_supplicant *wpa_s,
+				       const u8 *p2p_dev_addr, 
+				       int p2p_connect_freq, int go_neg_freq)
+{
+}
+
+static inline void 
+wpas_dbus_signal_p2p_connected_ip_address(struct wpa_supplicant *wpa_s,
+                                               const char *ip_str)
+{
+}
+#endif /* TIZEN */
 
 static inline void wpas_dbus_signal_certification(struct wpa_supplicant *wpa_s,
 						  int depth,
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers.c hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers.c
--- hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers.c	2015-09-24 15:25:20.373038328 +0800
@@ -28,6 +28,7 @@
 #include "dbus_dict_helpers.h"
 #include "dbus_common_i.h"
 #include "drivers/driver.h"
+#include "../wifi_display.h"
 
 static const char * const debug_strings[] = {
 	"excessive", "msgdump", "debug", "info", "warning", "error", NULL
@@ -513,6 +514,14 @@
 	return TRUE;
 }
 
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+#include <sys/prctl.h>
+
+#ifndef PR_TASK_PERF_USER_TRACE
+#define PR_TASK_PERF_USER_TRACE 666
+#endif // PR_TASK_PERF_USER_TRACE
+
+#endif // TIZEN_BOOTING_PERFOMANCE_TEST
 
 /**
  * wpas_dbus_handler_create_interface - Request registration of a network iface
@@ -539,6 +548,18 @@
 
 	dbus_message_iter_init(message, &iter);
 
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+{
+	char buf[100];
+	snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+	strncat(buf, "dbus", strlen("dbus"));
+	strncat(buf, ": createinterface received", strlen(": createinterface received"));
+
+	prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
+
 	if (!wpa_dbus_dict_open_read(&iter, &iter_dict, NULL))
 		goto error;
 	while (wpa_dbus_dict_has_dict_entry(&iter_dict)) {
@@ -581,6 +602,14 @@
 	if (ifname == NULL)
 		goto error; /* Required Ifname argument missing */
 
+#ifdef TIZEN_CONF_FILE
+	if (confname == NULL)
+	{
+		confname = os_strdup("/etc/wpa_supplicant/wpa_supplicant.conf");
+		wpa_printf(MSG_DEBUG, "Read Conffile");
+	}
+#endif /* TIZEN_CONF_FILE */
+
 	/*
 	 * Try to get the wpa_supplicant record for this iface, return
 	 * an error if we already control it.
@@ -1268,6 +1297,19 @@
 
 	os_memset(&params, 0, sizeof(params));
 
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+{
+	char buf[100];
+	snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+	strncat(buf, "dbus", strlen("dbus"));
+	strncat(buf, ": scan received", strlen(": scan received"));
+
+	prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
+
+
 	dbus_message_iter_init(message, &iter);
 
 	dbus_message_iter_recurse(&iter, &dict_iter);
@@ -1487,6 +1529,10 @@
 			"wpa_supplicant could not add a network on this interface.");
 		goto err;
 	}
+#ifdef TIZEN_WPS_PBC
+         /* Clearing previously configured wps success message */
+         wpa_s->wps_success = 0;
+#endif /* TIZEN_WPS_PBC */
 	wpas_notify_network_added(wpa_s, ssid);
 	ssid->disabled = 1;
 	wpa_config_set_network_defaults(ssid);
@@ -2220,6 +2266,60 @@
 
 #endif /* CONFIG_TDLS */
 
+#ifdef CONFIG_WFD_TDLS
+#include "../ctrl_iface.h"
+DBusMessage * wpas_dbus_handler_wfd_subelem_set(DBusMessage *message,
+                                           struct wpa_supplicant *wpa_s)
+{
+        char *cmd;
+
+        if (!dbus_message_get_args(message, NULL,
+                                   DBUS_TYPE_STRING, &cmd,
+                                   DBUS_TYPE_INVALID))
+                return wpas_dbus_error_invalid_args(message, NULL);
+
+        if (wifi_display_subelem_set(wpa_s->global, cmd) < 0){
+                return wpas_dbus_error_invalid_args(
+                        message, "Invalid wfd_subelem_set format");
+        }
+
+        return NULL;
+}
+
+DBusMessage * wpas_dbus_handler_wfd_TDLS_mode_set(DBusMessage *message,
+                                           struct wpa_supplicant *wpa_s)
+{
+        int oper_mode;
+
+        if (!dbus_message_get_args(message, NULL,
+                                   DBUS_TYPE_INT32, &oper_mode,
+                                   DBUS_TYPE_INVALID))
+                return wpas_dbus_error_invalid_args(message, NULL);
+
+        wpa_drv_send_tdls_mgmt(wpa_s, broadcast_ether_addr, oper_mode,
+                        1, 0, 0, 0, NULL, 0);
+
+        return NULL;
+}
+
+DBusMessage * wpas_dbus_handler_wfd_TDLS_ie_set(DBusMessage *message,
+                                           struct wpa_supplicant *wpa_s)
+{
+        int action_code;
+
+        if (!dbus_message_get_args(message, NULL,
+                                   DBUS_TYPE_INT32, &action_code,
+                                   DBUS_TYPE_INVALID))
+                return wpas_dbus_error_invalid_args(message, NULL);
+
+        if (wifi_display_update_tdls_wfd_ie(wpa_s, action_code) < 0){
+                return wpas_dbus_error_invalid_args(
+                        message, "Invalid wpas_dbus_handler_wfd_TDLS_ie_set format");
+        }
+
+        return NULL;
+}
+#endif /* CONFIG_WFD_TDLS */
 
 /**
  * wpas_dbus_handler_set_pkcs11_engine_and_module_path - Set PKCS #11 engine and module path
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers.h hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers.h
--- hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers.h	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers.h	2015-09-24 15:25:20.373038328 +0800
@@ -291,6 +291,11 @@
 DBusMessage * wpas_dbus_handler_wps_start(DBusMessage *message,
 					  struct wpa_supplicant *wpa_s);
 
+#ifdef TIZEN_WPS_PBC
+DBusMessage * wpas_dbus_handler_wps_cancel(DBusMessage *message,
+                                           struct wpa_supplicant *wpa_s);
+#endif /* TIZEN_WPS_PBC */
+
 dbus_bool_t wpas_dbus_getter_process_credentials(DBusMessageIter *iter,
 	DBusError *error, void *user_data);
 
@@ -315,6 +320,15 @@
 DBusMessage * wpas_dbus_handler_tdls_teardown(DBusMessage *message,
 					      struct wpa_supplicant *wpa_s);
 
+#ifdef CONFIG_WFD_TDLS
+DBusMessage * wpas_dbus_handler_wfd_subelem_set(DBusMessage *message,
+                                           struct wpa_supplicant *wpa_s);
+DBusMessage * wpas_dbus_handler_wfd_TDLS_mode_set(DBusMessage *message,
+                                           struct wpa_supplicant *wpa_s);
+DBusMessage * wpas_dbus_handler_wfd_TDLS_ie_set(DBusMessage *message,
+                                           struct wpa_supplicant *wpa_s);
+#endif /* CONFIG_WFD_TDLS */
+
 DBusMessage * wpas_dbus_error_invalid_args(DBusMessage *message,
 					   const char *arg);
 DBusMessage * wpas_dbus_error_unknown_error(DBusMessage *message,
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers_p2p.c hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
--- hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers_p2p.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers_p2p.c	2015-09-24 15:25:20.373038328 +0800
@@ -27,6 +27,9 @@
 
 #include "../p2p_supplicant.h"
 #include "../wifi_display.h"
+#ifdef TIZEN
+#include "p2p/p2p_i.h"
+#endif
 
 /**
  * Parses out the mac address from the peer object path.
@@ -311,6 +314,10 @@
 	char *iface = NULL;
 	unsigned int group_id = 0;
 	struct wpa_ssid *ssid;
+#ifdef SAMSUNG_P2P_GROUP_ADD
+	char *ssid_str = NULL;
+	char *passphrase = NULL;
+#endif /* SAMSUNG_P2P_GROUP_ADD */	
 
 	dbus_message_iter_init(message, &iter);
 
@@ -329,6 +336,14 @@
 			freq = entry.int32_value;
 			if (freq <= 0)
 				goto inv_args_clear;
+#ifdef SAMSUNG_P2P_GROUP_ADD
+		} else if (os_strcmp(entry.key, "ssid") == 0 &&
+			   entry.type == DBUS_TYPE_STRING) {
+			ssid_str = os_strdup(entry.str_value);
+		} else if (os_strcmp(entry.key, "passphrase") == 0 &&
+			  entry.type == DBUS_TYPE_STRING) {
+			passphrase = os_strdup(entry.str_value);
+#endif /* SAMSUNG_P2P_GROUP_ADD */
 		} else if (os_strcmp(entry.key, "persistent_group_object") ==
 			   0 &&
 			   entry.type == DBUS_TYPE_OBJECT_PATH)
@@ -380,7 +395,11 @@
 				"Failed to reinvoke a persistent group");
 			goto out;
 		}
+#ifdef SAMSUNG_P2P_GROUP_ADD
+	} else if (wpas_p2p_group_add(wpa_s, persistent_group, freq, 0, 0, ssid_str, passphrase))
+#else
 	} else if (wpas_p2p_group_add(wpa_s, persistent_group, freq, 0, 0))
+#endif /* SAMSUNG_P2P_GROUP_ADD */	
 		goto inv_args;
 
 out:
@@ -425,6 +444,63 @@
 	return TRUE;
 }
 
+DBusMessage * wpas_dbus_handler_p2p_remove_client(DBusMessage *message,
+                                                  struct wpa_supplicant *wpa_s)
+{
+        DBusMessageIter iter_dict;
+        DBusMessage *reply = NULL;
+        DBusMessageIter iter;
+        struct wpa_dbus_dict_entry entry;
+        char *peer_object_path = NULL;
+        char *interface_addr = NULL;
+        u8 peer_addr[ETH_ALEN];
+
+        if (!wpa_dbus_p2p_check_enabled(wpa_s, message, &reply, NULL))
+                return reply;
+
+        dbus_message_iter_init(message, &iter);
+
+        if (!wpa_dbus_dict_open_read(&iter, &iter_dict, NULL))
+                goto err;
+
+        while (wpa_dbus_dict_has_dict_entry(&iter_dict)) {
+                if (!wpa_dbus_dict_get_entry(&iter_dict, &entry))
+                        goto err;
+
+                if (os_strcmp(entry.key, "peer") == 0 &&
+                    entry.type == DBUS_TYPE_OBJECT_PATH) {
+                        os_free(peer_object_path);
+                        peer_object_path = os_strdup(entry.str_value);
+                        wpa_dbus_dict_entry_clear(&entry);
+                } else if (os_strcmp(entry.key, "iface") == 0 &&
+                           entry.type == DBUS_TYPE_STRING) {
+                        os_free(interface_addr);
+                        interface_addr = os_strdup(entry.str_value);
+                        wpa_dbus_dict_entry_clear(&entry);
+                } else {
+                        wpa_dbus_dict_entry_clear(&entry);
+                        goto err;
+                }
+        }
+
+        if ((!peer_object_path && !interface_addr) ||
+            (peer_object_path &&
+             (parse_peer_object_path(peer_object_path, peer_addr) < 0 ||
+              !p2p_peer_known(wpa_s->global->p2p, peer_addr))) ||
+            (interface_addr && hwaddr_aton(interface_addr, peer_addr) < 0))
+                goto err;
+
+        wpas_p2p_remove_client(wpa_s, peer_addr, interface_addr != NULL);
+        reply = NULL;
+out:
+        os_free(peer_object_path);
+        os_free(interface_addr);
+        return reply;
+err:
+        reply = wpas_dbus_error_invalid_args(message, "Invalid address format");
+        goto out;
+}
+
 
 DBusMessage * wpas_dbus_handler_p2p_flush(DBusMessage *message,
 					  struct wpa_supplicant *wpa_s)
@@ -998,6 +1074,54 @@
 		else if (os_strcmp(entry.key, "p2p_search_delay") == 0 &&
 			 entry.type == DBUS_TYPE_UINT32)
 			wpa_s->conf->p2p_search_delay = entry.uint32_value;
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+		else if (os_strcmp(entry.key, "static_ip") == 0 && 
+				entry.type == DBUS_TYPE_STRING)
+			p2p_set_static_ip(wpa_s->global->p2p, inet_addr(entry.str_value));
+#endif
+
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+		else if (os_strcmp(entry.key, "RGI_value") == 0 && 
+				entry.type == DBUS_TYPE_UINT32)
+		{
+			int go_intent = entry.uint32_value;
+			if(go_intent < -1 || go_intent > 15)
+			{    
+				wpa_printf(MSG_DEBUG, "Invalid Requested GO Intent: "
+						"%d", go_intent);
+				goto error;
+			}     
+			else if(go_intent == -1){ 
+				if(wpa_s->global->p2p->cfg->ON_req_go_intent == 0){
+					wpa_printf(MSG_DEBUG, "Invalid Request, RGI is disable");
+					goto error;
+				}     
+				else 
+					wpa_s->global->p2p->cfg->enable_req_go_intent = 0; 
+			}    
+			else {
+				wpa_s->global->p2p->cfg->enable_req_go_intent = 1;     
+				p2p_set_req_go_intent(wpa_s->global->p2p, go_intent);
+			}
+
+		}
+		else if (os_strcmp(entry.key, "RGI_enable") == 0 && 
+				entry.type == DBUS_TYPE_UINT32)
+		{
+			int enable = entry.uint32_value;
+			if(enable == 1)
+				wpa_s->global->p2p->cfg->ON_req_go_intent = 1;   
+			else if(enable == 0){
+				//                      wpa_s->global->p2p->cfg->enable_req_go_intent = 0;              
+				wpa_s->global->p2p->cfg->ON_req_go_intent = 0; 
+			}     
+			else {
+				wpa_printf(MSG_DEBUG, "Invalid RGI enable value: "
+						"%d", enable);
+				goto error;     
+			}
+		}
+#endif
 		else
 			goto error;
 
@@ -1513,6 +1637,56 @@
 }
 
 
+dbus_bool_t wpas_dbus_getter_p2p_peer_interface_address(DBusMessageIter *iter,
+                                                     DBusError *error,
+                                                     void *user_data)
+{       
+        struct peer_handler_args *peer_args = user_data;
+        const struct p2p_peer_info *info;
+	u8 interface_address[ETH_ALEN];
+        
+        info = p2p_get_peer_found(peer_args->wpa_s->global->p2p,
+                                  peer_args->p2p_device_addr, 0);
+        if (info == NULL) {
+                dbus_set_error(error, DBUS_ERROR_FAILED,
+                               "failed to find peer");
+                return FALSE;
+        }
+        if (p2p_get_interface_addr(peer_args->wpa_s->global->p2p,
+                                  peer_args->p2p_device_addr, interface_address) < 0) {
+                os_memset(interface_address, 0, ETH_ALEN);
+        }
+
+        return wpas_dbus_simple_array_property_getter(
+                iter, DBUS_TYPE_BYTE, (char *) interface_address,
+                ETH_ALEN, error);
+}
+
+dbus_bool_t wpas_dbus_getter_p2p_peer_intended_address(DBusMessageIter *iter,
+                                                     DBusError *error,
+                                                     void *user_data)
+{       
+        struct peer_handler_args *peer_args = user_data;
+        const struct p2p_peer_info *info;
+	u8 intended_address[ETH_ALEN];
+        
+        info = p2p_get_peer_found(peer_args->wpa_s->global->p2p,
+                                  peer_args->p2p_device_addr, 0);
+        if (info == NULL) {
+                dbus_set_error(error, DBUS_ERROR_FAILED,
+                               "failed to find peer");
+                return FALSE;
+        }
+        if (p2p_get_intended_addr(peer_args->wpa_s->global->p2p,
+                                  peer_args->p2p_device_addr, intended_address) < 0) {
+                os_memset(intended_address, 0, ETH_ALEN);
+        }
+
+        return wpas_dbus_simple_array_property_getter(
+                iter, DBUS_TYPE_BYTE, (char *) intended_address,
+                ETH_ALEN, error);
+}
+
 struct peer_group_data {
 	struct wpa_supplicant *wpa_s;
 	const struct p2p_peer_info *info;
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers_p2p.h hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers_p2p.h
--- hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers_p2p.h	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers_p2p.h	2015-09-24 15:25:20.373038328 +0800
@@ -53,6 +53,9 @@
 DBusMessage *wpas_dbus_handler_p2p_disconnect(
 	DBusMessage *message, struct wpa_supplicant *wpa_s);
 
+DBusMessage * wpas_dbus_handler_p2p_remove_client(
+        DBusMessage *message, struct wpa_supplicant *wpa_s);
+
 DBusMessage *wpas_dbus_handler_p2p_flush(
 	DBusMessage *message, struct wpa_supplicant *wpa_s);
 
@@ -150,6 +153,13 @@
 					     DBusError *error,
 					     void *user_data);
 
+dbus_bool_t wpas_dbus_getter_p2p_peer_interface_address(DBusMessageIter *iter,
+						     DBusError *error,
+						     void *user_data);
+
+dbus_bool_t wpas_dbus_getter_p2p_peer_intended_address(DBusMessageIter *iter,
+						     DBusError *error,
+						     void *user_data);
 /*
  * P2P Group properties
  */
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers_wps.c hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers_wps.c
--- hostap_2_4.orig/wpa_supplicant/dbus/dbus_new_handlers_wps.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/dbus_new_handlers_wps.c	2015-09-24 15:25:20.373038328 +0800
@@ -24,6 +24,9 @@
 struct wps_start_params {
 	int role; /* 0 - not set, 1 - enrollee, 2 - registrar */
 	int type; /* 0 - not set, 1 - pin,      2 - pbc       */
+#ifdef SAMSUNG_SRID	
+	int get;  /* 0 - not set, 1 - pin  */
+#endif /* SAMSUNG_SRID */	
 	u8 *bssid;
 	char *pin;
 	u8 *p2p_dev_addr;
@@ -53,7 +56,7 @@
 	else if (os_strcmp(val, "registrar") == 0)
 		params->role = 2;
 	else {
-		wpa_printf(MSG_DEBUG, "dbus: WPS.Start - Uknown role %s", val);
+		wpa_printf(MSG_DEBUG, "dbus: WPS.Start - Unknown role %s", val);
 		*reply = wpas_dbus_error_invalid_args(message, val);
 		return -1;
 	}
@@ -91,6 +94,35 @@
 	return 0;
 }
 
+#ifdef SAMSUNG_SRID
+static int wpas_dbus_handler_wps_get(DBusMessage *message,
+				      DBusMessageIter *entry_iter,
+				      struct wps_start_params *params,
+				      DBusMessage **reply)
+{
+	DBusMessageIter variant_iter;
+	char *val;
+
+	dbus_message_iter_recurse(entry_iter, &variant_iter);
+	if (dbus_message_iter_get_arg_type(&variant_iter) !=
+	    DBUS_TYPE_STRING) {
+		wpa_printf(MSG_DEBUG,
+			   "dbus: WPS.Start - Wrong Get type, string required");
+		*reply = wpas_dbus_error_invalid_args(message,
+						      "Get must be a string");
+		return -1;
+	}
+	dbus_message_iter_get_basic(&variant_iter, &val);
+	if (os_strcmp(val, "pin") == 0)
+		params->get = 1;
+	else {
+		wpa_printf(MSG_DEBUG, "dbus: WPS.Start - Uknown Get %s", val);
+		*reply = wpas_dbus_error_invalid_args(message, val);
+		return -1;
+	}
+	return 0;
+}
+#endif /* SAMSUNG_SRID */
 
 static int wpas_dbus_handler_wps_bssid(DBusMessage *message,
 				       DBusMessageIter *entry_iter,
@@ -113,7 +145,7 @@
 	dbus_message_iter_recurse(&variant_iter, &array_iter);
 	dbus_message_iter_get_fixed_array(&array_iter, &params->bssid, &len);
 	if (len != ETH_ALEN) {
-		wpa_printf(MSG_DEBUG, "dbus: WPS.Stsrt - Wrong Bssid length %d",
+		wpa_printf(MSG_DEBUG, "dbus: WPS.Start - Wrong Bssid length %d",
 			   len);
 		*reply = wpas_dbus_error_invalid_args(message,
 						      "Bssid is wrong length");
@@ -189,6 +221,11 @@
 	else if (os_strcmp(key, "Type") == 0)
 		return wpas_dbus_handler_wps_type(message, entry_iter,
 						  params, reply);
+#ifdef SAMSUNG_SRID
+	else if (os_strcmp(key, "Get") == 0)
+		return wpas_dbus_handler_wps_get(message, entry_iter,
+						  params, reply);
+#endif /* SAMSUNG_SRID */		
 	else if (os_strcmp(key, "Bssid") == 0)
 		return wpas_dbus_handler_wps_bssid(message, entry_iter,
 						   params, reply);
@@ -247,6 +284,14 @@
 		dbus_message_iter_next(&dict_iter);
 	}
 
+#ifdef SAMSUNG_SRID	
+	/* allow 'get' params similar to ctrl_interface */
+	if(params.get == 1) {
+		os_snprintf(npin, sizeof(npin), "%08d", wps_generate_pin());
+		goto done;
+	}
+#endif /* SAMSUNG_SRID */
+
 #ifdef CONFIG_AP
 	if (wpa_s->ap_iface && params.type == 1) {
 		if (params.pin == NULL) {
@@ -302,6 +347,9 @@
 						     "WPS start failed");
 	}
 
+#ifdef SAMSUNG_SRID
+done:
+#endif /* SAMSUNG_SRID */
 	reply = dbus_message_new_method_return(message);
 	if (!reply)
 		return wpas_dbus_error_no_memory(message);
@@ -318,6 +366,16 @@
 	return reply;
 }
 
+//Tizen: cancel WPS
+#ifdef TIZEN_WPS_PBC 
+DBusMessage * wpas_dbus_handler_wps_cancel(DBusMessage *message,
+                                          struct wpa_supplicant *wpa_s)
+{
+        wpas_wps_cancel(wpa_s);
+        return NULL;
+}
+#endif /* TIZEN_WPS_PBC */
+
 
 /**
  * wpas_dbus_getter_process_credentials - Check if credentials are processed
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/dbus-wpa_supplicant.conf hostap_2_4/wpa_supplicant/dbus/dbus-wpa_supplicant.conf
--- hostap_2_4.orig/wpa_supplicant/dbus/dbus-wpa_supplicant.conf	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/dbus-wpa_supplicant.conf	2015-09-24 15:25:20.373038328 +0800
@@ -14,6 +14,9 @@
                 <allow send_interface="fi.w1.wpa_supplicant1"/>
                 <allow receive_sender="fi.w1.wpa_supplicant1" receive_type="signal"/>
         </policy>
+        <policy user="app">
+                <allow receive_sender="fi.w1.wpa_supplicant1" receive_type="signal"/>
+        </policy>
         <policy context="default">
                 <deny own="fi.epitest.hostap.WPASupplicant"/>
                 <deny send_destination="fi.epitest.hostap.WPASupplicant"/>
diff -urN hostap_2_4.orig/wpa_supplicant/dbus/.gitignore hostap_2_4/wpa_supplicant/dbus/.gitignore
--- hostap_2_4.orig/wpa_supplicant/dbus/.gitignore	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/dbus/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-libwpadbus.a
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/eapol_test.8 hostap_2_4/wpa_supplicant/doc/docbook/eapol_test.8
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/eapol_test.8	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/eapol_test.8	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,124 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "EAPOL_TEST" "8" "15 March 2015" "" ""
+
+.SH NAME
+eapol_test \- EAP peer and RADIUS client testing
+.SH SYNOPSIS
+
+\fBeapol_test\fR [ \fB-nWS\fR ] [ \fB-c\fIconfig file\fB\fR ] [ \fB-a\fIserver IP address\fB\fR ] [ \fB-A\fIclient IP address\fB\fR ] [ \fB-p\fIUDP port\fB\fR ] [ \fB-s\fIshared secret\fB\fR ] [ \fB-r\fIre-authentications\fB\fR ] [ \fB-t\fItimeout\fB\fR ] [ \fB-C\fIConnect-Info\fB\fR ] [ \fB-M\fIMAC address\fB\fR ] [ \fB-o\fIfile\fB\fR ] [ \fB-N\fIattr spec\fB\fR ]
+
+
+\fBeapol_test scard\fR
+
+
+\fBeapol_test sim\fR [ \fBPIN\fR ] [ \fBnum triplets\fR ]
+
+.SH "OVERVIEW"
+.PP
+eapol_test is a program that links together the same EAP
+peer implementation that wpa_supplicant is using and the RADIUS
+authentication client code from hostapd. In addition, it has
+minimal glue code to combine these two components in similar
+ways to IEEE 802.1X/EAPOL Authenticator state machines. In other
+words, it integrates IEEE 802.1X Authenticator (normally, an
+access point) and IEEE 802.1X Supplicant (normally, a wireless
+client) together to generate a single program that can be used to
+test EAP methods without having to setup an access point and a
+wireless client.
+.PP
+The main uses for eapol_test are in interoperability testing
+of EAP methods against RADIUS servers and in development testing
+for new EAP methods. It can be easily used to automate EAP testing
+for interoperability and regression since the program can be run
+from shell scripts without require additional test components apart
+from a RADIUS server. For example, the automated EAP tests described
+in eap_testing.txt are implemented with eapol_test. Similarly,
+eapol_test could be used to implement an automated regression
+test suite for a RADIUS authentication server.
+.PP
+As an example:
+.sp
+.RS
+
+.nf
+eapol_test -ctest.conf -a127.0.0.1 -p1812 -ssecret -r1
+.fi
+.RE
+.PP
+tries to complete EAP authentication based on the network
+configuration from test.conf against the RADIUS server running
+on the local host. A re-authentication is triggered to test fast
+re-authentication. The configuration file uses the same format for
+network blocks as wpa_supplicant.
+.SH "COMMAND ARGUMENTS"
+.TP
+\fB-c configuration file path\fR
+A configuration to use.  The configuration should
+use the same format for network blocks as wpa_supplicant.
+.TP
+\fB-a AS address\fR
+IP address of the authentication server.  The
+default is '127.0.0.1'.
+.TP
+\fB-A client address\fR
+IP address of the client.  The default is to
+select an address automatically.
+.TP
+\fB-p AS port\fR
+UDP port of the authentication server. The
+default is '1812'.
+.TP
+\fB-s AS secret\fR
+Shared secret with the authentication server.
+The default is 'radius'.
+.TP
+\fB-r count\fR
+Number of reauthentications.
+.TP
+\fB-t timeout\fR
+Timeout in seconds. The default is 30.
+.TP
+\fB-C info\fR
+RADIUS Connect-Info.  The default is
+\&'CONNECT 11Mbps 802.11b'.
+.TP
+\fB-M mac address\fR
+Client MAC address (Calling-Station-Id).  The
+default is '02:00:00:00:00:01'.
+.TP
+\fB-o file\fR
+Location to write out server certificate.
+.TP
+\fB-N attr spec\fR
+Send arbitrary attribute specific by
+attr_id:syntax:value, or attr_id alone.  attr_id should be the numeric
+ID of the attribute, and syntax should be one of 's' (string),
+\&'d' (integer), or 'x' (octet string). The value is the attribute value
+to send.  When attr_id is given alone, NULL is used as the attribute
+value.  Multiple attributes can be specified by using the option
+several times.
+.TP
+\fB-n\fR
+Indicates that no MPPE keys are expected.
+.TP
+\fB-W\fR
+Wait for a control interface monitor before starting.
+.TP
+\fB-S\fR
+Save configuration after authentication.
+.SH "SEE ALSO"
+.PP
+\fBwpa_supplicant\fR(8)
+.SH "LEGAL"
+.PP
+wpa_supplicant is copyright (c) 2003-2015,
+Jouni Malinen <j@w1.fi> and
+contributors.
+All Rights Reserved.
+.PP
+This program is licensed under the BSD license (the one with
+advertisement clause removed).
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/.gitignore hostap_2_4/wpa_supplicant/doc/docbook/.gitignore
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/.gitignore	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1,6 +0,0 @@
-manpage.links
-manpage.refs
-*.8
-*.5
-*.html
-*.pdf
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/manpage.refs hostap_2_4/wpa_supplicant/doc/docbook/manpage.refs
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/manpage.refs	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/manpage.refs	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,4 @@
+{
+  '' => '',
+  '' => ''
+}
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_background.8 hostap_2_4/wpa_supplicant/doc/docbook/wpa_background.8
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_background.8	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/wpa_background.8	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,84 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "WPA_BACKGROUND" "8" "15 March 2015" "" ""
+
+.SH NAME
+wpa_background \- Background information on Wi-Fi Protected Access and IEEE 802.11i
+.SH "WPA"
+.PP
+The original security mechanism of IEEE 802.11 standard was
+not designed to be strong and has proven to be insufficient for
+most networks that require some kind of security. Task group I
+(Security) of IEEE 802.11 working group
+(http://www.ieee802.org/11/) has worked to address the flaws of
+the base standard and has in practice completed its work in May
+2004. The IEEE 802.11i amendment to the IEEE 802.11 standard was
+approved in June 2004 and published in July 2004.
+.PP
+Wi-Fi Alliance (http://www.wi-fi.org/) used a draft version
+of the IEEE 802.11i work (draft 3.0) to define a subset of the
+security enhancements that can be implemented with existing wlan
+hardware. This is called Wi-Fi Protected Access<TM> (WPA). This
+has now become a mandatory component of interoperability testing
+and certification done by Wi-Fi Alliance. Wi-Fi provides
+information about WPA at its web site
+(http://www.wi-fi.org/OpenSection/protected_access.asp).
+.PP
+IEEE 802.11 standard defined wired equivalent privacy (WEP)
+algorithm for protecting wireless networks. WEP uses RC4 with
+40-bit keys, 24-bit initialization vector (IV), and CRC32 to
+protect against packet forgery. All these choices have proven to
+be insufficient: key space is too small against current attacks,
+RC4 key scheduling is insufficient (beginning of the pseudorandom
+stream should be skipped), IV space is too small and IV reuse
+makes attacks easier, there is no replay protection, and non-keyed
+authentication does not protect against bit flipping packet
+data.
+.PP
+WPA is an intermediate solution for the security issues. It
+uses Temporal Key Integrity Protocol (TKIP) to replace WEP. TKIP
+is a compromise on strong security and possibility to use existing
+hardware. It still uses RC4 for the encryption like WEP, but with
+per-packet RC4 keys. In addition, it implements replay protection,
+keyed packet authentication mechanism (Michael MIC).
+.PP
+Keys can be managed using two different mechanisms. WPA can
+either use an external authentication server (e.g., RADIUS) and
+EAP just like IEEE 802.1X is using or pre-shared keys without need
+for additional servers. Wi-Fi calls these "WPA-Enterprise" and
+"WPA-Personal", respectively. Both mechanisms will generate a
+master session key for the Authenticator (AP) and Supplicant
+(client station).
+.PP
+WPA implements a new key handshake (4-Way Handshake and
+Group Key Handshake) for generating and exchanging data encryption
+keys between the Authenticator and Supplicant. This handshake is
+also used to verify that both Authenticator and Supplicant know
+the master session key. These handshakes are identical regardless
+of the selected key management mechanism (only the method for
+generating master session key changes).
+.SH "IEEE 802.11I / WPA2"
+.PP
+The design for parts of IEEE 802.11i that were not included
+in WPA has finished (May 2004) and this amendment to IEEE 802.11
+was approved in June 2004. Wi-Fi Alliance is using the final IEEE
+802.11i as a new version of WPA called WPA2. This includes, e.g.,
+support for more robust encryption algorithm (CCMP: AES in Counter
+mode with CBC-MAC) to replace TKIP and optimizations for handoff
+(reduced number of messages in initial key handshake,
+pre-authentication, and PMKSA caching).
+.SH "SEE ALSO"
+.PP
+\fBwpa_supplicant\fR(8)
+.SH "LEGAL"
+.PP
+wpa_supplicant is copyright (c) 2003-2015,
+Jouni Malinen <j@w1.fi> and
+contributors.
+All Rights Reserved.
+.PP
+This program is licensed under the BSD license (the one with
+advertisement clause removed).
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_cli.8 hostap_2_4/wpa_supplicant/doc/docbook/wpa_cli.8
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_cli.8	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/wpa_cli.8	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,219 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "WPA_CLI" "8" "15 March 2015" "" ""
+
+.SH NAME
+wpa_cli \- WPA command line client
+.SH SYNOPSIS
+
+\fBwpa_cli\fR [ \fB-p \fIpath to ctrl sockets\fB\fR ] [ \fB-g \fIpath to global ctrl_interface socket\fB\fR ] [ \fB-i \fIifname\fB\fR ] [ \fB-hvB\fR ] [ \fB-a \fIaction file\fB\fR ] [ \fB-P \fIpid file\fB\fR ] [ \fB-G \fIping interval\fB\fR ] [ \fB\fIcommand ...\fB\fR ]
+
+.SH "OVERVIEW"
+.PP
+wpa_cli is a text-based frontend program for interacting
+with wpa_supplicant. It is used to query current status, change
+configuration, trigger events, and request interactive user
+input.
+.PP
+wpa_cli can show the current authentication status, selected
+security mode, dot11 and dot1x MIBs, etc. In addition, it can
+configure some variables like EAPOL state machine parameters and
+trigger events like reassociation and IEEE 802.1X
+logoff/logon. wpa_cli provides a user interface to request
+authentication information, like username and password, if these
+are not included in the configuration. This can be used to
+implement, e.g., one-time-passwords or generic token card
+authentication where the authentication is based on a
+challenge-response that uses an external device for generating the
+response.
+.PP
+The control interface of wpa_supplicant can be configured to
+allow non-root user access (ctrl_interface GROUP= parameter in the
+configuration file). This makes it possible to run wpa_cli with a
+normal user account.
+.PP
+wpa_cli supports two modes: interactive and command
+line. Both modes share the same command set and the main
+difference is in interactive mode providing access to unsolicited
+messages (event messages, username/password requests).
+.PP
+Interactive mode is started when wpa_cli is executed without
+including the command as a command line parameter. Commands are
+then entered on the wpa_cli prompt. In command line mode, the same
+commands are entered as command line arguments for wpa_cli.
+.SH "INTERACTIVE AUTHENTICATION PARAMETERS REQUEST"
+.PP
+When wpa_supplicant need authentication parameters, like
+username and password, which are not present in the configuration
+file, it sends a request message to all attached frontend programs,
+e.g., wpa_cli in interactive mode. wpa_cli shows these requests
+with "CTRL-REQ-<type>-<id>:<text>"
+prefix. <type> is IDENTITY, PASSWORD, or OTP
+(one-time-password). <id> is a unique identifier for the
+current network. <text> is description of the request. In
+case of OTP request, it includes the challenge from the
+authentication server.
+.PP
+The reply to these requests can be given with
+\fBidentity\fR, \fBpassword\fR, and
+\fBotp\fR commands. <id> needs to be copied from
+the matching request. \fBpassword\fR and
+\fBotp\fR commands can be used regardless of whether
+the request was for PASSWORD or OTP. The main difference between these
+two commands is that values given with \fBpassword\fR are
+remembered as long as wpa_supplicant is running whereas values given
+with \fBotp\fR are used only once and then forgotten,
+i.e., wpa_supplicant will ask frontend for a new value for every use.
+This can be used to implement one-time-password lists and generic token
+card -based authentication.
+.PP
+Example request for password and a matching reply:
+.sp
+.RS
+
+.nf
+CTRL-REQ-PASSWORD-1:Password needed for SSID foobar
+> password 1 mysecretpassword
+.fi
+.RE
+.PP
+Example request for generic token card challenge-response:
+.sp
+.RS
+
+.nf
+CTRL-REQ-OTP-2:Challenge 1235663 needed for SSID foobar
+> otp 2 9876
+.fi
+.RE
+.SH "COMMAND ARGUMENTS"
+.TP
+\fB-p path\fR
+Change the path where control sockets should
+be found.
+.TP
+\fB-g control socket path\fR
+Connect to the global control socket at the
+indicated path rather than an interface-specific control
+socket.
+.TP
+\fB-i ifname\fR
+Specify the interface that is being
+configured.  By default, choose the first interface found with
+a control socket in the socket path.
+.TP
+\fB-h\fR
+Help.  Show a usage message.
+.TP
+\fB-v\fR
+Show version information.
+.TP
+\fB-B\fR
+Run as a daemon in the background.
+.TP
+\fB-a file\fR
+Run in daemon mode executing the action file
+based on events from wpa_supplicant.  The specified file will
+be executed with the first argument set to interface name and
+second to "CONNECTED" or "DISCONNECTED" depending on the event.
+This can be used to execute networking tools required to configure
+the interface.
+
+Additionally, three environmental variables are available to
+the file: WPA_CTRL_DIR, WPA_ID, and WPA_ID_STR. WPA_CTRL_DIR
+contains the absolute path to the ctrl_interface socket. WPA_ID
+contains the unique network_id identifier assigned to the active
+network, and WPA_ID_STR contains the content of the id_str option.
+.TP
+\fB-P file\fR
+Set the location of the PID
+file.
+.TP
+\fB-G ping interval\fR
+Set the interval (in seconds) at which
+wpa_cli pings the supplicant.
+.TP
+\fBcommand\fR
+Run a command.  The available commands are
+listed in the next section.
+.SH "COMMANDS"
+.PP
+The following commands are available:
+.TP
+\fBstatus\fR
+get current WPA/EAPOL/EAP status
+.TP
+\fBmib\fR
+get MIB variables (dot1x, dot11)
+.TP
+\fBhelp\fR
+show this usage help
+.TP
+\fBinterface [ifname]\fR
+show interfaces/select interface
+.TP
+\fBlevel <debug level>\fR
+change debug level
+.TP
+\fBlicense\fR
+show full wpa_cli license
+.TP
+\fBlogoff\fR
+IEEE 802.1X EAPOL state machine logoff
+.TP
+\fBlogon\fR
+IEEE 802.1X EAPOL state machine logon
+.TP
+\fBset\fR
+set variables (shows list of variables when run without arguments)
+.TP
+\fBpmksa\fR
+show PMKSA cache
+.TP
+\fBreassociate\fR
+force reassociation
+.TP
+\fBreconfigure\fR
+force wpa_supplicant to re-read its configuration file
+.TP
+\fBpreauthenticate <BSSID>\fR
+force preauthentication
+.TP
+\fBidentity <network id> <identity>\fR
+configure identity for an SSID
+.TP
+\fBpassword <network id> <password>\fR
+configure password for an SSID
+.TP
+\fBpin <network id> <pin>\fR
+configure pin for an SSID
+.TP
+\fBotp <network id> <password>\fR
+configure one-time-password for an SSID
+.TP
+\fBbssid <network id> <BSSID>\fR
+set preferred BSSID for an SSID
+.TP
+\fBlist_networks\fR
+list configured networks
+.TP
+\fBterminate\fR
+terminate \fBwpa_supplicant\fR
+.TP
+\fBquit\fR
+exit wpa_cli
+.SH "SEE ALSO"
+.PP
+\fBwpa_supplicant\fR(8)
+.SH "LEGAL"
+.PP
+wpa_supplicant is copyright (c) 2003-2015,
+Jouni Malinen <j@w1.fi> and
+contributors.
+All Rights Reserved.
+.PP
+This program is licensed under the BSD license (the one with
+advertisement clause removed).
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_gui.8 hostap_2_4/wpa_supplicant/doc/docbook/wpa_gui.8
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_gui.8	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/wpa_gui.8	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,51 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "WPA_GUI" "8" "15 March 2015" "" ""
+
+.SH NAME
+wpa_gui \- WPA Graphical User Interface
+.SH SYNOPSIS
+
+\fBwpa_gui\fR [ \fB-p \fIpath to ctrl sockets\fB\fR ] [ \fB-i \fIifname\fB\fR ] [ \fB-t\fR ]
+
+.SH "OVERVIEW"
+.PP
+wpa_gui is a QT graphical frontend program for interacting
+with wpa_supplicant. It is used to query current status, change
+configuration and request interactive user input.
+.PP
+wpa_gui supports (almost) all of the interactive status and
+configuration features of the command line client, wpa_cli. Refer
+to the wpa_cli manpage for a comprehensive list of the
+interactive mode features.
+.SH "COMMAND ARGUMENTS"
+.TP
+\fB-p path\fR
+Change the path where control sockets should
+be found.
+.TP
+\fB-i ifname\fR
+Specify the interface that is being
+configured. By default, choose the first interface found with
+a control socket in the socket path.
+.TP
+\fB-t\fR
+Start program in the system tray only (if the window
+manager supports it). By default the main status window is
+shown.
+.SH "SEE ALSO"
+.PP
+\fBwpa_cli\fR(8)
+\fBwpa_supplicant\fR(8)
+.SH "LEGAL"
+.PP
+wpa_supplicant is copyright (c) 2003-2015,
+Jouni Malinen <j@w1.fi> and
+contributors.
+All Rights Reserved.
+.PP
+This program is licensed under the BSD license (the one with
+advertisement clause removed).
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_passphrase.8 hostap_2_4/wpa_supplicant/doc/docbook/wpa_passphrase.8
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_passphrase.8	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/wpa_passphrase.8	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,40 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "WPA_PASSPHRASE" "8" "15 March 2015" "" ""
+
+.SH NAME
+wpa_passphrase \- Generate a WPA PSK from an ASCII passphrase for a SSID
+.SH SYNOPSIS
+
+\fBwpa_passphrase\fR [ \fB\fIssid\fB\fR ] [ \fB\fIpassphrase\fB\fR ]
+
+.SH "OVERVIEW"
+.PP
+\fBwpa_passphrase\fR pre-computes PSK entries for
+network configuration blocks of a
+\fIwpa_supplicant.conf\fR file. An ASCII passphrase
+and SSID are used to generate a 256-bit PSK.
+.SH "OPTIONS"
+.TP
+\fBssid\fR
+The SSID whose passphrase should be derived.
+.TP
+\fBpassphrase\fR
+The passphrase to use. If not included on the command line,
+passphrase will be read from standard input.
+.SH "SEE ALSO"
+.PP
+\fBwpa_supplicant.conf\fR(5)
+\fBwpa_supplicant\fR(8)
+.SH "LEGAL"
+.PP
+wpa_supplicant is copyright (c) 2003-2015,
+Jouni Malinen <j@w1.fi> and
+contributors.
+All Rights Reserved.
+.PP
+This program is licensed under the BSD license (the one with
+advertisement clause removed).
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_priv.8 hostap_2_4/wpa_supplicant/doc/docbook/wpa_priv.8
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_priv.8	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/wpa_priv.8	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,120 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "WPA_PRIV" "8" "15 March 2015" "" ""
+
+.SH NAME
+wpa_priv \- wpa_supplicant privilege separation helper
+.SH SYNOPSIS
+
+\fBwpa_priv\fR [ \fB-c \fIctrl path\fB\fR ] [ \fB-Bdd\fR ] [ \fB-P \fIpid file\fB\fR ] [ \fBdriver:ifname \fI[driver:ifname ...]\fB\fR ]
+
+.SH "OVERVIEW"
+.PP
+\fBwpa_priv\fR is a privilege separation helper that
+minimizes the size of \fBwpa_supplicant\fR code that needs
+to be run with root privileges.
+.PP
+If enabled, privileged operations are done in the wpa_priv process
+while leaving rest of the code (e.g., EAP authentication and WPA
+handshakes) to operate in an unprivileged process (wpa_supplicant) that
+can be run as non-root user. Privilege separation restricts the effects
+of potential software errors by containing the majority of the code in an
+unprivileged process to avoid the possibility of a full system
+compromise.
+.PP
+\fBwpa_priv\fR needs to be run with network admin
+privileges (usually, root user). It opens a UNIX domain socket for each
+interface that is included on the command line; any other interface will
+be off limits for \fBwpa_supplicant\fR in this kind of
+configuration. After this, \fBwpa_supplicant\fR can be run as
+a non-root user (e.g., all standard users on a laptop or as a special
+non-privileged user account created just for this purpose to limit access
+to user files even further).
+.SH "EXAMPLE CONFIGURATION"
+.PP
+The following steps are an example of how to configure
+\fBwpa_priv\fR to allow users in the
+\fBwpapriv\fR group to communicate with
+\fBwpa_supplicant\fR with privilege separation:
+.PP
+Create user group (e.g., wpapriv) and assign users that
+should be able to use wpa_supplicant into that group.
+.PP
+Create /var/run/wpa_priv directory for UNIX domain sockets and
+control user access by setting it accessible only for the wpapriv
+group:
+.sp
+.RS
+
+.nf
+mkdir /var/run/wpa_priv
+chown root:wpapriv /var/run/wpa_priv
+chmod 0750 /var/run/wpa_priv
+.fi
+.RE
+.PP
+Start \fBwpa_priv\fR as root (e.g., from system
+startup scripts) with the enabled interfaces configured on the
+command line:
+.sp
+.RS
+
+.nf
+wpa_priv -B -c /var/run/wpa_priv -P /var/run/wpa_priv.pid wext:wlan0
+.fi
+.RE
+.PP
+Run \fBwpa_supplicant\fR as non-root with a user
+that is in the wpapriv group:
+.sp
+.RS
+
+.nf
+wpa_supplicant -i ath0 -c wpa_supplicant.conf
+.fi
+.RE
+.SH "COMMAND ARGUMENTS"
+.TP
+\fB-c ctrl path\fR
+Specify the path to wpa_priv control directory
+(Default: /var/run/wpa_priv/).
+.TP
+\fB-B\fR
+Run as a daemon in the background.
+.TP
+\fB-P file\fR
+Set the location of the PID
+file.
+.TP
+\fBdriver:ifname [driver:ifname ...]\fR
+The <driver> string dictates which of the
+supported \fBwpa_supplicant\fR driver backends is to be
+used. To get a list of supported driver types see wpa_supplicant help
+(e.g, wpa_supplicant -h). The driver backend supported by most good
+drivers is \fBwext\fR\&.
+
+The <ifname> string specifies which network
+interface is to be managed by \fBwpa_supplicant\fR
+(e.g., wlan0 or ath0).
+
+\fBwpa_priv\fR does not use the network interface
+before \fBwpa_supplicant\fR is started, so it is fine to
+include network interfaces that are not available at the time wpa_priv
+is started. wpa_priv can control multiple interfaces with one process,
+but it is also possible to run multiple \fBwpa_priv\fR
+processes at the same time, if desired.
+.SH "SEE ALSO"
+.PP
+\fBwpa_supplicant\fR(8)
+.SH "LEGAL"
+.PP
+wpa_supplicant is copyright (c) 2003-2015,
+Jouni Malinen <j@w1.fi> and
+contributors.
+All Rights Reserved.
+.PP
+This program is licensed under the BSD license (the one with
+advertisement clause removed).
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_supplicant.8 hostap_2_4/wpa_supplicant/doc/docbook/wpa_supplicant.8
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_supplicant.8	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/wpa_supplicant.8	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,544 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "WPA_SUPPLICANT" "8" "15 March 2015" "" ""
+
+.SH NAME
+wpa_supplicant \- Wi-Fi Protected Access client and IEEE 802.1X supplicant
+.SH SYNOPSIS
+
+\fBwpa_supplicant\fR [ \fB-BddfhKLqqsTtuvW\fR ] [ \fB-i\fIifname\fB\fR ] [ \fB-c\fIconfig file\fB\fR ] [ \fB-D\fIdriver\fB\fR ] [ \fB-P\fIPID_file\fB\fR ] [ \fB-f\fIoutput file\fB\fR ]
+
+.SH "OVERVIEW"
+.PP
+Wireless networks do not require physical access to the network equipment
+in the same way as wired networks. This makes it easier for unauthorized
+users to passively monitor a network and capture all transmitted frames.
+In addition, unauthorized use of the network is much easier. In many cases,
+this can happen even without user's explicit knowledge since the wireless
+LAN adapter may have been configured to automatically join any available
+network.
+.PP
+Link-layer encryption can be used to provide a layer of security for
+wireless networks. The original wireless LAN standard, IEEE 802.11,
+included a simple encryption mechanism, WEP. However, that proved to
+be flawed in many areas and network protected with WEP cannot be consider
+secure. IEEE 802.1X authentication and frequently changed dynamic WEP keys
+can be used to improve the network security, but even that has inherited
+security issues due to the use of WEP for encryption. Wi-Fi Protected
+Access and IEEE 802.11i amendment to the wireless LAN standard introduce
+a much improvement mechanism for securing wireless networks. IEEE 802.11i
+enabled networks that are using CCMP (encryption mechanism based on strong
+cryptographic algorithm AES) can finally be called secure used for
+applications which require efficient protection against unauthorized
+access.
+.PP
+\fBwpa_supplicant\fR is an implementation of
+the WPA Supplicant component, i.e., the part that runs in the
+client stations. It implements WPA key negotiation with a WPA
+Authenticator and EAP authentication with Authentication
+Server. In addition, it controls the roaming and IEEE 802.11
+authentication/association of the wireless LAN driver.
+.PP
+\fBwpa_supplicant\fR is designed to be a
+"daemon" program that runs in the background and acts as the
+backend component controlling the wireless
+connection. \fBwpa_supplicant\fR supports separate
+frontend programs and an example text-based frontend,
+\fBwpa_cli\fR, is included with
+wpa_supplicant.
+.PP
+Before wpa_supplicant can do its work, the network interface
+must be available.  That means that the physical device must be
+present and enabled, and the driver for the device must be
+loaded. The daemon will exit immediately if the device is not already
+available.
+.PP
+After \fBwpa_supplicant\fR has configured the
+network device, higher level configuration such as DHCP may
+proceed.  There are a variety of ways to integrate wpa_supplicant
+into a machine's networking scripts, a few of which are described
+in sections below.
+.PP
+The following steps are used when associating with an AP
+using WPA:
+.TP 0.2i
+\(bu
+\fBwpa_supplicant\fR requests the kernel
+driver to scan neighboring BSSes
+.TP 0.2i
+\(bu
+\fBwpa_supplicant\fR selects a BSS based on
+its configuration
+.TP 0.2i
+\(bu
+\fBwpa_supplicant\fR requests the kernel
+driver to associate with the chosen BSS
+.TP 0.2i
+\(bu
+If WPA-EAP: integrated IEEE 802.1X Supplicant
+completes EAP authentication with the
+authentication server (proxied by the Authenticator in the
+AP)
+.TP 0.2i
+\(bu
+If WPA-EAP: master key is received from the IEEE 802.1X
+Supplicant
+.TP 0.2i
+\(bu
+If WPA-PSK: \fBwpa_supplicant\fR uses PSK
+as the master session key
+.TP 0.2i
+\(bu
+\fBwpa_supplicant\fR completes WPA 4-Way
+Handshake and Group Key Handshake with the Authenticator
+(AP)
+.TP 0.2i
+\(bu
+\fBwpa_supplicant\fR configures encryption
+keys for unicast and broadcast
+.TP 0.2i
+\(bu
+normal data packets can be transmitted and received
+.SH "SUPPORTED FEATURES"
+.PP
+Supported WPA/IEEE 802.11i features:
+.TP 0.2i
+\(bu
+WPA-PSK ("WPA-Personal")
+.TP 0.2i
+\(bu
+WPA with EAP (e.g., with RADIUS authentication server)
+("WPA-Enterprise") Following authentication methods are
+supported with an integrate IEEE 802.1X Supplicant:
+.RS
+.TP 0.2i
+\(bu
+EAP-TLS
+.RE
+.RS
+.TP 0.2i
+\(bu
+EAP-PEAP/MSCHAPv2 (both PEAPv0 and PEAPv1)
+.TP 0.2i
+\(bu
+EAP-PEAP/TLS (both PEAPv0 and PEAPv1)
+.TP 0.2i
+\(bu
+EAP-PEAP/GTC (both PEAPv0 and PEAPv1)
+.TP 0.2i
+\(bu
+EAP-PEAP/OTP (both PEAPv0 and PEAPv1)
+.TP 0.2i
+\(bu
+EAP-PEAP/MD5-Challenge (both PEAPv0 and PEAPv1)
+.TP 0.2i
+\(bu
+EAP-TTLS/EAP-MD5-Challenge
+.TP 0.2i
+\(bu
+EAP-TTLS/EAP-GTC
+.TP 0.2i
+\(bu
+EAP-TTLS/EAP-OTP
+.TP 0.2i
+\(bu
+EAP-TTLS/EAP-MSCHAPv2
+.TP 0.2i
+\(bu
+EAP-TTLS/EAP-TLS
+.TP 0.2i
+\(bu
+EAP-TTLS/MSCHAPv2
+.TP 0.2i
+\(bu
+EAP-TTLS/MSCHAP
+.TP 0.2i
+\(bu
+EAP-TTLS/PAP
+.TP 0.2i
+\(bu
+EAP-TTLS/CHAP
+.TP 0.2i
+\(bu
+EAP-SIM
+.TP 0.2i
+\(bu
+EAP-AKA
+.TP 0.2i
+\(bu
+EAP-PSK
+.TP 0.2i
+\(bu
+EAP-PAX
+.TP 0.2i
+\(bu
+LEAP (note: requires special support from
+the driver for IEEE 802.11 authentication)
+.TP 0.2i
+\(bu
+(following methods are supported, but since
+they do not generate keying material, they cannot be used
+with WPA or IEEE 802.1X WEP keying)
+.TP 0.2i
+\(bu
+EAP-MD5-Challenge 
+.TP 0.2i
+\(bu
+EAP-MSCHAPv2
+.TP 0.2i
+\(bu
+EAP-GTC
+.TP 0.2i
+\(bu
+EAP-OTP
+.RE
+.TP 0.2i
+\(bu
+key management for CCMP, TKIP, WEP104, WEP40
+.TP 0.2i
+\(bu
+RSN/WPA2 (IEEE 802.11i)
+.RS
+.TP 0.2i
+\(bu
+pre-authentication
+.TP 0.2i
+\(bu
+PMKSA caching
+.RE
+.SH "AVAILABLE DRIVERS"
+.PP
+A summary of available driver backends is below. Support for each
+of the driver backends is chosen at wpa_supplicant compile time. For a
+list of supported driver backends that may be used with the -D option on
+your system, refer to the help output of wpa_supplicant
+(\fBwpa_supplicant -h\fR).
+.TP
+\fBwext\fR
+Linux wireless extensions (generic).
+.TP
+\fBwired\fR
+wpa_supplicant wired Ethernet driver
+.TP
+\fBroboswitch\fR
+wpa_supplicant Broadcom switch driver
+.TP
+\fBbsd\fR
+BSD 802.11 support (Atheros, etc.).
+.TP
+\fBndis\fR
+Windows NDIS driver.
+.SH "COMMAND LINE OPTIONS"
+.PP
+Most command line options have global scope. Some are given per
+interface, and are only valid if at least one \fB-i\fR option
+is specified, otherwise they're ignored. Option groups for different
+interfaces must be separated by \fB-N\fR option.
+.TP
+\fB-b br_ifname\fR
+Optional bridge interface name. (Per interface)
+.TP
+\fB-B\fR
+Run daemon in the background.
+.TP
+\fB-c filename\fR
+Path to configuration file. (Per interface)
+.TP
+\fB-C ctrl_interface\fR
+Path to ctrl_interface socket (Per interface. Only used if
+\fB-c\fR is not).
+.TP
+\fB-i ifname\fR
+Interface to listen on. Multiple instances of this option can
+be present, one per interface, separated by \fB-N\fR
+option (see below).
+.TP
+\fB-d\fR
+Increase debugging verbosity (\fB-dd\fR even
+more).
+.TP
+\fB-D driver\fR
+Driver to use (can be multiple drivers: nl80211,wext).
+(Per interface, see the available options below.)
+.TP
+\fB-e entropy file\fR
+File for \fBwpa_supplicant\fR to use to
+maintain its internal entropy store in over restarts.
+.TP
+\fB-f output file\fR
+Log output to specified file instead of stdout. (This
+is only available if \fBwpa_supplicant\fR was
+built with the CONFIG_DEBUG_FILE
+option.)
+.TP
+\fB-g global ctrl_interface\fR
+Path to global ctrl_interface socket. If specified, interface
+definitions may be omitted.
+.TP
+\fB-K\fR
+Include keys (passwords, etc.) in debug output.
+.TP
+\fB-t\fR
+Include timestamp in debug messages.
+.TP
+\fB-h\fR
+Help.  Show a usage message.
+.TP
+\fB-L\fR
+Show license (BSD).
+.TP
+\fB-o override driver\fR
+Override the driver parameter for new
+interfaces.
+.TP
+\fB-O override ctrl_interface\fR
+Override the ctrl_interface parameter for new
+interfaces.
+.TP
+\fB-p\fR
+Driver parameters. (Per interface)
+.TP
+\fB-P PID_file\fR
+Path to PID file.
+.TP
+\fB-q\fR
+Decrease debugging verbosity (\fB-qq\fR even
+less).
+.TP
+\fB-s\fR
+Log output to syslog instead of stdout. (This is only
+available if \fBwpa_supplicant\fR was built
+with the CONFIG_DEBUG_SYSLOG
+option.)
+.TP
+\fB-T\fR
+Log output to Linux tracing in addition to any other
+destinations. (This is only available
+if \fBwpa_supplicant\fR was built with
+the CONFIG_DEBUG_LINUX_TRACING
+option.)
+.TP
+\fB-t\fR
+Include timestamp in debug messages.
+.TP
+\fB-u\fR
+Enable DBus control interface. If enabled, interface
+definitions may be omitted. (This is only available
+if \fBwpa_supplicant\fR was built with
+the CONFIG_DBUS option.)
+.TP
+\fB-v\fR
+Show version.
+.TP
+\fB-W\fR
+Wait for a control interface monitor before starting.
+.TP
+\fB-N\fR
+Start describing new interface.
+.SH "EXAMPLES"
+.PP
+In most common cases, \fBwpa_supplicant\fR is
+started with:
+.sp
+.RS
+
+.nf
+wpa_supplicant -B -c/etc/wpa_supplicant.conf -iwlan0
+.fi
+.RE
+.PP
+This makes the process fork into background.
+.PP
+The easiest way to debug problems, and to get debug log for
+bug reports, is to start \fBwpa_supplicant\fR on
+foreground with debugging enabled:
+.sp
+.RS
+
+.nf
+wpa_supplicant -c/etc/wpa_supplicant.conf -iwlan0 -d
+.fi
+.RE
+.PP
+If the specific driver wrapper is not known beforehand, it is
+possible to specify multiple comma separated driver wrappers on the command
+line. \fBwpa_supplicant\fR will use the first driver
+wrapper that is able to initialize the interface.
+.sp
+.RS
+
+.nf
+wpa_supplicant -Dnl80211,wext -c/etc/wpa_supplicant.conf -iwlan0
+.fi
+.RE
+.PP
+\fBwpa_supplicant\fR can control multiple
+interfaces (radios) either by running one process for each
+interface separately or by running just one process and list of
+options at command line. Each interface is separated with -N
+argument. As an example, following command would start
+wpa_supplicant for two interfaces:
+.sp
+.RS
+
+.nf
+wpa_supplicant \\
+	-c wpa1.conf -i wlan0 -D nl80211 -N \\
+	-c wpa2.conf -i ath0 -D wext
+.fi
+.RE
+.SH "OS REQUIREMENTS"
+.PP
+Current hardware/software requirements:
+.TP 0.2i
+\(bu
+Linux kernel 2.4.x or 2.6.x with Linux Wireless
+Extensions v15 or newer
+.TP 0.2i
+\(bu
+FreeBSD 6-CURRENT
+.TP 0.2i
+\(bu
+Microsoft Windows with WinPcap (at least WinXP, may work
+with other versions)
+.SH "SUPPORTED DRIVERS"
+.TP
+\fBLinux wireless extensions\fR
+In theory, any driver that supports Linux wireless
+extensions can be used with IEEE 802.1X (i.e., not WPA) when
+using ap_scan=0 option in configuration file.
+.TP
+\fBWired Ethernet drivers\fR
+Use ap_scan=0.
+.TP
+\fBBSD net80211 layer (e.g., Atheros driver)\fR
+At the moment, this is for FreeBSD 6-CURRENT branch.
+.TP
+\fBWindows NDIS\fR
+The current Windows port requires WinPcap
+(http://winpcap.polito.it/).  See README-Windows.txt for more
+information.
+.PP
+wpa_supplicant was designed to be portable for different
+drivers and operating systems. Hopefully, support for more wlan
+cards and OSes will be added in the future. See developer.txt for
+more information about the design of wpa_supplicant and porting to
+other drivers. One main goal is to add full WPA/WPA2 support to
+Linux wireless extensions to allow new drivers to be supported
+without having to implement new driver-specific interface code in
+wpa_supplicant.
+.SH "ARCHITECTURE"
+.PP
+The
+\fBwpa_supplicant\fR system consists of the following
+components:
+.TP
+\fB\fIwpa_supplicant.conf\fB \fR
+the configuration file describing all networks that the
+user wants the computer to connect to.  
+.TP
+\fBwpa_supplicant\fR
+the program that directly interacts with the
+network interface.  
+.TP
+\fBwpa_cli\fR
+the
+client program that provides a high-level interface to the
+functionality of the daemon.  
+.TP
+\fBwpa_passphrase\fR
+a utility needed to construct
+\fIwpa_supplicant.conf\fR files that include
+encrypted passwords.
+.SH "QUICK START"
+.PP
+First, make a configuration file, e.g.
+\fI/etc/wpa_supplicant.conf\fR, that describes the networks
+you are interested in.  See \fBwpa_supplicant.conf\fR(5)
+for details.
+.PP
+Once the configuration is ready, you can test whether the
+configuration works by running \fBwpa_supplicant\fR
+with following command to start it on foreground with debugging
+enabled:
+.sp
+.RS
+
+.nf
+wpa_supplicant -iwlan0 -c/etc/wpa_supplicant.conf -d
+    
+.fi
+.RE
+.PP
+Assuming everything goes fine, you can start using following
+command to start \fBwpa_supplicant\fR on background
+without debugging:
+.sp
+.RS
+
+.nf
+wpa_supplicant -iwlan0 -c/etc/wpa_supplicant.conf -B
+    
+.fi
+.RE
+.PP
+Please note that if you included more than one driver
+interface in the build time configuration (.config), you may need
+to specify which interface to use by including -D<driver
+name> option on the command line.
+.SH "INTERFACE TO PCMCIA-CS/CARDMRG"
+.PP
+For example, following small changes to pcmcia-cs scripts
+can be used to enable WPA support:
+.PP
+Add MODE="Managed" and WPA="y" to the network scheme in
+\fI/etc/pcmcia/wireless.opts\fR\&.
+.PP
+Add the following block to the end of \fBstart\fR
+action handler in \fI/etc/pcmcia/wireless\fR:
+.sp
+.RS
+
+.nf
+if [ "$WPA" = "y" -a -x /usr/local/bin/wpa_supplicant ]; then
+    /usr/local/bin/wpa_supplicant -B -c/etc/wpa_supplicant.conf -i$DEVICE
+fi
+    
+.fi
+.RE
+.PP
+Add the following block to the end of \fBstop\fR
+action handler (may need to be separated from other actions) in
+\fI/etc/pcmcia/wireless\fR:
+.sp
+.RS
+
+.nf
+if [ "$WPA" = "y" -a -x /usr/local/bin/wpa_supplicant ]; then
+    killall wpa_supplicant
+fi
+    
+.fi
+.RE
+.PP
+This will make \fBcardmgr\fR start
+\fBwpa_supplicant\fR when the card is plugged
+in.
+.SH "SEE ALSO"
+.PP
+\fBwpa_background\fR(8)
+\fBwpa_supplicant.conf\fR(5)
+\fBwpa_cli\fR(8)
+\fBwpa_passphrase\fR(8)
+.SH "LEGAL"
+.PP
+wpa_supplicant is copyright (c) 2003-2015,
+Jouni Malinen <j@w1.fi> and
+contributors.
+All Rights Reserved.
+.PP
+This program is licensed under the BSD license (the one with
+advertisement clause removed).
diff -urN hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_supplicant.conf.5 hostap_2_4/wpa_supplicant/doc/docbook/wpa_supplicant.conf.5
--- hostap_2_4.orig/wpa_supplicant/doc/docbook/wpa_supplicant.conf.5	1970-01-01 08:00:00.000000000 +0800
+++ hostap_2_4/wpa_supplicant/doc/docbook/wpa_supplicant.conf.5	2015-09-24 15:25:20.373038328 +0800
@@ -0,0 +1,225 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "WPA_SUPPLICANT.CONF" "5" "15 March 2015" "" ""
+
+.SH NAME
+wpa_supplicant.conf \- configuration file for wpa_supplicant
+.SH "OVERVIEW"
+.PP
+\fBwpa_supplicant\fR is configured using a text
+file that lists all accepted networks and security policies,
+including pre-shared keys. See the example configuration file,
+probably in \fB/usr/share/doc/wpa_supplicant/\fR, for
+detailed information about the configuration format and supported
+fields.
+.PP
+All file paths in this configuration file should use full
+(absolute, not relative to working directory) path in order to allow
+working directory to be changed. This can happen if wpa_supplicant is
+run in the background.
+.PP
+Changes to configuration file can be reloaded be sending
+SIGHUP signal to \fBwpa_supplicant\fR ('killall -HUP
+wpa_supplicant'). Similarly, reloading can be triggered with
+the \fBwpa_cli reconfigure\fR command.
+.PP
+Configuration file can include one or more network blocks,
+e.g., one for each used SSID. wpa_supplicant will automatically
+select the best network based on the order of network blocks in
+the configuration file, network security level (WPA/WPA2 is
+preferred), and signal strength.
+.SH "QUICK EXAMPLES"
+.TP 3
+1. 
+WPA-Personal (PSK) as home network and WPA-Enterprise with
+EAP-TLS as work network.
+.sp
+.RS
+
+.nf
+# allow frontend (e.g., wpa_cli) to be used by all users in 'wheel' group
+ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel
+#
+# home network; allow all valid ciphers
+network={
+	ssid="home"
+	scan_ssid=1
+	key_mgmt=WPA-PSK
+	psk="very secret passphrase"
+}
+#
+# work network; use EAP-TLS with WPA; allow only CCMP and TKIP ciphers
+network={
+	ssid="work"
+	scan_ssid=1
+	key_mgmt=WPA-EAP
+	pairwise=CCMP TKIP
+	group=CCMP TKIP
+	eap=TLS
+	identity="user@example.com"
+	ca_cert="/etc/cert/ca.pem"
+	client_cert="/etc/cert/user.pem"
+	private_key="/etc/cert/user.prv"
+	private_key_passwd="password"
+}
+.fi
+.RE
+.TP 3
+2. 
+WPA-RADIUS/EAP-PEAP/MSCHAPv2 with RADIUS servers that
+use old peaplabel (e.g., Funk Odyssey and SBR, Meetinghouse
+Aegis, Interlink RAD-Series)
+.sp
+.RS
+
+.nf
+ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel
+network={
+	ssid="example"
+	scan_ssid=1
+	key_mgmt=WPA-EAP
+	eap=PEAP
+	identity="user@example.com"
+	password="foobar"
+	ca_cert="/etc/cert/ca.pem"
+	phase1="peaplabel=0"
+	phase2="auth=MSCHAPV2"
+}
+.fi
+.RE
+.TP 3
+3. 
+EAP-TTLS/EAP-MD5-Challenge configuration with anonymous
+identity for the unencrypted use. Real identity is sent only
+within an encrypted TLS tunnel.
+.sp
+.RS
+
+.nf
+ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel
+network={
+	ssid="example"
+	scan_ssid=1
+	key_mgmt=WPA-EAP
+	eap=TTLS
+	identity="user@example.com"
+	anonymous_identity="anonymous@example.com"
+	password="foobar"
+	ca_cert="/etc/cert/ca.pem"
+	phase2="auth=MD5"
+}
+.fi
+.RE
+.TP 3
+4. 
+IEEE 802.1X (i.e., no WPA) with dynamic WEP keys
+(require both unicast and broadcast); use EAP-TLS for
+authentication
+.sp
+.RS
+
+.nf
+ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel
+network={
+	ssid="1x-test"
+	scan_ssid=1
+	key_mgmt=IEEE8021X
+	eap=TLS
+	identity="user@example.com"
+	ca_cert="/etc/cert/ca.pem"
+	client_cert="/etc/cert/user.pem"
+	private_key="/etc/cert/user.prv"
+	private_key_passwd="password"
+	eapol_flags=3
+}
+.fi
+.RE
+.TP 3
+5. 
+Catch all example that allows more or less all
+configuration modes. The configuration options are used based
+on what security policy is used in the selected SSID. This is
+mostly for testing and is not recommended for normal
+use.
+.sp
+.RS
+
+.nf
+ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel
+network={
+	ssid="example"
+	scan_ssid=1
+	key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE
+	pairwise=CCMP TKIP
+	group=CCMP TKIP WEP104 WEP40
+	psk="very secret passphrase"
+	eap=TTLS PEAP TLS
+	identity="user@example.com"
+	password="foobar"
+	ca_cert="/etc/cert/ca.pem"
+	client_cert="/etc/cert/user.pem"
+	private_key="/etc/cert/user.prv"
+	private_key_passwd="password"
+	phase1="peaplabel=0"
+	ca_cert2="/etc/cert/ca2.pem"
+	client_cert2="/etc/cer/user.pem"
+	private_key2="/etc/cer/user.prv"
+	private_key2_passwd="password"
+}
+.fi
+.RE
+.TP 3
+6. 
+Authentication for wired Ethernet. This can be used with
+\fBwired\fR or \fBroboswitch\fR interface
+(-Dwired or -Droboswitch on command line).
+.sp
+.RS
+
+.nf
+ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel
+ap_scan=0
+network={
+	key_mgmt=IEEE8021X
+	eap=MD5
+	identity="user"
+	password="password"
+	eapol_flags=0
+}
+.fi
+.RE
+.SH "CERTIFICATES"
+.PP
+Some EAP authentication methods require use of
+certificates. EAP-TLS uses both server side and client
+certificates whereas EAP-PEAP and EAP-TTLS only require the server
+side certificate. When client certificate is used, a matching
+private key file has to also be included in configuration. If the
+private key uses a passphrase, this has to be configured in
+wpa_supplicant.conf ("private_key_passwd").
+.PP
+wpa_supplicant supports X.509 certificates in PEM and DER
+formats. User certificate and private key can be included in the
+same file.
+.PP
+If the user certificate and private key is received in
+PKCS#12/PFX format, they need to be converted to suitable PEM/DER
+format for wpa_supplicant. This can be done, e.g., with following
+commands:
+.sp
+.RS
+
+.nf
+# convert client certificate and private key to PEM format
+openssl pkcs12 -in example.pfx -out user.pem -clcerts
+# convert CA certificate (if included in PFX file) to PEM format
+openssl pkcs12 -in example.pfx -out ca.pem -cacerts -nokeys
+.fi
+.RE
+.SH "SEE ALSO"
+.PP
+\fBwpa_supplicant\fR(8)
+\fBopenssl\fR(1)
diff -urN hostap_2_4.orig/wpa_supplicant/driver_i.h hostap_2_4/wpa_supplicant/driver_i.h
--- hostap_2_4.orig/wpa_supplicant/driver_i.h	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/driver_i.h	2015-09-24 15:25:20.373038328 +0800
@@ -505,9 +505,15 @@
 
 static inline int wpa_drv_shared_freq(struct wpa_supplicant *wpa_s)
 {
+#ifdef TIZEN_PHY_FREQ
+	/* Tizen: Get frequency of Physical device */
+    	extern int wpa_suppicant_get_freq_phy_device(struct wpa_supplicant *wpa_s);
+        return wpa_suppicant_get_freq_phy_device(wpa_s);
+#else
 	if (!wpa_s->driver->shared_freq)
 		return -1;
 	return wpa_s->driver->shared_freq(wpa_s->drv_priv);
+#endif /* TIZEN_PHY_FREQ */
 }
 
 static inline int wpa_drv_get_noa(struct wpa_supplicant *wpa_s,
diff -urN hostap_2_4.orig/wpa_supplicant/events.c hostap_2_4/wpa_supplicant/events.c
--- hostap_2_4.orig/wpa_supplicant/events.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/events.c	2015-09-24 15:25:20.377038328 +0800
@@ -23,6 +23,7 @@
 #include "eap_peer/eap.h"
 #include "ap/hostapd.h"
 #include "p2p/p2p.h"
+#include "p2p/p2p_i.h"
 #include "wnm_sta.h"
 #include "notify.h"
 #include "common/ieee802_11_defs.h"
@@ -45,6 +46,16 @@
 #include "mesh.h"
 #include "mesh_mpm.h"
 #include "wmm_ac.h"
+#include "wps/wps_i.h"
+
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+#include <sys/prctl.h>
+
+#ifndef PR_TASK_PERF_USER_TRACE
+#define PR_TASK_PERF_USER_TRACE 666
+#endif // PR_TASK_PERF_USER_TRACE
+ 
+#endif // TIZEN_BOOTING_PERFOMANCE_TEST
 
 
 #ifndef CONFIG_NO_SCAN_PROCESSING
@@ -1078,6 +1089,48 @@
 }
 
 
+#ifdef SAMSUNG_P2P_PREKEY
+void wpa_supplicant_prekey_ssid(struct wpa_supplicant *wpa_s , struct wpa_bss *selected,struct wpa_ssid * ssid)
+{
+        if (wpa_s->ifname && (os_strcmp(wpa_s->ifname , "wlan0") == 0))
+                return;
+
+        if (wpa_s->global->p2p == NULL) {
+                wpa_printf(MSG_ERROR , "SS:[%s] ---- wpa_s->global->p2p is NULL \r\n" , __func__);
+                return;
+        }
+
+        //if ((wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT) && os_strlen(wpa_s->global->p2p->cfg->pre_Recvpassphrase) > 0) {
+        if ((wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT)) {
+                if ((selected->ssid_len > 0) && (ssid->ssid_len <= 0)) {
+                        if (ssid->ssid)
+                                os_free(ssid->ssid);
+
+                        ssid->ssid = os_zalloc(selected->ssid_len + 1);
+                        if (ssid->ssid) {
+                                os_memcpy(ssid->ssid, selected->ssid, selected->ssid_len);
+                                ssid->ssid_len = selected->ssid_len;
+
+                                if (!ssid->passphrase) {
+                                        ssid->passphrase = os_zalloc(64);
+                                        if (ssid->passphrase) {
+                                                p2p_get_hash_prekey(wpa_s->global->p2p->cfg->pre_Recvpassphrase, ssid->passphrase , 8);
+                                        }
+                                }
+
+                                if (ssid->passphrase) {
+                                        wpa_config_update_psk(ssid);
+                                }
+                                else {
+                                        wpa_printf(MSG_ERROR , "SS:[%s] passphrase is NULL. \r\n" , __func__);
+                                }
+                        }
+                }
+        }
+
+}
+#endif /* SAMSUNG_P2P_PREKEY */
+
 int wpa_supplicant_connect(struct wpa_supplicant *wpa_s,
 			   struct wpa_bss *selected,
 			   struct wpa_ssid *ssid)
@@ -1095,7 +1148,15 @@
 #endif /* CONFIG_P2P */
 
 #ifdef CONFIG_WPS
+#ifdef TIZEN_WPS_PBC
+                wps_fail_event(wpa_s->wps, WPS_ProbeRequest,
+                               WPS_CFG_MULTIPLE_PBC_DETECTED,
+                               WPS_EI_NO_ERROR, selected->bssid);
+                wpas_wps_cancel(wpa_s);
+		wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
+#else
 		wpas_wps_cancel(wpa_s);
+#endif /* TIZEN_WPS_PBC */
 #endif /* CONFIG_WPS */
 		return -1;
 	}
@@ -1129,6 +1190,9 @@
 		}
 		wpa_msg(wpa_s, MSG_DEBUG, "Request association with " MACSTR,
 			MAC2STR(selected->bssid));
+#ifdef SAMSUNG_P2P_PREKEY
+		wpa_supplicant_prekey_ssid(wpa_s , selected, ssid);
+#endif /* SAMSUNG_P2P_PREKEY */
 		wpa_supplicant_associate(wpa_s, selected, ssid);
 	} else {
 		wpa_dbg(wpa_s, MSG_DEBUG, "Already associated or trying to "
@@ -1366,6 +1430,19 @@
 
 	wpas_notify_scan_done(wpa_s, 1);
 
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+        {
+                char buf[100];
+
+                snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+                strncat(buf, wpa_s->ifname,  strlen(wpa_s->ifname));
+                strncat(buf, ": scan_result", strlen(": scan_result"));
+
+                prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+        }
+#endif //TIZEN_BOOTING_PERFOMANCE_TEST
+
+
 	if (!wpa_s->own_scan_running && wpa_s->radio->external_scan_running) {
 		wpa_dbg(wpa_s, MSG_DEBUG, "Do not use results from externally requested scan operation for network selection");
 		wpa_scan_results_free(scan_res);
@@ -1529,7 +1606,9 @@
 static int wpa_supplicant_event_scan_results(struct wpa_supplicant *wpa_s,
 					     union wpa_event_data *data)
 {
+#ifndef SAMSUNG_SRID	
 	struct wpa_supplicant *ifs;
+#endif	
 	int res;
 
 	res = _wpa_supplicant_event_scan_results(wpa_s, data, 1);
@@ -1550,6 +1629,8 @@
 		 */
 		return 0;
 	}
+#ifndef SAMSUNG_SRID
+	/* Do not update results to sibling interfaces */
 
 	/*
 	 * Check other interfaces to see if they share the same radio. If
@@ -1563,7 +1644,7 @@
 			_wpa_supplicant_event_scan_results(ifs, data, 0);
 		}
 	}
-
+#endif /* SAMSUNG_SRID */
 	return 0;
 }
 
@@ -1935,6 +2016,18 @@
 
 #ifdef CONFIG_AP
 	if (wpa_s->ap_iface) {
+#ifdef SAMSUNG_P2P_PREKEY
+                if (wpa_s->global->p2p && wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT_WPS_STARTED) {
+                        // cancel wps
+                        if (wpa_s->ap_iface->bss[0]->wps->registrar) {
+                                wps_registrar_wps_cancel(wpa_s->ap_iface->bss[0]->wps->registrar);
+                        }
+                        else {
+                                wpa_printf(MSG_ERROR , "Prekey:[%s] ---- registrar is NULL \r\n " , __func__);
+                        }
+                        wpa_s->global->p2p->cfg->isPreKey = SAMSUNG_PREKEY_SUPPORT;
+                }
+#endif /* SAMSUNG_P2P_PREKEY */	
 		if (!data)
 			return;
 		hostapd_notif_assoc(wpa_s->ap_iface->bss[0],
@@ -1942,6 +2035,9 @@
 				    data->assoc_info.req_ies,
 				    data->assoc_info.req_ies_len,
 				    data->assoc_info.reassoc);
+#ifdef TIZEN
+		wpa_msg(wpa_s, MSG_ERROR, "EVENT-STA-ASSOCED");
+#endif /* TIZEN */		
 		return;
 	}
 #endif /* CONFIG_AP */
@@ -2041,6 +2137,15 @@
 	}
 	wpa_supplicant_cancel_scan(wpa_s);
 
+#ifdef SAMSUNG_P2P_PREKEY
+        /*
+         * To clear provisioing state in client mode,
+         * while connecting to SAMSUNG PREKEY SUPPORTED Device
+         */
+	if(wpa_s->global->p2p && !(wpa_s->global->p2p->cfg->disable_skip_wps))
+	        prekey_group_formation_completed(wpa_s);
+#endif /* SAMSUNG_P2P_PREKEY */
+
 	if ((wpa_s->drv_flags & WPA_DRIVER_FLAGS_4WAY_HANDSHAKE) &&
 	    wpa_key_mgmt_wpa_psk(wpa_s->key_mgmt)) {
 		/*
@@ -2221,6 +2326,20 @@
 			return; /* P2P group removed */
 		wpas_auth_failed(wpa_s, "WRONG_KEY");
 	}
+#ifdef TIZEN
+	/*
+	 * Avoid Reconnect if Connected WLAN AP is Powered off
+	 */
+	if(wpa_s->wpa_state == WPA_COMPLETED && !(os_strcmp(wpa_s->ifname, "p2p0")==0))
+	{
+		wpa_s->disconnected = 1;
+		if(!locally_generated)
+		{
+			 //remove AP from bss table
+			 wpa_bss_flush_by_deauth(wpa_s);
+		}
+	}
+#endif /* TIZEN */
 	if (!wpa_s->disconnected &&
 	    (!wpa_s->auto_reconnect_disabled ||
 	     wpa_s->key_mgmt == WPA_KEY_MGMT_WPS ||
@@ -2503,6 +2622,114 @@
 }
 #endif /* CONFIG_TDLS */
 
+#ifdef CONFIG_WFD_TDLS
+#define TLV_HDR_LEN             2       /* header length */
+/* tag_ID/length/value_buffer tuple */
+typedef struct bcm_tlv {
+        u8      id;  
+        u8      len; 
+        u8      data[1];
+} bcm_tlv_t;
+
+static u8* bcm_parse_tlvs_wfdie(const u8 *buf, int buflen, u8 category)
+{
+        bcm_tlv_t *elt;
+        int totlen;
+
+        if(category == WLAN_ACTION_VENDOR_SPECIFIC) {
+                buf += 4;                       /* wfa_oui(3) + wfa_out_type(1) + */
+        } else if (category == WLAN_ACTION_TDLS) {
+                u8 action_code = *(u8*)buf;
+
+                if(action_code == WLAN_TDLS_SETUP_REQUEST) {
+                        buf += 4;               /* action(1) + dialog token(1) + capability(2) + */
+                } else if(action_code == WLAN_TDLS_SETUP_RESPONSE) {
+                        buf += 6;               /* action(1) + status code(2) + dialog token(1) + capability(2) + */
+                } else if(action_code == WLAN_TDLS_SETUP_CONFIRM) {
+                        buf += 4;               /* action(1) + status code(2) + dialog token(1) + */
+                } else {
+                        return NULL;
+                }
+        } else {
+                return NULL;
+        }
+
+        elt = (bcm_tlv_t*)buf;
+        totlen = buflen;
+
+        /* find tagged parameter */
+        while (totlen >= TLV_HDR_LEN) {
+                int len = elt->len;
+
+                /* validate remaining totlen */
+                if ((elt->id == WLAN_EID_VENDOR_SPECIFIC) && (totlen >= (int)(len + TLV_HDR_LEN))) {
+                        if(len > 4) {
+                                u32 ie_vendor_type = (elt->data[0] << 24) | (elt->data[1] << 16) | (elt->data[2] << 8) | elt->data[3];
+                                if(ie_vendor_type == WFD_IE_VENDOR_TYPE) {
+                                        return (u8*)(elt);
+                                }
+                        }
+                }
+
+                elt = (bcm_tlv_t*)((u8*)elt + (len + TLV_HDR_LEN));
+                totlen -= (len + TLV_HDR_LEN);
+        }
+
+        return NULL;
+}
+
+static void wpa_s_tdls_rx_action(struct wpa_supplicant *wpa_s,
+                                                        u8 category, const u8 *data, size_t len, const u8 *sa)
+{
+        if((category == WLAN_ACTION_TDLS) || (category == WLAN_ACTION_VENDOR_SPECIFIC)) {
+                char *wfd_ie = NULL;
+                u8 ie_len = 0;
+                u8* buff = NULL;
+                u8 buff_len = 0;
+
+                wpa_msg_global(wpa_s, MSG_ERROR, "Enter wpa_s_tdls_rx_action");
+
+                buff = bcm_parse_tlvs_wfdie(data, len, category);
+                if(buff == NULL)
+                {
+                                wpa_msg_global(wpa_s, MSG_ERROR, "Enter wpa_s_tdls_rx_action NULL??");
+                                return;
+                }
+                buff_len = len - ((int)buff - (int)data);
+
+                if(buff_len <= 0)
+                        return;
+                ie_len = buff_len * 2;
+                wfd_ie = os_zalloc(ie_len + 1);
+                if (!wfd_ie)
+                        return;
+
+                wpa_snprintf_hex(wfd_ie, ie_len + 1, (u8 *)buff, ie_len);
+
+                if(category == WLAN_ACTION_VENDOR_SPECIFIC) {
+                        wpa_msg_global(wpa_s, MSG_ERROR, TDLS_EVENT_PEER_FOUND MACSTR
+                                                        " tdls_wfd_ie=%s", MAC2STR(sa), wfd_ie);
+                        wpas_notify_tdls_peer(wpa_s, sa, ie_len, wfd_ie, "TDLSPeerFound");
+                } else if(category == WLAN_ACTION_TDLS) {
+                        u8 action_code = *(u8*)data;
+                        if(action_code == WLAN_TDLS_SETUP_CONFIRM) {
+                                wpa_msg_global(wpa_s, MSG_ERROR, TDLS_PEER_CONNECTED MACSTR
+                                                " tdls_wfd_ie=%s", MAC2STR(sa), wfd_ie);
+
+                                wpas_notify_tdls_peer(wpa_s, sa, ie_len, wfd_ie, "TDLSConnected");
+
+                        } else if(action_code == WLAN_TDLS_SETUP_RESPONSE) {
+                                wpa_msg_global(wpa_s, MSG_ERROR, TDLS_PEER_CONNECTED MACSTR
+                                                " tdls_wfd_ie=%s", MAC2STR(sa), wfd_ie);
+
+                                wpas_notify_tdls_peer(wpa_s, sa, ie_len, wfd_ie, "TDLSConnected");
+                        }
+                }
+
+                os_free(wfd_ie);
+        }
+}
+#endif /* CONFIG_WFD_TDLS */
 
 #ifdef CONFIG_WNM
 static void wpa_supplicant_event_wnm(struct wpa_supplicant *wpa_s,
@@ -2659,6 +2886,49 @@
 #endif /* CONFIG_IEEE80211W */
 }
 
+#if defined(CONFIG_P2P) && defined(TIZEN_P2P_LISTEN)
+void wpa_check_p2p_listen_resume(struct wpa_supplicant *wpa_s)
+{
+        struct wpa_supplicant *tmp_wpa_s;
+
+        if(wpa_s->global->p2p == NULL || wpa_s->global->p2p_disabled)
+                return;
+
+        for (tmp_wpa_s = wpa_s->global->ifaces; tmp_wpa_s; tmp_wpa_s = tmp_wpa_s->next) {
+                if (os_strcmp(tmp_wpa_s->ifname, "p2p0") == 0){
+                        if(tmp_wpa_s->p2p_long_listen_pending){
+                                tmp_wpa_s->p2p_long_listen = tmp_wpa_s->p2p_long_listen_pending;
+                                tmp_wpa_s->p2p_long_listen_pending = 0;
+                                wpas_p2p_listen(tmp_wpa_s, tmp_wpa_s->p2p_long_listen);
+                        }
+                        break;
+                }
+        }
+        return;
+}
+void wpa_check_p2p_listen_stop(struct wpa_supplicant *wpa_s)
+{
+        struct wpa_supplicant *tmp_wpa_s;
+     
+        if(wpa_s->global->p2p == NULL || wpa_s->global->p2p_disabled)
+                return;
+     
+        if(wpa_s->global->p2p->state == P2P_LISTEN_ONLY){
+                for (tmp_wpa_s = wpa_s->global->ifaces; tmp_wpa_s; tmp_wpa_s = tmp_wpa_s->next) {
+                        if (os_strcmp(tmp_wpa_s->ifname, "p2p0") == 0 && 
+                            tmp_wpa_s->p2p_long_listen){
+                                tmp_wpa_s->p2p_long_listen_pending = tmp_wpa_s->p2p_long_listen/1000;
+                                if(tmp_wpa_s->p2p_long_listen%1000)
+                                        tmp_wpa_s->p2p_long_listen_pending++;
+                                wpas_p2p_stop_find(tmp_wpa_s);
+                                break;
+                        }
+                }
+        }
+        return;
+}
+#endif /* CONFIG_P2P && TIZEN_P2P_LISTEN */
+
 
 static void wpas_event_disconnect(struct wpa_supplicant *wpa_s, const u8 *addr,
 				  u16 reason_code, int locally_generated,
@@ -2935,6 +3205,41 @@
 	}
 #endif /* CONFIG_TDLS */
 
+#ifdef CONFIG_WFD_TDLS
+       if(category == WLAN_ACTION_TDLS && plen >=4 &&
+                       payload[0] == WLAN_TDLS_SETUP_RESPONSE) {
+                       wpa_dbg(wpa_s, MSG_DEBUG,
+                                       "TDLS: Setup Response Frame from " MACSTR,
+                                               MAC2STR(mgmt->sa));
+
+                       wpa_s_tdls_rx_action(wpa_s, category, payload, plen, mgmt->sa);
+                       return;
+       }
+       if(category == WLAN_ACTION_TDLS && plen >=4 &&
+                       payload[0] == WLAN_TDLS_SETUP_CONFIRM) {
+                       wpa_dbg(wpa_s, MSG_DEBUG,
+                               "TDLS: Setup Confirmation frame Frame from " MACSTR,
+                                       MAC2STR(mgmt->sa));
+
+                       wpa_s_tdls_rx_action(wpa_s, category, payload, plen, mgmt->sa);
+                       return;
+       }
+       if(category == WLAN_ACTION_TDLS && plen >=4 &&
+                       payload[0] == WLAN_TDLS_TEARDOWN) {
+                       wpa_dbg(wpa_s, MSG_DEBUG,
+                               "TDLS: Teardown frame Frame from " MACSTR,
+                                       MAC2STR(mgmt->sa));
+                       wpas_notify_tdls_disconnected(wpa_s, mgmt->sa);
+                       return;
+       }
+       if(category == WLAN_ACTION_VENDOR_SPECIFIC && plen >=4) {
+                       wpa_dbg(wpa_s, MSG_DEBUG,
+                               "TDLS: Vendor specific probe Response Frame from " MACSTR,
+                                MAC2STR(mgmt->sa));
+                       wpa_s_tdls_rx_action(wpa_s, category, payload, plen, mgmt->sa);
+       }
+#endif /* CONFIG_WFD_TDLS */
+
 #ifdef CONFIG_INTERWORKING
 	if (category == WLAN_ACTION_QOS && plen >= 1 &&
 	    payload[0] == QOS_QOS_MAP_CONFIG) {
@@ -3093,6 +3398,10 @@
 	case EVENT_DEAUTH:
 		wpas_event_deauth(wpa_s,
 				  data ? &data->deauth_info : NULL);
+#if defined(CONFIG_P2P) && defined(TIZEN_P2P_LISTEN)
+		//wpas_notify_resume_listen(wpa_s);
+		wpa_check_p2p_listen_resume(wpa_s);
+#endif /* CONFIG_P2P && TIZEN_P2P_LISTEN */		
 		break;
 	case EVENT_MICHAEL_MIC_FAILURE:
 		wpa_supplicant_event_michael_mic_failure(wpa_s, data);
@@ -3125,6 +3434,10 @@
 		}
 		break;
 	case EVENT_SCAN_RESULTS:
+#if defined(CONFIG_P2P) && defined(TIZEN_P2P_LISTEN)
+		//wpas_notify_resume_listen(wpa_s);
+		wpa_check_p2p_listen_resume(wpa_s);
+#endif /* CONFIG_P2P && TIZEN_P2P_LISTEN */		
 		if (os_reltime_initialized(&wpa_s->scan_start_time)) {
 			struct os_reltime now, diff;
 			os_get_reltime(&now);
@@ -3194,6 +3507,10 @@
 			wpas_connection_failed(wpa_s, bssid);
 			wpa_supplicant_mark_disassoc(wpa_s);
 		}
+#if defined(CONFIG_P2P) && defined(TIZEN_P2P_LISTEN)
+		//wpas_notify_resume_listen(wpa_s);
+		wpa_check_p2p_listen_resume(wpa_s);
+#endif /* CONFIG_P2P && TIZEN_P2P_LISTEN */		
 		break;
 	case EVENT_AUTH_TIMED_OUT:
 		/* It is possible to get this event from earlier connection */
@@ -3485,6 +3802,9 @@
 		break;
 	case EVENT_INTERFACE_ENABLED:
 		wpa_dbg(wpa_s, MSG_DEBUG, "Interface was enabled");
+#ifdef SAMSUNG_SRID
+                wpa_s->interface_disabled = 0; 
+#endif
 		if (wpa_s->wpa_state == WPA_INTERFACE_DISABLED) {
 			wpa_supplicant_update_mac_addr(wpa_s);
 			if (wpa_s->p2p_mgmt) {
@@ -3510,6 +3830,14 @@
 		break;
 	case EVENT_INTERFACE_DISABLED:
 		wpa_dbg(wpa_s, MSG_DEBUG, "Interface was disabled");
+#ifdef SAMSUNG_SRID
+                wpa_s->interface_disabled = 1; 
+#endif
+#ifdef TIZEN
+		/* Flush BSS entries on Interface disabled */
+	        if(os_strcmp(wpa_s->ifname, "wlan0")==0)
+			wpa_bss_flush(wpa_s);			
+#endif /* TIZEN */
 #ifdef CONFIG_P2P
 		if (wpa_s->p2p_group_interface == P2P_GROUP_INTERFACE_GO ||
 		    (wpa_s->current_ssid && wpa_s->current_ssid->p2p_group &&
diff -urN hostap_2_4.orig/wpa_supplicant/.gitignore hostap_2_4/wpa_supplicant/.gitignore
--- hostap_2_4.orig/wpa_supplicant/.gitignore	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-*.service
diff -urN hostap_2_4.orig/wpa_supplicant/main.c hostap_2_4/wpa_supplicant/main.c
--- hostap_2_4.orig/wpa_supplicant/main.c	2015-09-24 15:25:20.349038329 +0800
+++ hostap_2_4/wpa_supplicant/main.c	2015-09-24 15:25:20.373038328 +0800
@@ -16,6 +16,14 @@
 #include "driver_i.h"
 #include "p2p_supplicant.h"
 
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+#include <sys/prctl.h>
+
+#ifndef PR_TASK_PERF_USER_TRACE
+#define PR_TASK_PERF_USER_TRACE 666
+#endif // PR_TASK_PERF_USER_TRACE
+
+#endif // TIZEN_BOOTING_PERFOMANCE_TEST
 
 static void usage(void)
 {
@@ -160,6 +168,12 @@
 	struct wpa_params params;
 	struct wpa_global *global;
 
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+	int ctrl_iface_type = 0;
+	char ctrl_iface_type_name[3][10] = { {""}, {"-wlan0"}, {"-p2p0"} };
+	char buf[100];
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
+
 	if (os_program_init())
 		return -1;
 
@@ -214,6 +228,9 @@
 #endif /* CONFIG_DEBUG_FILE */
 		case 'g':
 			params.ctrl_interface = optarg;
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST			
+			ctrl_iface_type=2;
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
 			break;
 		case 'G':
 			params.ctrl_interface_group = optarg;
@@ -272,6 +289,9 @@
 #ifdef CONFIG_DBUS
 		case 'u':
 			params.dbus_ctrl_interface = 1;
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+			ctrl_iface_type=1;
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST	*/
 			break;
 #endif /* CONFIG_DBUS */
 		case 'v':
@@ -297,6 +317,15 @@
 			goto out;
 		}
 	}
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+
+	snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+	strncat(buf, ctrl_iface_type_name[ctrl_iface_type],  strlen(ctrl_iface_type_name[ctrl_iface_type]));
+	strncat(buf, ": Start", strlen(": Start"));
+
+	prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
 
 	exitcode = 0;
 	global = wpa_supplicant_init(&params);
@@ -307,6 +336,15 @@
 	} else {
 		wpa_printf(MSG_INFO, "Successfully initialized "
 			   "wpa_supplicant");
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+		snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+		strncat(buf, ctrl_iface_type_name[ctrl_iface_type], strlen(ctrl_iface_type_name[ctrl_iface_type]));
+		strncat(buf, ": initialized successful", strlen(": initialized successful"));
+
+		wpa_printf(MSG_INFO, "%s", buf);
+		prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
 	}
 
 	for (i = 0; exitcode == 0 && i < iface_count; i++) {
diff -urN hostap_2_4.orig/wpa_supplicant/Makefile hostap_2_4/wpa_supplicant/Makefile
--- hostap_2_4.orig/wpa_supplicant/Makefile	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/Makefile	2015-09-24 15:25:20.373038328 +0800
@@ -16,6 +16,78 @@
 
 -include .config
 
+# START: Customization for SAMSUNG
+
+ifeq ($(TIZEN), y)
+CFLAGS += -DTIZEN
+CFLAGS += -DTIZEN_PHY_FREQ # IOCTL not using to be removed
+# Required for WPS push button connection + WPS PBC Overlap Functionality
+CFLAGS += -DTIZEN_WPS_PBC
+$(info TIZEN TIZEN_PHY_FREQ TIZEN_WPS_PBC enabled)
+endif
+
+ifeq ($(TIZEN_CONF_FILE), y)
+CFLAGS += -DTIZEN_CONF_FILE
+$(info TIZEN_CONF_FILE enabled)
+endif
+
+ifeq ($(TIZEN_BOOTING_PERFOMANCE_TEST), y)
+CFLAGS += -DTIZEN_BOOTING_PERFOMANCE_TEST
+$(info TIZEN_BOOTING_PERFOMANCE_TEST enabled)
+endif
+
+ifeq ($(TIZEN_P2P_DISCONNECT), y)
+CFLAGS += -DTIZEN_P2P_DISCONNECT
+$(info TIZEN_P2P_DISCONNECT enabled)
+endif
+
+ifeq ($(TIZEN_P2P_LISTEN), y)
+CFLAGS += -DTIZEN_P2P_LISTEN
+$(info TIZEN_P2P_LISTEN enabled)
+endif
+
+ifeq ($(SAMSUNG_P2P_PREKEY), y)
+CFLAGS += -DSAMSUNG_P2P_PREKEY
+$(info SAMSUNG_P2P_PREKEY enabled)
+endif
+
+ifeq ($(P2P_SKIP_DHCP_ADJUST), y)
+CFLAGS += -DSEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+$(info P2P_SKIP_DHCP_ADJUST enabled)
+endif
+
+ifeq ($(P2P_SAMSUNG_GO_INTENT), y)
+CFLAGS += -DSAMSUNG_GO_INTENT_REQUEST
+$(info P2P_SAMSUNG_GO_INTENT enabled)
+endif
+
+ifeq ($(SAMSUNG_DEBUG_FILE), y)
+CFLAGS += -DSAMSUNG_DEBUG_FILE
+$(info SAMSUNG_DEBUG_FILE enabled)
+endif
+
+ifeq ($(SAMSUNG_PREFER_5G), y)
+CFLAGS += -DSAMSUNG_PREFER_5G
+$(info SAMSUNG_PREFER_5G enabled)
+endif
+
+ifeq ($(CONFIG_SAMSUNG_SRID), y)
+CFLAGS += -DSAMSUNG_SRID
+$(info SAMSUNG_SRID enabled)
+endif
+
+ifeq ($(SAMSUNG_P2P_GROUP_ADD), y)
+CFLAGS += -DSAMSUNG_P2P_GROUP_ADD
+$(info SAMSUNG_P2P_GROUP_ADD enabled)
+endif
+
+ifeq ($(CONFIG_WFD_TDLS), y)
+CFLAGS += -DCONFIG_WFD_TDLS
+$(info CONFIG_WFD_TDLS enabled)
+endif
+
+# END: Customization for SAMSUNG
+
 ifdef CONFIG_TESTING_OPTIONS
 CFLAGS += -DCONFIG_TESTING_OPTIONS
 CONFIG_WPS_TESTING=y
@@ -1518,6 +1590,16 @@
 CFLAGS += -DCONFIG_OFFCHANNEL
 endif
 
+######## [Start] SAMSUNG KPI ##########
+ifeq ($(SAMSUNG_KPI), y)
+OBJS += ../src/KPI/supplicantkpi.o
+LDFLAGS += -lpthread
+CFLAGS += $(shell pkg-config --cflags logger) -DSAMSUNG_KPI
+LIBS += $(shell pkg-config --libs logger)
+$(info SAMSUNG_KPI enabled)
+endif
+######## [END] SAMSUNG KPI ##########
+
 ifdef CONFIG_MODULE_TESTS
 CFLAGS += -DCONFIG_MODULE_TESTS
 OBJS += wpas_module_tests.o
diff -urN hostap_2_4.orig/wpa_supplicant/notify.c hostap_2_4/wpa_supplicant/notify.c
--- hostap_2_4.orig/wpa_supplicant/notify.c	2015-09-24 15:25:20.349038329 +0800
+++ hostap_2_4/wpa_supplicant/notify.c	2015-09-24 15:25:20.373038328 +0800
@@ -125,6 +125,12 @@
 	wpas_dbus_signal_prop_changed(wpa_s, WPAS_DBUS_PROP_CURRENT_NETWORK);
 }
 
+#ifdef TIZEN_WPS_PBC
+void wpas_notify_wps_connected(struct wpa_supplicant *wpa_s, u8 *ssid)
+{
+        wpas_dbus_signal_wps_connected(wpa_s, ssid);
+}
+#endif /* TIZEN_WPS_PBC */
 
 void wpas_notify_ap_scan_changed(struct wpa_supplicant *wpa_s)
 {
@@ -206,6 +212,18 @@
 	wpas_dbus_signal_scan_done(wpa_s, success);
 }
 
+#ifdef TIZEN_P2P_LISTEN
+void wpas_notify_stop_listen(struct wpa_supplicant *wpa_s, int scan_triggered)
+{
+        wpas_dbus_signal_stop_listen(wpa_s, scan_triggered);
+}
+ 
+void wpas_notify_resume_listen(struct wpa_supplicant *wpa_s)
+{
+        wpas_dbus_signal_resume_listen(wpa_s);
+}
+#endif /* TIZEN_P2P_LISTEN */
+
 
 void wpas_notify_scan_results(struct wpa_supplicant *wpa_s)
 {
@@ -612,11 +630,19 @@
 					 const u8 *dev_addr, int request,
 					 enum p2p_prov_disc_status status,
 					 u16 config_methods,
-					 unsigned int generated_pin)
+					 unsigned int generated_pin
+#ifdef TIZEN
+					, char *params
+#endif
+						)
 {
 	wpas_dbus_signal_p2p_provision_discovery(wpa_s, dev_addr, request,
 						 status, config_methods,
-						 generated_pin);
+						 generated_pin
+#ifdef TIZEN
+					, params
+#endif
+						);
 }
 
 
@@ -637,6 +663,21 @@
 	wpas_dbus_signal_p2p_wps_failed(wpa_s, fail);
 }
 
+#ifdef TIZEN
+void wpas_notify_p2p_mcc_required(struct wpa_supplicant *wpa_s,
+				  const u8 *p2p_dev_addr, 
+				  int p2p_connect_freq, int go_neg_freq)
+{
+	wpas_dbus_signal_p2p_mcc_required(wpa_s, p2p_dev_addr, 
+					  p2p_connect_freq, go_neg_freq);	
+}
+
+void wpas_notify_connected_ip_address(struct wpa_supplicant *wpa_s, const char *ip_str)
+{
+	wpas_dbus_signal_p2p_connected_ip_address(wpa_s, ip_str);	
+}
+#endif /* TIZEN */
+
 #endif /* CONFIG_P2P */
 
 
@@ -783,3 +824,40 @@
 	}
 #endif /* CONFIG_P2P */
 }
+
+#ifdef CONFIG_WFD_TDLS
+void wpas_notify_tdls_peer(struct wpa_supplicant *wpa_s, const u8 *peer, 
+                size_t ie_len, const char *wfd_ie, const char *sig_name)
+{
+        char *peerMac;
+
+        peerMac = os_zalloc(13);
+        if (!peerMac)
+                return;
+
+        wpa_snprintf_hex(peerMac, 13, (u8 *)(peer), 12);
+
+        wpas_dbus_signal_tdls_peer(wpa_s, peerMac, wfd_ie, sig_name);
+
+        os_free(peerMac);
+}
+
+void wpas_notify_tdls_disconnected(struct wpa_supplicant *wpa_s,
+                                const u8 *peer)
+{
+        char *peerMac;
+
+        peerMac = os_zalloc(13);
+        if (!peerMac)
+                return;
+
+        wpa_snprintf_hex(peerMac, 13, 
+                                 (u8 *)(peer), 12);
+
+        wpas_dbus_signal_tdls_disconnected(wpa_s, peerMac);
+        wpa_msg_global(wpa_s, MSG_INFO, "TDLS-PEER-DISCONNECTED %s",
+                        peerMac);
+
+        os_free(peerMac);
+}
+#endif /* CONFIG_WFD_TDLS */
diff -urN hostap_2_4.orig/wpa_supplicant/notify.h hostap_2_4/wpa_supplicant/notify.h
--- hostap_2_4.orig/wpa_supplicant/notify.h	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/notify.h	2015-09-24 15:25:20.377038328 +0800
@@ -24,6 +24,15 @@
 			       enum wpa_states old_state);
 void wpas_notify_disconnect_reason(struct wpa_supplicant *wpa_s);
 void wpas_notify_network_changed(struct wpa_supplicant *wpa_s);
+
+#ifdef TIZEN_WPS_PBC
+void wpas_notify_wps_connected(struct wpa_supplicant *wpa_s, u8 *ssid);
+#endif /* TIZEN_WPS_PBC */
+#ifdef TIZEN_P2P_LISTEN
+void wpas_notify_stop_listen(struct wpa_supplicant *wpa_s, int scan_triggered);
+void wpas_notify_resume_listen(struct wpa_supplicant *wpa_s);
+#endif /* TIZEN_P2P_LISTEN */
+
 void wpas_notify_ap_scan_changed(struct wpa_supplicant *wpa_s);
 void wpas_notify_bssid_changed(struct wpa_supplicant *wpa_s);
 void wpas_notify_auth_changed(struct wpa_supplicant *wpa_s);
@@ -108,7 +117,11 @@
 					 const u8 *dev_addr, int request,
 					 enum p2p_prov_disc_status status,
 					 u16 config_methods,
-					 unsigned int generated_pin);
+					 unsigned int generated_pin
+#ifdef TIZEN
+					, char *params
+#endif
+					);
 void wpas_notify_p2p_group_started(struct wpa_supplicant *wpa_s,
 				   struct wpa_ssid *ssid, int network_id,
 				   int client);
@@ -119,7 +132,13 @@
 
 void wpas_notify_p2p_wps_failed(struct wpa_supplicant *wpa_s,
 				struct wps_event_fail *fail);
-
+#ifdef TIZEN
+void wpas_notify_p2p_mcc_required(struct wpa_supplicant *wpa_s,
+                                  const u8 *p2p_dev_addr, 
+                                  int p2p_connect_freq, int go_neg_freq);
+void wpas_notify_connected_ip_address(struct wpa_supplicant *wpa_s,
+				      const char *ip_str);
+#endif /* TIZEN */
 void wpas_notify_certification(struct wpa_supplicant *wpa_s, int depth,
 			       const char *subject, const char *altsubject[],
 			       int num_altsubject, const char *cert_hash,
@@ -134,4 +153,11 @@
 void wpas_notify_network_type_changed(struct wpa_supplicant *wpa_s,
 				      struct wpa_ssid *ssid);
 
+#ifdef CONFIG_WFD_TDLS
+void wpas_notify_tdls_peer(struct wpa_supplicant *wpa_s, const u8 *peer, 
+                size_t ie_len, const char *data, const char *sig_name);
+void wpas_notify_tdls_disconnected(struct wpa_supplicant *wpa_s,
+                        const u8 *peer);
+#endif /* CONFIG_WFD_TDLS */
+
 #endif /* NOTIFY_H */
diff -urN hostap_2_4.orig/wpa_supplicant/p2p_supplicant.c hostap_2_4/wpa_supplicant/p2p_supplicant.c
--- hostap_2_4.orig/wpa_supplicant/p2p_supplicant.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/p2p_supplicant.c	2015-09-24 15:25:20.373038328 +0800
@@ -16,6 +16,7 @@
 #include "common/wpa_ctrl.h"
 #include "wps/wps_i.h"
 #include "p2p/p2p.h"
+#include "p2p/p2p_i.h"
 #include "ap/hostapd.h"
 #include "ap/ap_config.h"
 #include "ap/sta_info.h"
@@ -876,6 +877,13 @@
 	 */
 	wpa_s->global->p2p_go_wait_client.sec = 0;
 
+#ifdef SAMSUNG_P2P_PREKEY
+	wpa_s->global->p2p->cfg->isPreKey = SAMSUNG_PREKEY_NONE;
+	os_memset(wpa_s->global->p2p->cfg->pre_Sendpassphrase , 0 , sizeof(wpa_s->global->p2p->cfg->pre_Sendpassphrase));
+	os_memset(wpa_s->global->p2p->cfg->pre_Recvpassphrase , 0 , sizeof(wpa_s->global->p2p->cfg->pre_Recvpassphrase));
+	wpa_s->global->p2p->cfg->disable_skip_wps=wpa_s->conf->disable_skip_wps;
+#endif /* SAMSUNG_P2P_PREKEY */
+
 	if (wpa_s->p2p_group_interface != NOT_P2P_GROUP_INTERFACE) {
 		struct wpa_global *global;
 		char *ifname;
@@ -1242,7 +1250,12 @@
 	if (wpa_s->global->p2p_group_formation)
 		wpa_s = wpa_s->global->p2p_group_formation;
 	if (wpa_s->p2p_go_group_formation_completed) {
+#ifdef SAMSUNG_P2P_PREKEY
+	    if(wpa_s->global->p2p->cfg->disable_skip_wps ||
+		    !(wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT))
+#endif /* SAMSUNG_P2P_PREKEY */
 		wpa_s->global->p2p_group_formation = NULL;
+
 		wpa_s->p2p_in_provisioning = 0;
 	}
 	wpa_s->p2p_in_invitation = 0;
@@ -1724,6 +1737,20 @@
 			   "filtering");
 		return;
 	}
+#ifdef SAMSUNG_P2P_PREKEY
+	if(!wpa_s->global->p2p->cfg->disable_skip_wps
+			&& (wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT)
+			&& os_strlen(wpa_s->global->p2p->cfg->pre_Sendpassphrase) > 0) {
+		wpas_group_formation_completed(wpa_s, 1);
+	}
+        else {
+		if (params->wps_method == WPS_PBC)
+			wpa_supplicant_ap_wps_pbc(wpa_s, params->peer_interface_addr, NULL);
+		else if (wpa_s->p2p_pin[0])
+			wpa_supplicant_ap_wps_pin(wpa_s, params->peer_interface_addr,
+								wpa_s->p2p_pin, NULL, 0, 0);
+	}
+#else
 	if (params->wps_method == WPS_PBC) {
 		wpa_supplicant_ap_wps_pbc(wpa_s, params->peer_interface_addr,
 					  params->peer_device_addr);
@@ -1744,10 +1771,114 @@
 	} else if (wpa_s->p2p_pin[0])
 		wpa_supplicant_ap_wps_pin(wpa_s, params->peer_interface_addr,
 					  wpa_s->p2p_pin, NULL, 0, 0);
+#endif /* SAMSUNG_P2P_PREKEY */
 	os_free(wpa_s->go_params);
 	wpa_s->go_params = NULL;
 }
 
+#ifdef SAMSUNG_P2P_PREKEY
+static void wpas_start_no_wps(struct wpa_supplicant *wpa_s,
+                              struct p2p_go_neg_results *params,
+                              char *passphrase, int join)
+{
+        struct wpa_ssid *ssid;
+
+	/* If Prekey is disabled do not proceed further */
+	if(wpa_s->global->p2p->cfg->disable_skip_wps)
+		return;
+
+        wpa_supplicant_ap_deinit(wpa_s);
+
+        if (wpas_copy_go_neg_results(wpa_s, params) < 0)
+                return;
+
+        ssid = wpa_config_add_network(wpa_s->conf);
+        if (ssid == NULL) {
+                wpa_printf(MSG_ERROR , "SS: ssid is nulll... \r\n");
+                return;
+        }
+
+        wpa_config_set_network_defaults(ssid);
+
+        if(wpa_s->go_params && wpa_s->go_params->ssid_len) {
+                ssid->ssid = os_zalloc(params->ssid_len + 1);
+                if (ssid->ssid) {
+                        os_memcpy(ssid->ssid, params->ssid, params->ssid_len);
+                        ssid->ssid_len = params->ssid_len;
+                }
+        }
+
+        if(ssid->ssid_len <= 0) {
+                if (!is_zero_ether_addr(params->peer_interface_addr)) {
+                        os_memcpy(ssid->bssid, params->peer_interface_addr, ETH_ALEN);
+                        ssid->bssid_set = 1;
+                }
+        }
+
+        ssid->temporary = 1;
+        ssid->p2p_group = 1;
+        ssid->key_mgmt = WPA_KEY_MGMT_PSK;
+        ssid->psk_set = 0;
+
+        ssid->passphrase = os_zalloc(64);
+        if(ssid->passphrase != NULL) {
+                p2p_get_hash_prekey(passphrase , ssid->passphrase , 8);
+        }
+        else {
+                wpa_printf(MSG_ERROR , "SS: passphrase alloc is fail. \r\n");
+                return;
+        }
+
+        wpa_config_update_psk(ssid);
+
+        ssid->disabled = 0;
+
+        if(join && !wpa_s->global->p2p->cfg->invitation_state) {
+                ssid->key_mgmt |= WPA_KEY_MGMT_WPS;
+                wpa_config_set(ssid, "phase1", "\"pbc=skip_pbc\"", 0);
+        }
+        wpa_s->global->p2p->cfg->invitation_state = 0;
+
+        wpa_s->disconnected = 0;
+        wpa_s->reassociate = 1;
+        wpa_s->blacklist_cleared = 0;
+
+        wpa_s->show_group_started = 1;
+
+        wpa_supplicant_req_scan(wpa_s, 0, 0);
+}
+
+
+/**
+ * prekey_group_formation_completed - Clear Provisioning state after association
+ * @wpa_s: Pointer to wpa_supplicant data
+ *
+ * Clear Provisioning after association since Prekey will skip WPS step, so
+ * supplicant should clear provision * state to avoid failing of p2p_find command.
+ * On 20140129
+ */
+void prekey_group_formation_completed(struct wpa_supplicant *wpa_s)
+{
+        if (wpa_s->global->p2p &&
+                wpa_s->p2p_in_provisioning &&
+                !wpa_s->go_params->role_go &&
+                wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT)
+        {
+                //Clear Provisioning
+                wpa_s->global->p2p->go_neg_peer = NULL;
+                p2p_clear_timeout(wpa_s->global->p2p);
+                p2p_set_state(wpa_s->global->p2p, P2P_IDLE);
+
+                //Cancel Group formation timeout
+                eloop_cancel_timeout(wpas_p2p_group_formation_timeout,
+                                wpa_s->parent, NULL);
+                //enable flag for group_completed
+                wpa_s->p2p_go_group_formation_completed = 1;
+                //call group_completed
+                wpas_group_formation_completed(wpa_s, 1);
+        }
+}
+#endif /* SAMSUNG_P2P_PREKEY */
 
 static void wpas_start_wps_go(struct wpa_supplicant *wpa_s,
 			      struct p2p_go_neg_results *params,
@@ -2065,6 +2196,11 @@
 		wpa_msg_global(wpa_s, MSG_INFO,
 			       P2P_EVENT_GO_NEG_FAILURE "status=%d",
 			       res->status);
+#ifdef SAMSUNG_P2P_PREKEY
+		if (wpa_s->global->p2p &&
+		    !wpa_s->global->p2p->cfg->disable_skip_wps)
+			wpa_s->global->p2p->cfg->isPreKey = SAMSUNG_PREKEY_NONE;
+#endif /* SAMSUNG_P2P_PREKEY */
 		wpas_notify_p2p_go_neg_completed(wpa_s, res);
 		wpas_p2p_remove_pending_group_interface(wpa_s);
 		return;
@@ -2083,7 +2219,18 @@
 		       MAC2STR(res->peer_interface_addr),
 		       p2p_wps_method_text(res->wps_method));
 	wpas_notify_p2p_go_neg_completed(wpa_s, res);
+#ifdef TIZEN
+	/* Generate Event in case of Multi-Channel-Concurrency */
+        if(wpa_s->p2p_connect_freq && wpa_s->p2p_connect_freq != res->freq) {
+                wpa_msg(wpa_s, MSG_INFO, "P2P-MCC-REQUIRED bssid="
+                               MACSTR "  p2p_connect_freq=%d  go_neg_freq=%d", 
+                               MAC2STR(res->peer_device_addr),
+                               wpa_s->p2p_connect_freq, res->freq);
 
+		wpas_notify_p2p_mcc_required(wpa_s, res->peer_device_addr,
+			     wpa_s->p2p_connect_freq, res->freq);
+	}
+#endif /* TIZEN */
 	if (res->role_go && wpa_s->p2p_persistent_id >= 0) {
 		struct wpa_ssid *ssid;
 		ssid = wpa_config_get_network(wpa_s->conf,
@@ -2119,16 +2266,36 @@
 
 		if (res->role_go)
 			wpas_start_wps_go(group_wpa_s, res, 1);
-		else
+		else{
+#ifdef SAMSUNG_P2P_PREKEY
+			if(!wpa_s->global->p2p->cfg->disable_skip_wps
+					&& (wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT)
+					&& os_strlen(wpa_s->global->p2p->cfg->pre_Recvpassphrase) > 0)
+				wpas_start_no_wps(group_wpa_s, res, wpa_s->global->p2p->cfg->pre_Recvpassphrase, 0);
+			else
+#endif /* SAMSUNG_P2P_PREKEY */		
 			wpas_start_wps_enrollee(group_wpa_s, res);
+		}
 	} else {
 		wpa_s->p2p_in_provisioning = 1;
 		wpa_s->global->p2p_group_formation = wpa_s;
 
 		if (res->role_go)
 			wpas_start_wps_go(wpa_s, res, 1);
-		else
+		else{
+#ifdef SAMSUNG_P2P_PREKEY
+			/*
+			* Added to support wps-skip, when p2p interface is already available 
+			* [DTV use single interface for p2p i.e. "p2p0"]
+			*/
+			if(!wpa_s->global->p2p->cfg->disable_skip_wps
+					&& (wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT)
+					&& os_strlen(wpa_s->global->p2p->cfg->pre_Recvpassphrase) > 0){
+				wpas_start_no_wps(wpa_s, res, wpa_s->global->p2p->cfg->pre_Recvpassphrase, 0);
+			} else
+#endif /* SAMSUNG_P2P_PREKEY */
 			wpas_start_wps_enrollee(ctx, res);
+		}
 	}
 
 	wpa_s->p2p_long_listen = 0;
@@ -3630,7 +3797,14 @@
 			       const u8 *dev_addr, const u8 *pri_dev_type,
 			       const char *dev_name, u16 supp_config_methods,
 			       u8 dev_capab, u8 group_capab, const u8 *group_id,
-			       size_t group_id_len)
+			       size_t group_id_len
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+                , u32 static_ip
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+                , u8 requested_go_intent, int ON_req_go_intent, struct wpabuf * requested_go_intent_attributes
+#endif
+				)
 {
 	struct wpa_supplicant *wpa_s = ctx;
 	char devtype[WPS_DEV_TYPE_BUFSIZE];
@@ -3657,15 +3831,58 @@
 		os_memset(empty_dev_type, 0, sizeof(empty_dev_type));
 		pri_dev_type = empty_dev_type;
 	}
-	res = os_snprintf(params, sizeof(params), " p2p_dev_addr=" MACSTR
-			  " pri_dev_type=%s name='%s' config_methods=0x%x "
-			  "dev_capab=0x%x group_capab=0x%x%s%s",
-			  MAC2STR(dev_addr),
-			  wps_dev_type_bin2str(pri_dev_type, devtype,
-					       sizeof(devtype)),
-			  dev_name, supp_config_methods, dev_capab, group_capab,
-			  group ? " group=" : "",
-			  group ? group->ifname : "");
+	
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+	if(requested_go_intent_attributes && ON_req_go_intent)
+	{
+#endif
+		res = os_snprintf(params, sizeof(params), " p2p_dev_addr=" MACSTR
+				" pri_dev_type=%s name='%s' config_methods=0x%x "
+				"dev_capab=0x%x group_capab=0x%x%s%s "
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP                                         
+				"static_ip=0x%x " 
+#endif
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+				"Req_GO_Intent=0x%x"
+#endif
+				,
+				MAC2STR(dev_addr),
+				wps_dev_type_bin2str(pri_dev_type, devtype,
+					sizeof(devtype)),
+				dev_name, supp_config_methods, dev_capab, group_capab,
+				group ? " group=" : "",
+				group ? group->ifname : ""
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+				,static_ip
+#endif
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+				,requested_go_intent
+#endif
+				);
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+	}
+	else
+	{
+		res = os_snprintf(params, sizeof(params), " p2p_dev_addr=" MACSTR
+				" pri_dev_type=%s name='%s' config_methods=0x%x "
+				"dev_capab=0x%x group_capab=0x%x%s%s "
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP                                        
+				"static_ip=0x%x " 
+#endif
+				,
+				MAC2STR(dev_addr),
+				wps_dev_type_bin2str(pri_dev_type, devtype,
+					sizeof(devtype)),
+				dev_name, supp_config_methods, dev_capab, group_capab,
+				group ? " group=" : "",
+				group ? group->ifname : ""
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+				,static_ip
+#endif
+			   );
+	}
+#endif
+	
 	if (os_snprintf_error(sizeof(params), res))
 		wpa_printf(MSG_DEBUG, "P2P: PD Request event truncated");
 	params[sizeof(params) - 1] = '\0';
@@ -3682,50 +3899,162 @@
 
 	wpas_notify_p2p_provision_discovery(wpa_s, peer, 1 /* request */,
 					    P2P_PROV_DISC_SUCCESS,
-					    config_methods, generated_pin);
+					    config_methods, generated_pin
+#ifdef TIZEN
+					    , params
+#endif
+					);
 }
 
 
-static void wpas_prov_disc_resp(void *ctx, const u8 *peer, u16 config_methods)
+static void wpas_prov_disc_resp(void *ctx, const u8 *peer, u16 config_methods
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+		, u32 static_ip
+#endif /* SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP */
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+		, u8 requested_go_intent , u8 rgi_confirm, int rgi_type ,struct wpabuf * requested_go_intent_attributes
+#endif
+		)
 {
 	struct wpa_supplicant *wpa_s = ctx;
 	unsigned int generated_pin = 0;
+#if defined(SAMSUNG_GO_INTENT_REQUEST) || defined(SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP)
+	char params[100];
+	int res;
+#else
 	char params[20];
+#endif
 
 	if (wpa_s->pending_pd_before_join &&
-	    (os_memcmp(peer, wpa_s->pending_join_dev_addr, ETH_ALEN) == 0 ||
-	     os_memcmp(peer, wpa_s->pending_join_iface_addr, ETH_ALEN) == 0)) {
+			(os_memcmp(peer, wpa_s->pending_join_dev_addr, ETH_ALEN) == 0 ||
+			 os_memcmp(peer, wpa_s->pending_join_iface_addr, ETH_ALEN) == 0)) {
 		wpa_s->pending_pd_before_join = 0;
 		wpa_printf(MSG_DEBUG, "P2P: Starting pending "
-			   "join-existing-group operation");
+				"join-existing-group operation");
 		wpas_p2p_join_start(wpa_s, 0, NULL, 0);
 		return;
 	}
 
 	if (wpa_s->pending_pd_use == AUTO_PD_JOIN ||
-	    wpa_s->pending_pd_use == AUTO_PD_GO_NEG) {
+			wpa_s->pending_pd_use == AUTO_PD_GO_NEG) {
+#if !defined(SAMSUNG_GO_INTENT_REQUEST) && !defined(SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP)
 		int res;
+#endif
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+		if(requested_go_intent_attributes && rgi_type == RGI_VALUE)
+		{
+#endif
+			res = os_snprintf(params, sizeof(params), " peer_go=%d"
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP                                         
+					" static_ip=0x%x" 
+#endif
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+					" Req_GO_Intent=0x%x"
+#endif
+					,wpa_s->pending_pd_use == AUTO_PD_JOIN
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+					,static_ip
+#endif
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+					,requested_go_intent
+#endif
+					);
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+		}
+		else if(requested_go_intent_attributes && rgi_type == RGI_CONFIRM)
+			res = os_snprintf(params, sizeof(params), " peer_go=%d" 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP                                         
+					" static_ip=0x%x" 
+#endif
+					" RGI_confirm=0x%x" ,wpa_s->pending_pd_use == AUTO_PD_JOIN
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+					,static_ip
+#endif
+					,rgi_confirm);
+		else
+			res = os_snprintf(params, sizeof(params), " peer_go=%d" 
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP                                         
+					" static_ip=0x%x" 
+#endif
+					,wpa_s->pending_pd_use == AUTO_PD_JOIN
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+					,static_ip
+#endif
+					);
+#endif	/* SAMSUNG_GO_INTENT_REQUEST */	
 
-		res = os_snprintf(params, sizeof(params), " peer_go=%d",
-				  wpa_s->pending_pd_use == AUTO_PD_JOIN);
 		if (os_snprintf_error(sizeof(params), res))
 			params[sizeof(params) - 1] = '\0';
-	} else
+	} else {
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+		if(requested_go_intent_attributes && rgi_type == RGI_VALUE){
+			res = os_snprintf(params, sizeof(params),
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP                                         
+					" static_ip=0x%x" 
+#endif
+					" Req_GO_Intent=0x%x"
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+					,static_ip
+#endif
+					,requested_go_intent);
+			if (os_snprintf_error(sizeof(params), res))
+				params[sizeof(params) - 1] = '\0';
+
+		}
+		else if(requested_go_intent_attributes && rgi_type == RGI_CONFIRM){
+			res = os_snprintf(params, sizeof(params),
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP                                         
+					" static_ip=0x%x" 
+#endif
+					" RGI_confirm=0x%x"
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+					,static_ip
+#endif
+					,rgi_confirm);
+			if (os_snprintf_error(sizeof(params), res))
+				params[sizeof(params) - 1] = '\0';
+		}
+		else{
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+			res = os_snprintf(params, sizeof(params),"static_ip=0x%x ",static_ip);
+			if (os_snprintf_error(sizeof(params), res))
+				params[sizeof(params) - 1] = '\0';
+#else
+			params[0] = '\0';
+#endif
+		}
+#else /* SAMSUNG_GO_INTENT_REQUEST */
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+		res = os_snprintf(params, sizeof(params),"static_ip=0x%x ",static_ip);
+		if (os_snprintf_error(sizeof(params), res))
+			params[sizeof(params) - 1] = '\0';
+#else
 		params[0] = '\0';
+#endif
+#endif
+	}
 
 	if (config_methods & WPS_CONFIG_DISPLAY)
 		wpas_prov_disc_local_keypad(wpa_s, peer, params);
 	else if (config_methods & WPS_CONFIG_KEYPAD) {
 		generated_pin = wps_generate_pin();
 		wpas_prov_disc_local_display(wpa_s, peer, params,
-					     generated_pin);
-	} else if (config_methods & WPS_CONFIG_PUSHBUTTON)
-		wpa_msg_global(wpa_s, MSG_INFO, P2P_EVENT_PROV_DISC_PBC_RESP
-			       MACSTR "%s", MAC2STR(peer), params);
-
+				generated_pin);
+	} else if (config_methods & WPS_CONFIG_PUSHBUTTON){
+		wpa_msg_global(wpa_s, MSG_INFO, P2P_EVENT_PROV_DISC_PBC_RESP MACSTR
+				"%s", MAC2STR(peer), params );
+#ifdef SEC_PRODUCT_FEATURE_WLAN_DIRECT_SKIP_DHCP
+		wpa_printf(MSG_INFO, P2P_EVENT_PROV_DISC_PBC_RESP MACSTR_SEC
+				"%s", MAC2STR_SEC(peer), params);
+#endif
+	}
 	wpas_notify_p2p_provision_discovery(wpa_s, peer, 0 /* response */,
-					    P2P_PROV_DISC_SUCCESS,
-					    config_methods, generated_pin);
+			P2P_PROV_DISC_SUCCESS,
+			config_methods, generated_pin
+#ifdef TIZEN
+			, params
+#endif
+			);
 }
 
 
@@ -3772,7 +4101,11 @@
 	}
 
 	wpas_notify_p2p_provision_discovery(wpa_s, peer, 0 /* response */,
-					    status, 0, 0);
+					    status, 0, 0
+#ifdef TIZEN
+					    , NULL
+#endif
+			);
 }
 
 
@@ -3873,11 +4206,21 @@
 
 	grp = wpas_get_p2p_group(wpa_s, ssid, ssid_len, go);
 	if (grp) {
+#ifdef SAMSUNG_SRID
+		/* Fixed group is already running issue */
+                for (s = grp->conf->ssid; s; s = s->next) {
+                        if(os_memcmp(ssid, s->ssid, ssid_len) == 0)
+                                break;
+                }
+                wpa_config_remove_network(grp->conf, s->id);
+                wpa_printf(MSG_DEBUG, "P2P: Removing already invited persistent group from config");
+#else
 		wpa_printf(MSG_DEBUG, "P2P: Accept invitation to already "
 			   "running persistent group");
 		if (*go)
 			os_memcpy(group_bssid, grp->own_addr, ETH_ALEN);
 		goto accept_inv;
+#endif /* SAMSUNG_SRID */
 	}
 
 	if (!is_zero_ether_addr(wpa_s->p2p_auth_invite) &&
@@ -3991,8 +4334,30 @@
 		wpa_printf(MSG_DEBUG, "P2P: Invitation from peer " MACSTR
 			   " was accepted; op_freq=%d MHz, SSID=%s",
 			   MAC2STR(sa), op_freq, wpa_ssid_txt(ssid, ssid_len));
+#ifdef TIZEN
+		/* Custom Event Notification for WFD Manager in TIZEN */
+		wpa_msg(wpa_s, MSG_INFO, "P2P: Invitation from peer " MACSTR
+			" was accepted; op_freq=%d MHz", MAC2STR(sa), op_freq);
+#endif /* TIZEN */		
 		if (s) {
 			int go = s->mode == WPAS_MODE_P2P_GO;
+#ifdef SAMSUNG_SRID
+			/* Single Scan on p2p invitation */
+			if(op_freq) {
+				int *freqs = NULL;
+				freqs = os_malloc(sizeof(int));
+				if(freqs == NULL)
+					return;
+				*freqs = op_freq;
+				os_free(wpa_s->manual_scan_freqs);
+				wpa_s->manual_scan_freqs = freqs;
+				freqs = NULL;
+                                wpa_s->scan_req = MANUAL_SCAN_REQ;
+                                wpa_msg(wpa_s, MSG_INFO, "P2P: [SAMSUNG] Single scan"
+					" on receive p2p invitation from peerInvitation"
+					" from peer " MACSTR, MAC2STR(sa));
+                        }
+#endif /* SAMSUNG_SRID */			
 			wpas_p2p_group_add_persistent(
 				wpa_s, s, go, 0, op_freq, 0, 0, NULL,
 				go ? P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE : 0);
@@ -4963,7 +5328,11 @@
 					P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE :
 					0);
 			} else if (response_done) {
+#ifdef SAMSUNG_P2P_GROUP_ADD
+				wpas_p2p_group_add(wpa_s, 1, 0, 0, 0, NULL, NULL);
+#else
 				wpas_p2p_group_add(wpa_s, 1, 0, 0, 0);
+#endif /* SAMSUNG_P2P_GROUP_ADD */
 			}
 
 			if (passwd_id == DEV_PW_P2PS_DEFAULT) {
@@ -5061,7 +5430,11 @@
 			persistent_go->mode == WPAS_MODE_P2P_GO ?
 			P2P_MAX_INITIAL_CONN_WAIT_GO_REINVOKE : 0);
 	} else {
+#ifdef SAMSUNG_P2P_GROUP_ADD
+		wpas_p2p_group_add(wpa_s, 1, 0, 0, 0, NULL, NULL);
+#else
 		wpas_p2p_group_add(wpa_s, 1, 0, 0, 0);
+#endif /* SAMSUNG_P2P_GROUP_ADD */
 	}
 
 	return 1;
@@ -5221,13 +5594,23 @@
 	p2p.p2p_intra_bss = wpa_s->conf->p2p_intra_bss;
 
 	p2p.max_listen = wpa_s->max_remain_on_chan;
-
+#ifdef SAMSUNG_P2P_PREKEY
+	p2p.isPreKey = SAMSUNG_PREKEY_NONE;
+	os_memset(p2p.pre_Sendpassphrase , 0 , sizeof(p2p.pre_Sendpassphrase));
+	os_memset(p2p.pre_Recvpassphrase , 0 , sizeof(p2p.pre_Recvpassphrase));
+	p2p.passphrase_len = 8;
+	p2p.disable_skip_wps=wpa_s->conf->disable_skip_wps;;
+#else
 	if (wpa_s->conf->p2p_passphrase_len >= 8 &&
 	    wpa_s->conf->p2p_passphrase_len <= 63)
 		p2p.passphrase_len = wpa_s->conf->p2p_passphrase_len;
 	else
 		p2p.passphrase_len = 8;
-
+#endif /* SAMSUNG_P2P_PREKEY */
+#ifdef SAMSUNG_GO_INTENT_REQUEST
+        p2p.enable_req_go_intent = 0;
+        p2p.ON_req_go_intent = 0;
+#endif
 	global->p2p = p2p_init(&p2p);
 	if (global->p2p == NULL)
 		return -1;
@@ -5880,6 +6263,14 @@
 		wpa_s->off_channel_freq = 0;
 		wpa_s->roc_waiting_drv_freq = 0;
 	}
+#ifdef SAMSUNG_P2P_PREKEY
+	if(!wpa_s->global->p2p->cfg->disable_skip_wps
+			&& wpa_s->global && (wpa_s->pending_join_wps_method == WPS_PBC) 
+			&& (wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT)
+			&& os_strlen(wpa_s->global->p2p->cfg->pre_Recvpassphrase) > 0)
+		wpas_start_no_wps(group, &res, wpa_s->global->p2p->cfg->pre_Recvpassphrase , 1);
+        else
+#endif /* SAMSUNG_P2P_PREKEY */
 	wpas_start_wps_enrollee(group, &res);
 
 	/*
@@ -6052,6 +6443,20 @@
 	if (!auth)
 		wpa_s->p2p_long_listen = 0;
 
+#ifdef SAMSUNG_PREFER_5G
+        /*   
+         * Prefer 5 GHz Frequency when user doesn't send
+         * any frequency value while p2p_connect, i.e. freq=0
+         * if user sends freq while p2p_connect, that freq 
+         * will be used for connection.
+         */
+        if(freq == 5 || freq == 0){
+                wpa_s->global->p2p->prefer_5g = 1; 
+                freq = 0; 
+        }else
+                wpa_s->global->p2p->prefer_5g = 0;
+#endif /* SAMSUNG_PREFER_5G */
+
 	wpa_s->p2p_wps_method = wps_method;
 	wpa_s->p2p_persistent_group = !!persistent_group;
 	wpa_s->p2p_persistent_id = persistent_id;
@@ -6268,6 +6673,24 @@
 }
 
 
+#ifdef TIZEN_P2P_LISTEN
+int wpas_check_p2p_listen_stop(struct wpa_supplicant *wpa_s, char* cmd) 
+{
+        extern void wpa_check_p2p_listen_stop(struct wpa_supplicant *wpa_s);
+
+        if(os_strcmp(cmd, "1") == 0) { 
+                if (wpas_p2p_in_progress(wpa_s))
+                        wpa_check_p2p_listen_stop(wpa_s);
+        } else if (os_strcmp(cmd, "0") == 0) { 
+                wpa_check_p2p_listen_stop(wpa_s);
+        } else {
+                return -1;
+        }
+
+        return 0;
+}
+#endif /* TIZEN_P2P_LISTEN */
+
 static int wpas_p2p_select_go_freq(struct wpa_supplicant *wpa_s, int freq)
 {
 	unsigned int r;
@@ -6578,16 +7001,22 @@
  * @freq: Frequency for the group or 0 to indicate no hardcoding
  * @ht40: Start GO with 40 MHz channel width
  * @vht:  Start GO with VHT support
+ * @ssid:  Start GO with user Provided ssid name
+ * @passphrase:  Start GO with user Provided passphrase
  * Returns: 0 on success, -1 on failure
  *
  * This function creates a new P2P group with the local end as the Group Owner,
  * i.e., without using Group Owner Negotiation.
  */
 int wpas_p2p_group_add(struct wpa_supplicant *wpa_s, int persistent_group,
-		       int freq, int ht40, int vht)
+		       int freq, int ht40, int vht
+#ifdef SAMSUNG_P2P_GROUP_ADD 
+		       , char *ssid, char *passphrase
+#endif		       
+		       )
 {
 	struct p2p_go_neg_results params;
-
+	
 	if (wpa_s->global->p2p_disabled || wpa_s->global->p2p == NULL)
 		return -1;
 
@@ -6624,7 +7053,23 @@
 	}
 	p2p_go_params(wpa_s->global->p2p, &params);
 	params.persistent_group = persistent_group;
-
+#ifdef SAMSUNG_P2P_GROUP_ADD
+	/* Overwrite default/generated ssid and passphrse with user inputs */
+        if(ssid){
+		/* Update with user provided ssid */
+		params.ssid_len = os_strlen(ssid);
+		os_memcpy(params.ssid, ssid, os_strlen(ssid));
+        }
+        if(passphrase){
+		/* Update with user provided passphrase */
+		os_memset(params.passphrase, 0, 64);
+		os_memcpy(params.passphrase, passphrase, os_strlen(passphrase));
+#ifdef SAMSUNG_P2P_PREKEY
+		/* Disable prekey feature in case of p2p group add received from command line */
+		wpa_s->global->p2p->cfg->disable_skip_wps=1;
+#endif /* SAMSUNG_P2P_PREKEY */
+        }
+#endif /* SAMSUNG_P2P_GROUP_ADD */
 	wpa_s = wpas_p2p_get_group_iface(wpa_s, 0, 1);
 	if (wpa_s == NULL)
 		return -1;
@@ -6753,6 +7198,10 @@
 		}
 		os_strlcpy(params.passphrase, ssid->passphrase,
 			   sizeof(params.passphrase));
+#ifdef SAMSUNG_P2P_PREKEY
+		/* Disable prekey feature in case of persistent p2p group add received from command line */
+		wpa_s->global->p2p->cfg->disable_skip_wps=1;
+#endif /* SAMSUNG_P2P_PREKEY */
 	}
 	os_memcpy(params.ssid, ssid->ssid, ssid->ssid_len);
 	params.ssid_len = ssid->ssid_len;
@@ -6809,8 +7258,16 @@
 			return;
 		}
 		wpas_p2p_set_group_idle_timeout(wpa_s);
-	} else
+	} else {
+#ifdef SAMSUNG_P2P_PREKEY
+		if(!wpa_s->global->p2p->cfg->disable_skip_wps
+				&& wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT) {
+			wpa_s->global->p2p_group_formation = NULL;
+			eloop_cancel_timeout(wpas_p2p_group_formation_timeout, wpa_s->parent, NULL);
+		}
+#endif /* SAMSUNG_P2P_PREKEY */
 		eloop_cancel_timeout(wpas_p2p_group_idle_timeout, wpa_s, NULL);
+	}
 }
 
 
@@ -7130,7 +7587,11 @@
 		 * least for now, this is mapped to a Listen state for one
 		 * hour.
 		 */
+#ifdef SAMSUNG_SRID
+                timeout = 2147483; 	/* max value for 24 days */
+#else
 		timeout = 3600;
+#endif /* SAMSUNG_SRID */
 	}
 	eloop_cancel_timeout(wpas_p2p_long_listen_timeout, wpa_s, NULL);
 	wpa_s->p2p_long_listen = 0;
@@ -7452,6 +7913,12 @@
 			       ssid->passphrase, go_dev_addr, persistent,
 			       ip_addr);
 
+#ifdef SAMSUNG_P2P_PREKEY
+	if(!wpa_s->global->p2p->cfg->disable_skip_wps
+			&& wpa_s->global->p2p->cfg->isPreKey == SAMSUNG_PREKEY_SUPPORT) {
+		eloop_cancel_timeout(wpas_p2p_group_formation_timeout, wpa_s->parent, NULL);
+	}
+#endif /* SAMSUNG_P2P_PREKEY */
 	if (persistent)
 		network_id = wpas_p2p_store_persistent_group(wpa_s->parent,
 							     ssid, go_dev_addr);
@@ -7693,8 +8160,44 @@
 		unsigned int r;
 		u8 channel_forced;
 
+#ifdef SAMSUNG_SRID
+                if(wpa_s->conf->p2p_listen_channel == 99){
+                         int freq = wpa_drv_shared_freq(wpa_s);
+                         if(freq>0){
+                                if( p2p_freq_to_channel(freq, (u8 *)&wpa_s->conf->p2p_listen_reg_class,
+                                        (u8 *)&wpa_s->conf->p2p_listen_channel) == -1) {
+                                        wpa_msg(wpa_s, MSG_INFO, "Ignore P2P_LISTEN_CHANNEL 99 in DFS channel(%d)", freq);
+                                        wpa_s->conf->p2p_listen_reg_class = -1;
+                                        wpa_s->conf->p2p_listen_channel = -1;
+                                }
+                         }else{
+                                wpa_s->conf->p2p_listen_reg_class = 81;
+                                wpa_s->conf->p2p_listen_channel = 1;
+                         }
+                }
+                /* DFS channel test */
+                if(wpa_s->conf->p2p_listen_channel == 100) {
+	                wpa_s->conf->p2p_listen_reg_class = -1;
+        	        wpa_s->conf->p2p_listen_channel = -1;
+                	wpa_msg(wpa_s, MSG_ERROR, "P2P: DFS test reg %d ch %d", 
+				wpa_s->conf->p2p_listen_reg_class, wpa_s->conf->p2p_listen_channel);
+                }
+#endif /* SAMSUNG_SRID */
 		if (wpa_s->conf->p2p_listen_reg_class &&
 		    wpa_s->conf->p2p_listen_channel) {
+#ifdef SAMSUNG_SRID
+                        /* This is to handle cases when MW sets only listen_channel 
+                         * without changing corresponding listen_reg_class 
+                         */
+                        if(wpa_s->conf->p2p_listen_channel >0 && wpa_s->conf->p2p_listen_channel <= 13)
+                                 wpa_s->conf->p2p_listen_reg_class = 81;
+                        else if(wpa_s->conf->p2p_listen_channel == 14)
+                                 wpa_s->conf->p2p_listen_reg_class = 82;
+                        else if(wpa_s->conf->p2p_listen_channel >= 36 && wpa_s->conf->p2p_listen_channel <= 48)
+                                 wpa_s->conf->p2p_listen_reg_class = 115;
+                        else if(wpa_s->conf->p2p_listen_channel >= 149 && wpa_s->conf->p2p_listen_channel <= 161)
+                                 wpa_s->conf->p2p_listen_reg_class = 124;
+#endif /* SAMSUNG_SRID */
 			reg_class = wpa_s->conf->p2p_listen_reg_class;
 			channel = wpa_s->conf->p2p_listen_channel;
 			channel_forced = 1;
@@ -7722,6 +8225,19 @@
 		unsigned int r;
 		if (wpa_s->conf->p2p_oper_reg_class &&
 		    wpa_s->conf->p2p_oper_channel) {
+#ifdef SAMSUNG_SRID
+                        /* This is to handle cases when MW sets only oper_channel 
+                         * without changing corresponding oper_reg_class 
+                         */
+                        if(wpa_s->conf->p2p_oper_channel <= 13)
+                                 wpa_s->conf->p2p_oper_reg_class = 81;
+                         else if(wpa_s->conf->p2p_oper_channel == 14)
+                                 wpa_s->conf->p2p_oper_reg_class = 82;
+                         else if(wpa_s->conf->p2p_oper_channel >= 36 && wpa_s->conf->p2p_oper_channel <= 48)
+                                 wpa_s->conf->p2p_oper_reg_class = 115;
+                         else if(wpa_s->conf->p2p_oper_channel >= 149 && wpa_s->conf->p2p_oper_channel <= 161)
+                                 wpa_s->conf->p2p_oper_reg_class = 124;
+#endif /* SAMSUNG_SRID */
 			op_reg_class = wpa_s->conf->p2p_oper_reg_class;
 			op_channel = wpa_s->conf->p2p_oper_channel;
 			cfg_op_channel = 1;
diff -urN hostap_2_4.orig/wpa_supplicant/p2p_supplicant.h hostap_2_4/wpa_supplicant/p2p_supplicant.h
--- hostap_2_4.orig/wpa_supplicant/p2p_supplicant.h	2015-09-24 15:25:20.349038329 +0800
+++ hostap_2_4/wpa_supplicant/p2p_supplicant.h	2015-09-24 15:25:20.373038328 +0800
@@ -30,8 +30,13 @@
 		     int pd, int ht40, int vht);
 int wpas_p2p_handle_frequency_conflicts(struct wpa_supplicant *wpa_s,
                                           int freq, struct wpa_ssid *ssid);
+#ifdef SAMSUNG_P2P_GROUP_ADD
+int wpas_p2p_group_add(struct wpa_supplicant *wpa_s, int persistent_group,
+		       int freq, int ht40, int vht, char *ssid, char *passphrase);
+#else
 int wpas_p2p_group_add(struct wpa_supplicant *wpa_s, int persistent_group,
 		       int freq, int ht40, int vht);
+#endif /*SAMSUNG_P2P_GROUP_ADD */
 int wpas_p2p_group_add_persistent(struct wpa_supplicant *wpa_s,
 				  struct wpa_ssid *ssid, int addr_allocated,
 				  int force_freq, int neg_freq, int ht40,
@@ -183,6 +188,10 @@
 			 struct wps_event_fail *fail);
 int wpas_p2p_group_remove(struct wpa_supplicant *wpa_s, const char *ifname);
 
+#ifdef TIZEN_P2P_LISTEN
+int wpas_check_p2p_listen_stop(struct wpa_supplicant *wpa_s, char* cmd);
+#endif /* TIZEN_P2P_LISTEN */
+
 #else /* CONFIG_P2P */
 
 static inline int
@@ -313,4 +322,9 @@
 
 #endif /* CONFIG_P2P */
 
+
+#ifdef SAMSUNG_P2P_PREKEY
+void prekey_group_formation_completed(struct wpa_supplicant *wpa_s);
+#endif /* SAMSUNG_P2P_PREKEY */
+
 #endif /* P2P_SUPPLICANT_H */
diff -urN hostap_2_4.orig/wpa_supplicant/scan.c hostap_2_4/wpa_supplicant/scan.c
--- hostap_2_4.orig/wpa_supplicant/scan.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/scan.c	2015-09-24 15:25:20.373038328 +0800
@@ -24,6 +24,11 @@
 #include "scan.h"
 #include "mesh.h"
 
+#ifdef SAMSUNG_KPI
+#include <sys/msg.h>
+#include "KPI/supplicantkpi.h"
+char gScanResultKpiData[MAX_SKPIDATA_SCAN_RESULT_BUFF_SIZE];
+#endif /* SAMSUNG_KPI */
 
 static void wpa_supplicant_gen_assoc_event(struct wpa_supplicant *wpa_s)
 {
@@ -679,6 +684,12 @@
 		return;
 	}
 
+#if defined(CONFIG_P2P) && defined(TIZEN_P2P_LISTEN)
+	//wpas_notify_stop_listen(wpa_s, 1);
+	extern void wpa_check_p2p_listen_stop(struct wpa_supplicant *wpa_s);
+	wpa_check_p2p_listen_stop(wpa_s);
+#endif /* CONFIG_P2P && TIZEN_P2P_LISTEN */
+
 	ssid = NULL;
 	if (wpa_s->scan_req != MANUAL_SCAN_REQ &&
 	    wpa_s->connect_without_scan) {
@@ -2062,6 +2073,44 @@
 					&scan_res->fetch_time);
 	wpa_bss_update_end(wpa_s, info, new_scan);
 
+#ifdef SAMSUNG_KPI
+        if(!strncmp(wpa_s->ifname, "wlan", 4))
+        {
+                int i;
+                int remainedKPIBufSize = MAX_SKPIDATA_SCAN_RESULT_BUFF_SIZE-4;
+
+                os_snprintf(gScanResultKpiData, strlen("num=0000;slist=")+1, "num=%4d;slist=", scan_res->num);
+                remainedKPIBufSize -= strlen("num=0000;slist=")+1;
+
+                for(i = 0; i < scan_res->num ; i++)
+                {
+                        char tempbuf[100];
+
+                        if(remainedKPIBufSize <= (strlen("|0000@0000")+1))
+                        {
+                                wpa_printf(MSG_ERROR, "[KPI] Scan_result is too big. remainedSize  = %d", remainedKPIBufSize);
+                                break;
+                        }
+
+                        if(i != 0)
+                        {
+                                os_snprintf(tempbuf, strlen("|0000@0000")+1, "|%4d@%4d", scan_res->res[i]->level, scan_res->res[i]->freq);
+                                remainedKPIBufSize -= strlen("|0000@0000")+1;
+                        }
+                        else
+                        {
+                                os_snprintf(tempbuf, strlen("0000@0000")+1, "%4d@%4d", scan_res->res[i]->level, scan_res->res[i]->freq);
+                                remainedKPIBufSize -= strlen("0000@0000")+1;
+                        }
+
+                        strncat(gScanResultKpiData, tempbuf, strlen(tempbuf));
+                }
+
+                strncat(gScanResultKpiData, "\0", strlen("\0"));
+
+        }
+#endif /* SAMSUNG_KPI */
+
 	return scan_res;
 }
 
@@ -2195,6 +2244,9 @@
 			params->mac_addr_mask = mac_addr + ETH_ALEN;
 		}
 	}
+#ifdef SAMSUNG_SRID
+	params->scan_trigger_failed = 0;
+#endif /* SAMSUNG_SRID */	
 	return params;
 
 failed:
diff -urN hostap_2_4.orig/wpa_supplicant/wpa_cli.c hostap_2_4/wpa_supplicant/wpa_cli.c
--- hostap_2_4.orig/wpa_supplicant/wpa_cli.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/wpa_cli.c	2015-09-24 15:25:20.373038328 +0800
@@ -2231,6 +2231,13 @@
 	return wpa_cli_cmd(ctrl, "P2P_EXT_LISTEN", 0, argc, argv);
 }
 
+#ifdef TIZEN_P2P_DISCONNECT
+static int wpa_cli_cmd_p2p_disconnect(struct wpa_ctrl *ctrl, int argc,
+					 char *argv[])
+{
+	return wpa_cli_cmd(ctrl, "P2P_DISCONNECT", 1, argc, argv);
+}
+#endif /* TIZEN_P2P_DISCONNECT */
 
 static int wpa_cli_cmd_p2p_remove_client(struct wpa_ctrl *ctrl, int argc,
 					 char *argv[])
@@ -2284,6 +2291,21 @@
 }
 #endif /* CONFIG_WIFI_DISPLAY */
 
+#ifdef CONFIG_WFD_TDLS
+static int wpa_cli_cmd_wfd_set_tdls_ie(struct wpa_ctrl *ctrl, int argc,
+                                        char *argv[])
+
+{
+        return wpa_cli_cmd(ctrl, "WFD_SET_TDLS_IE", 0, argc, argv);
+}
+static int wpa_cli_cmd_wfd_set_tdls_mode(struct wpa_ctrl *ctrl, int argc,
+                                        char *argv[])
+
+{
+        printf("!!!%s called\n",__FUNCTION__);
+        return wpa_cli_cmd(ctrl, "WFD_SET_TDLS_MODE", 0, argc, argv);
+}
+#endif /* CONFIG_WFD_TDLS */
 
 #ifdef CONFIG_INTERWORKING
 static int wpa_cli_cmd_fetch_anqp(struct wpa_ctrl *ctrl, int argc,
@@ -2988,6 +3010,11 @@
 	{ "p2p_ext_listen", wpa_cli_cmd_p2p_ext_listen, NULL,
 	  cli_cmd_flag_none,
 	  "[<period> <interval>] = set extended listen timing" },
+#ifdef TIZEN_P2P_DISCONNECT
+	{ "p2p_disconnect", wpa_cli_cmd_p2p_disconnect,
+	  wpa_cli_complete_p2p_peer, cli_cmd_flag_none,
+	  "<address|iface=address|peer_addr=address> = remove a peer from all groups" },
+#endif
 	{ "p2p_remove_client", wpa_cli_cmd_p2p_remove_client,
 	  wpa_cli_complete_p2p_peer, cli_cmd_flag_none,
 	  "<address|iface=address> = remove a peer from all groups" },
@@ -2999,6 +3026,14 @@
 	{ "wfd_subelem_get", wpa_cli_cmd_wfd_subelem_get, NULL,
 	  cli_cmd_flag_none,
 	  "<subelem> = get Wi-Fi Display subelement" },
+#ifdef CONFIG_WFD_TDLS
+        { "wfd_set_tdls_ie", wpa_cli_cmd_wfd_set_tdls_ie, NULL,
+          cli_cmd_flag_none,
+        "<subelem> [contents] = set Wi-Fi Display TDLS IE" },
+        { "wfd_set_tdls_mode", wpa_cli_cmd_wfd_set_tdls_mode, NULL,
+          cli_cmd_flag_none,
+        " set Wi-Fi Display TDLS Mode" },
+#endif /* CONFIG_WFD_TDLS */	  
 #endif /* CONFIG_WIFI_DISPLAY */
 #ifdef CONFIG_INTERWORKING
 	{ "fetch_anqp", wpa_cli_cmd_fetch_anqp, NULL, cli_cmd_flag_none,
diff -urN hostap_2_4.orig/wpa_supplicant/wpa_gui-qt4/.gitignore hostap_2_4/wpa_supplicant/wpa_gui-qt4/.gitignore
--- hostap_2_4.orig/wpa_supplicant/wpa_gui-qt4/.gitignore	2015-09-24 15:25:20.349038329 +0800
+++ hostap_2_4/wpa_supplicant/wpa_gui-qt4/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1,4 +0,0 @@
-.moc
-.obj
-.ui
-qrc_icons.cpp
diff -urN hostap_2_4.orig/wpa_supplicant/wpa_gui-qt4/lang/.gitignore hostap_2_4/wpa_supplicant/wpa_gui-qt4/lang/.gitignore
--- hostap_2_4.orig/wpa_supplicant/wpa_gui-qt4/lang/.gitignore	2015-09-24 15:25:20.349038329 +0800
+++ hostap_2_4/wpa_supplicant/wpa_gui-qt4/lang/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-*.qm
diff -urN hostap_2_4.orig/wpa_supplicant/wpa_supplicant.c hostap_2_4/wpa_supplicant/wpa_supplicant.c
--- hostap_2_4.orig/wpa_supplicant/wpa_supplicant.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/wpa_supplicant.c	2015-09-24 15:25:20.373038328 +0800
@@ -55,6 +55,29 @@
 #include "wpas_kay.h"
 #include "mesh.h"
 
+#ifdef SAMSUNG_KPI
+#include "KPI/supplicantkpi.h"
+#include <sys/msg.h>
+#include <pthread.h>
+#ifdef MSG_INFO
+#undef MSG_INFO
+#endif
+#endif /* SAMSUNG_KPI */
+
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+#include <sys/prctl.h>
+
+#ifndef PR_TASK_PERF_USER_TRACE
+#define PR_TASK_PERF_USER_TRACE 666
+#endif // PR_TASK_PERF_USER_TRACE
+
+#endif // TIZEN_BOOTING_PERFOMANCE_TEST
+
+#if defined(CONFIG_P2P) && defined(TIZEN_P2P_LISTEN)
+extern void wpa_check_p2p_listen_resume(struct wpa_supplicant *wpa_s);
+extern void wpa_check_p2p_listen_stop(struct wpa_supplicant *wpa_s);
+#endif /* CONFIG_P2P && TIZEN_P2P_LISTEN */
+
 const char *wpa_supplicant_version =
 "wpa_supplicant v" VERSION_STR "\n"
 "Copyright (c) 2003-2015, Jouni Malinen <j@w1.fi> and contributors";
@@ -722,11 +745,104 @@
 	if (state == WPA_COMPLETED && wpa_s->new_connection) {
 		struct wpa_ssid *ssid = wpa_s->current_ssid;
 #if defined(CONFIG_CTRL_IFACE) || !defined(CONFIG_NO_STDOUT_DEBUG)
+#if defined(CONFIG_P2P) && defined(TIZEN)
+		/*
+         * Connected event with Network Information in 
+         * case of 4 way handshake Static IP [HEX Format]
+         */
+        u8 ip[3 * 4];
+        if(wpa_s->global->p2p && (wpa_sm_get_p2p_ip_addr(wpa_s->wpa, ip) == 0)) {
+	       char ip_str[100];
+               os_snprintf(ip_str, sizeof(ip_str), "client_ip_addr=0x%02x%02x%02x%02x"
+                           " ip_mask=0x%02x%02x%02x%02x go_ip_addr=0x%02x%02x%02x%02x",
+                           ip[0], ip[1], ip[2], ip[3],
+                           ip[4], ip[5], ip[6], ip[7],
+                           ip[8], ip[9], ip[10], ip[11]);
+
+               wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_CONNECTED "- Connection to "
+	 	       MACSTR " completed [id=%d id_str=%s] %s",
+                       MAC2STR(wpa_s->bssid),
+                       ssid ? ssid->id : -1,
+                       ssid && ssid->id_str ? ssid->id_str : "", ip_str);
+
+	       /* Notify on Dbus interface also */
+	       wpas_notify_connected_ip_address(wpa_s, ip_str);
+        }
+        else
+#endif /* TIZEN */
 		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_CONNECTED "- Connection to "
 			MACSTR " completed [id=%d id_str=%s]",
 			MAC2STR(wpa_s->bssid),
 			ssid ? ssid->id : -1,
 			ssid && ssid->id_str ? ssid->id_str : "");
+
+#ifdef SAMSUNG_KPI
+        if(!strncmp(wpa_s->ifname, "wlan", 4))
+        {
+                int msqid;
+                int ret = 0;
+
+                SKpiData kpidata;
+
+                extern errno;
+
+                if((msqid = msgget((key_t)1111, IPC_CREAT|0666))== -1) {
+                        wpa_printf(MSG_ERROR, "[KPI] AP_CONNECTED msgget() fail");
+                }
+                else
+                {
+                        kpidata.type = 1;
+                        kpidata.eventtype = SUPPLICANT_KPI_EVENT_WIFI_ENV;
+
+                        if(KPIGetStatus(wpa_s, kpidata.buff) == 0)
+                        {
+                                extern char gScanResultKpiData[MAX_SKPIDATA_SCAN_RESULT_BUFF_SIZE];
+
+                                strncat(kpidata.buff, gScanResultKpiData, MAX_SKPIDATA_SCAN_RESULT_BUFF_SIZE);
+
+                                ret = msgsnd(msqid, &kpidata, (sizeof(SKpiData)-sizeof(long)), IPC_NOWAIT);
+                                if(ret == -1)
+                                {
+                                        wpa_printf(MSG_ERROR, "[KPI] AP_CONNECTED msgsnd() error: %s", strerror(errno));
+                                }
+                                else
+                                {
+                                        wpa_printf(MSG_DEBUG, "[KPI] AP_CONNECTED msgsnd(%d, %08x, %d, 0)", msqid, (unsigned int)&kpidata, strlen(kpidata.buff));
+                                }
+                        }
+                        else
+                        {
+                                wpa_printf(MSG_ERROR, "[KPI] AP_CONNECTED KPIGetStatus fail");
+                        }
+                }
+        }
+#endif /* SAMSUNG_KPI */
+
+//Tizen: Notify about successful connection via PBC
+#ifdef TIZEN_WPS_PBC
+        if(wpa_s->wps_success) {
+        	ssid->ssid[ssid->ssid_len] = '\0';
+        	wpa_msg(wpa_s, MSG_INFO, "WPS Connected to ssid %s",ssid->ssid);
+        	wpas_notify_wps_connected(wpa_s, ssid->ssid);
+        }
+#endif /* TIZEN_WPS_PBC */
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+        {
+		char buf[100];
+		snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+		strncat(buf, wpa_s->ifname, strlen(wpa_s->ifname));
+		strncat(buf, ": connected", strlen(": connected"));
+
+		prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+	}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
+
+#if defined(CONFIG_P2P) && defined(TIZEN_P2P_LISTEN)
+        //wpas_notify_resume_listen(wpa_s);
+	wpa_check_p2p_listen_resume(wpa_s);
+#endif /* CONFIG_P2P && TIZEN_P2P_LISTEN */
+
 #endif /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
 		wpas_clear_temp_disabled(wpa_s, ssid, 1);
 		wpa_s->extra_blacklist_count = 0;
@@ -810,6 +926,10 @@
 {
 	struct wpa_global *global = signal_ctx;
 	wpa_supplicant_terminate_proc(global);
+#ifdef SAMSUNG_KPI
+        KPI_thread_Stop();
+#endif /* SAMSUNG_KPI */
+
 }
 
 
@@ -1571,6 +1691,10 @@
 	ibss_rsn_deinit(wpa_s->ibss_rsn);
 	wpa_s->ibss_rsn = NULL;
 #endif /* CONFIG_IBSS_RSN */
+#if defined(CONFIG_P2P) && defined(TIZEN_P2P_LISTEN)
+         //wpas_notify_stop_listen(wpa_s, 0);
+	 wpa_check_p2p_listen_stop(wpa_s);
+#endif /* CONFIG_P2P && TIZEN_P2P_LISTEN */
 
 	if (ssid->mode == WPAS_MODE_AP || ssid->mode == WPAS_MODE_P2P_GO ||
 	    ssid->mode == WPAS_MODE_P2P_GROUP_FORMATION) {
@@ -1931,6 +2055,17 @@
 		wpa_msg(wpa_s, MSG_INFO, "Trying to associate with " MACSTR
 			" (SSID='%s' freq=%d MHz)", MAC2STR(bss->bssid),
 			wpa_ssid_txt(bss->ssid, bss->ssid_len), bss->freq);
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+        {
+			char buf[100];
+			snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+			strncat(buf, wpa_s->ifname, strlen(wpa_s->ifname));
+			strncat(buf, ": Trying to associate", strlen(": Trying to associate"));
+
+			prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+        }
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
 		bssid_changed = !is_zero_ether_addr(wpa_s->bssid);
 		os_memset(wpa_s->bssid, 0, ETH_ALEN);
 		os_memcpy(wpa_s->pending_bssid, bss->bssid, ETH_ALEN);
@@ -1962,6 +2097,17 @@
 		wpa_msg(wpa_s, MSG_INFO, "Trying to associate with SSID '%s'",
 			wpa_ssid_txt(ssid->ssid, ssid->ssid_len));
 		os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+        {
+		char buf[100];
+		snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+		strncat(buf, wpa_s->ifname, strlen(wpa_s->ifname));
+		strncat(buf, ": Trying to associate", strlen(": Trying to associate"));
+
+		prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+	}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
 	}
 	wpa_supplicant_cancel_sched_scan(wpa_s);
 	wpa_supplicant_cancel_scan(wpa_s);
@@ -4180,7 +4326,7 @@
 		return -1;
 	}
 
-	if (iface->p2p_mgmt && wpas_p2p_init(wpa_s->global, wpa_s) < 0) {
+	if (iface->p2p_mgmt && strncmp(wpa_s->ifname, "wlan", 4) && wpas_p2p_init(wpa_s->global, wpa_s) < 0) {
 		wpa_msg(wpa_s, MSG_ERROR, "Failed to init P2P");
 		return -1;
 	}
@@ -4219,6 +4365,21 @@
 
 	wpas_rrm_reset(wpa_s);
 
+#ifdef SAMSUNG_KPI
+        if(!strncmp(wpa_s->ifname, "wlan", 4))
+        {
+                pthread_t tid;
+                int err;
+
+                err = pthread_create(&tid, NULL, supplicant_rcv_kpi_msg, NULL);
+                if(err != 0)
+                {
+                        wpa_printf(MSG_ERROR, "[KPI] pthread_create error %d", err);
+                        return -1;
+                }
+        }
+#endif /* SAMSUNG_KPI */
+
 	return 0;
 }
 
@@ -4359,6 +4520,17 @@
 
 	wpa_dbg(wpa_s, MSG_DEBUG, "Added interface %s", wpa_s->ifname);
 	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+        {
+		char buf[100];
+		snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+		strncat(buf, wpa_s->ifname, strlen(wpa_s->ifname));
+		strncat(buf, ": Interface created",  strlen(": Interface created"));
+					
+		prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+	}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
 
 #ifdef CONFIG_P2P
 	if (wpa_s->global->p2p == NULL &&
@@ -4409,6 +4581,17 @@
 
 	wpa_dbg(wpa_s, MSG_DEBUG, "Removing interface %s", wpa_s->ifname);
 
+#ifdef TIZEN_BOOTING_PERFOMANCE_TEST
+        {
+		char buf[100];
+		snprintf(buf, strlen("[wpa_supplicant] ")+1, "[wpa_supplicant] ");
+
+		strncat(buf, wpa_s->ifname, strlen(wpa_s->ifname));
+		strncat(buf, ": Interface Removed", strlen(": Interface Removed"));
+
+		prctl(PR_TASK_PERF_USER_TRACE, buf, strlen(buf));
+		}
+#endif /* TIZEN_BOOTING_PERFOMANCE_TEST */
 #ifdef CONFIG_MESH
 	if (mesh_if_created) {
 		ifname = os_strdup(wpa_s->ifname);
diff -urN hostap_2_4.orig/wpa_supplicant/wpa_supplicant_i.h hostap_2_4/wpa_supplicant/wpa_supplicant_i.h
--- hostap_2_4.orig/wpa_supplicant/wpa_supplicant_i.h	2015-09-24 15:25:20.349038329 +0800
+++ hostap_2_4/wpa_supplicant/wpa_supplicant_i.h	2015-09-24 15:25:20.373038328 +0800
@@ -521,6 +521,10 @@
 	struct wpa_driver_ops *driver;
 	int interface_removed; /* whether the network interface has been
 				* removed */
+#ifdef SAMSUNG_SRID
+        int interface_disabled; /* whether the network interface has been 
+                                 * disbaled */
+#endif
 	struct wpa_sm *wpa;
 	struct eapol_sm *eapol;
 
@@ -753,6 +757,9 @@
 	} p2p_group_interface;
 	struct p2p_group *p2p_group;
 	int p2p_long_listen; /* remaining time in long Listen state in ms */
+#ifdef TIZEN_P2P_LISTEN
+	int p2p_long_listen_pending;
+#endif /* TIZEN_P2P_LISTEN */
 	char p2p_pin[10];
 	int p2p_wps_method;
 	u8 p2p_auth_invite[ETH_ALEN];
@@ -814,6 +821,9 @@
 	unsigned int p2p_peer_oob_pk_hash_known:1;
 	unsigned int p2p_disable_ip_addr_req:1;
 	unsigned int p2ps_join_addr_valid:1;
+#ifdef SAMSUNG_P2P_PREKEY
+	unsigned disable_skip_wps:1;
+#endif
 	int p2p_persistent_go_freq;
 	int p2p_persistent_id;
 	int p2p_go_intent;
diff -urN hostap_2_4.orig/wpa_supplicant/wps_supplicant.c hostap_2_4/wpa_supplicant/wps_supplicant.c
--- hostap_2_4.orig/wpa_supplicant/wps_supplicant.c	2015-09-24 15:25:20.353038328 +0800
+++ hostap_2_4/wpa_supplicant/wps_supplicant.c	2015-09-24 15:25:20.377038328 +0800
@@ -1178,6 +1178,7 @@
 	}
 #ifdef CONFIG_P2P
 	if (p2p_group && wpa_s->go_params && wpa_s->go_params->ssid_len) {
+		os_free(ssid->ssid);	/* Prevent Memory leak fix: now added to opensource */
 		ssid->ssid = os_zalloc(wpa_s->go_params->ssid_len + 1);
 		if (ssid->ssid) {
 			ssid->ssid_len = wpa_s->go_params->ssid_len;
@@ -1702,6 +1703,15 @@
 	if (!eap_is_wps_pbc_enrollee(&ssid->eap))
 		return 0;
 
+#if defined(CONFIG_P2P) && defined(SAMSUNG_SRID)
+	/* Patch to avoid p2p overlap */
+        if(wpa_s->p2p_in_provisioning)
+        {
+                wpa_printf(MSG_ERROR, "[SAMSUNG]WPS: Ignoring PBC Overlap in P2P Provisioning.");
+                return 0;
+        }
+#endif /* CONFIG_P2P && SAMSUNG_SRID */
+
 	wpa_printf(MSG_DEBUG, "WPS: Check whether PBC session overlap is "
 		   "present in scan results; selected BSSID " MACSTR,
 		   MAC2STR(selected->bssid));
