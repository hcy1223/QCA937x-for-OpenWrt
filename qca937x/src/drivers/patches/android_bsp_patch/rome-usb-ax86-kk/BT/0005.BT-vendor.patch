/*
* Copyright (c) 2015 Qualcomm Atheros, Inc.
* All Rights Reserved.
* Qualcomm Atheros Confidential and Proprietary.
* NOT A CONTRIBUTION
*/

diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/Android.mk android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/Android.mk
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/Android.mk	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,28 @@
+LOCAL_PATH:= $(call my-dir)
+
+#If you want to use the legacy way(by using NV) of set the BT address
+#You can set the value to 0
+BT_QSOC_GET_ITEMS_FROM_PERSIST = 1
+
+ifeq ($(BT_QSOC_GET_ITEMS_FROM_PERSIST),1)
+include $(CLEAR_VARS)
+
+LOCAL_C_INCLUDES:= $(LOCAL_PATH)
+
+LOCAL_SRC_FILES:=  bt_nv.cpp
+LOCAL_C_INCLUDES += ../../common/inc
+
+LOCAL_MODULE:= libbtnv
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_OWNER := qcom
+LOCAL_PROPRIETARY_MODULE := true
+
+include $(BUILD_SHARED_LIBRARY)
+
+endif # BT_QSOC_GET_ITEMS_FROM_PERSIST
+
+TEMP_LOCAL_PATH := $(LOCAL_PATH)
+
+ifeq ($(BOARD_HAS_QCA_BT_ROME_USB),true)
+    include $(TEMP_LOCAL_PATH)/rome_usb/Android.mk
+endif
\ No newline at end of file
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/armasm.h android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/armasm.h
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/armasm.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/armasm.h	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,283 @@
+#ifndef ARMASM_H
+#define ARMASM_H
+/*=============================================================================
+
+                        ARM Assembly Language Definitions
+
+GENERAL DESCRIPTION
+  This file contains assembly language macros for use with the ARM assembler.
+
+
+-----------------------------------------------------------------------------
+Copyright (c) 1998 - 2001 Qualcomm Technologies, Inc.
+All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+-----------------------------------------------------------------------------
+=============================================================================*/
+
+
+/*=============================================================================
+
+                            EDIT HISTORY FOR FILE
+
+$Header: //linux/pkgs/proprietary/oncrpc/main/source/inc/armasm.h#3 $
+
+when       who     what, where, why
+--------   ---     ----------------------------------------------------------
+09/13/05   ck      Copied from 6100 branch
+07/12/02   jct     Removed conditional inclusion of customer.h and target.h
+05/17/01   kar     Bigger SVC stack available to support REX from MSM archive
+01/25/01   day     Merged from MSM5105_COMMON.00.00.05.
+                     Added support for Interworking
+                     Added define for system stack size
+04/02/99    sk     Increased Abort stack size.
+04/02/99    ms     Reduced stack sizes.
+02/03/99    ms     Renamed blx to blatox since blx is a keyword in Assembler
+                   of ARM SDK 2.5
+01/18/99    ms     Moved ARM_TRAP_FRAME related declarations to boot_trap.h.
+                   Moved context frame related macros to rexarm.s.
+                   Incorporated exception frame related macros directly into
+                   boot_abort_handler in bootsys.s.
+12/10/98   jkl     Included r12 in the context frame.
+11/23/98   jkl     Clean up code. Changed save_context_from_task macro.
+10/27/98   jkl     Revised for new context
+09/13/98   hcg     Changed exception/trap frame names
+07/10/98   jct     Revised for coding standard, removed unused code
+01/01/98   bwj     Created
+=============================================================================*/
+
+#include "target.h"
+#include "customer.h"
+
+/*  CPSR Control Masks         */
+#define PSR_Thumb_Mask       0x20
+#define PSR_Fiq_Mask         0x40
+#define PSR_Irq_Mask         0x80
+#define PSR_Mode_Mask        0x1f
+
+/*  Processor mode definitions */
+#define PSR_User             0x10
+#define PSR_Fiq              0x11
+#define PSR_Irq              0x12
+#define PSR_Supervisor       0x13
+#define PSR_Abort            0x17
+#define PSR_Undef            0x1b
+#define PSR_System           0x1f
+#define PSR_Thumb            0x20
+
+/*===========================================================================
+**  GENERAL PURPOSE ASSEMBLY MACROS.
+**=========================================================================*/
+
+#if defined(_ARM_ASM_)
+
+        GBLS    current_node_name
+        GBLS    current_node_type
+        GBLA    current_node_aregcount
+        GBLA    current_node_vregcount
+
+/*===========================================================================
+
+Name: pusha, popa
+
+Description: Readable names for push and pop.
+
+MODE: Any
+STATE: ARM
+
+Registers modified: sp
+
+=============================================================================*/
+
+        MACRO
+        pusha   $stack, $reg
+        str     $reg, [$stack, #-4]!
+        MEND
+
+        MACRO
+        popa    $stack, $reg
+        ldr     $reg, [$stack], #4
+        MEND
+
+/*===========================================================================
+
+Name: Entry_Node, Entry_Node_End
+
+Description: Defines an empty function prolog and epilog of a piece of assembly code.
+             These macros take care of the following:
+               - Exporting the entry point label
+               - Creating a stack frame
+               - Software stack checking
+
+Defined Labels:
+   "node_name" - The main thumb mode entry point of the function.
+   "node_name"_end - A label marking the begining of the function epilog.
+
+Arguments:
+  Leaf_Node
+  Node_Name - The function name of the function to be defined.
+  Leaf_Node_End
+  None
+
+MODE: Any
+STATE: ARM
+
+Registers modified: None
+
+=============================================================================*/
+
+        MACRO
+        ENTRY_NODE $node_name
+current_node_name       SETS    "$node_name"
+        EXPORT  $node_name
+        ALIGN
+        ROUT
+$node_name
+        MEND
+                                        ;  The end of an entry node.
+        MACRO
+        ENTRY_NODE_END
+$current_node_name._exit
+current_node_name       SETS    ""
+        MEND
+
+/*===========================================================================
+
+  Name: Leaf_Node, Leaf_Node_End
+
+  Description: Defines the function prolog and epilog of a function that makes
+               no function calls. These macros take care of the following:
+                 - Exporting the entry point label
+                 - Creating 16 and 32 bit entry points.
+                 - Creating a stack frame
+                 - Software stack checking
+
+  Defined Labels:
+     "node_name" - The main thumb mode entry point of the function.
+     "node_name"_32 - The ARM state entry point to the function.
+     "node_name"_end - A label marking the begining of the function epilog.
+
+  Arguments:
+    Leaf_Node
+     Node_Name - The function name of the function to be defined.
+    Leaf_Node_End
+     None
+
+  MODE: Any
+  STATE: ARM and Thumb state entry points. Code runs in ARM state.
+
+  Registers modified: None
+
+=============================================================================*/
+        MACRO
+        LEAF_NODE $node_name
+current_node_type       SETS    "Leaf"
+        CODE16
+        ENTRY_NODE $node_name
+        bx      pc
+        ALIGN
+        CODE32
+#ifndef __APCS_INTERWORK
+        orr     lr, lr, #0x01
+#endif
+        EXPORT  $node_name._32
+$node_name._32
+        MEND
+
+        MACRO
+        LEAF_NODE_END $node_name
+        ASSERT  "$current_node_type" = "Leaf"
+        ENTRY_NODE_END $node_name
+        bx     lr
+current_node_type       SETS    ""
+        MEND
+
+
+/*===========================================================================
+
+  Name: Leaf_Node_End, Leaf_Node_End_16
+
+  Description: Defines the function prolog and epilog of a Thumb mode only function that makes
+               no function calls. These macros take care of the following:
+                 - Exporting the entry point label
+                 - Creating a 16 bit entry point.
+                 - Creating a stack frame
+                 - Software stack checking
+
+  Defined Labels:
+     "node_name" - The main thumb mode entry point of the function.
+     "node_name"_end - A label marking the begining of the function epilog.
+
+  Arguments:
+    Leaf_Node_16
+     Node_Name - The function name of the function to be defined.
+    Leaf_Node_End_16
+     None
+
+  MODE: Any
+  STATE: Thumb
+
+  Registers modified: None
+
+=============================================================================*/
+
+        MACRO
+        LEAF_NODE_16 $node_name
+current_node_type       SETS    "Leaf16"
+        CODE16
+        ENTRY_NODE $node_name
+        MEND
+
+        MACRO
+        LEAF_NODE_END_16 $node_name
+        ASSERT  "$current_node_type" = "Leaf16"
+        ENTRY_NODE_END $node_name
+        bx     lr
+current_node_type       SETS    ""
+        MEND
+
+
+        MACRO
+        ALTERNATE_ENTRY_16 $node_name
+        ASSERT  "$current_node_type" = "Leaf16"
+        EXPORT $node_name
+$node_name
+        MEND
+
+
+/*===========================================================================
+
+  Name: blatox
+
+  Description: Calls a function from ARM state without having to know whether that
+     that function is ARM or Thumb state code.
+
+  Arguments:
+    destreg - The register that contains the address of the function to be called.
+
+  Registers modified: lr
+
+  MODE: Any
+  STATE: ARM. Can call either ARM or Thumb state functions.
+
+=============================================================================*/
+
+        MACRO
+        blatox     $destreg
+        ROUT
+
+        tst     $destreg, #0x01         /* Test for thumb mode call.  */
+
+        ldrne   lr, =%1
+        ldreq   lr, =%2
+        bx      $destreg
+1
+        CODE16
+        bx      pc
+        ALIGN
+        CODE32
+2
+        MEND
+
+#endif   /* ARM_ASM  */
+
+#endif   /* ARMASM_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/bt_nv.cpp android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/bt_nv.cpp
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/bt_nv.cpp	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/bt_nv.cpp	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,464 @@
+/*============================================================================
+  Copyright (c) 2010 - 2012 Qualcomm Technologies, Inc.  All Rights Reserved.
+  Qualcomm Technologies Proprietary and Confidential.
+
+  FILE:         bt_nv.cpp
+
+  OVERVIEW:     This file implements functions to read and write the NV items into
+                the /persistent file system.
+                Through this code you can read and write the following format data.
+                *** data format ***
+                nvID    WriteProtect    Size    Data
+                X       X(1 or 0)       X       X X X X X X
+
+*==============================================================================
+                        EDIT HISTORY FOR MODULE
+
+  This section contains comments describing changes made to the module.
+  Notice that changes are listed in reverse chronological order. Please
+  use ISO format for dates.
+
+when        who  what, where, why
+----------  ---  -----------------------------------------------------------
+2010-02-15   ss  Intial version
+2011-09-28  rrr  Moved the implementation to CPP, for having BD address being
+                 programmed twice if previous BD address was random generated.
+2012-02-16  rrr  Read/Write access to NV config file (i.e. /persist/bt_nv.bin)
+                 is limited to "bluetooth" user only. And making bt_nv.bin as
+                 hidden.
+2012-02-22  rrr  Moved/modified macros to header file for reference across
+                 source files.
+============================================================================*/
+
+
+/*----------------------------------------------------------------------------
+ * Include Files
+ * -------------------------------------------------------------------------*/
+/* Necessary includes */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include "comdef.h"
+#include "bt_nv.h"
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pwd.h>
+#include <grp.h>
+
+/*----------------------------------------------------------------------------
+ * Preprocessor Definitions and Constants
+  * -------------------------------------------------------------------------*/
+#define NV_REF_CLOCK_SIZE     1
+#define NV_REF_CLOCK_T_SIZE   1
+#define NV_CMD_HDR_SIZE       3
+
+#define SIZE_OF_BYTE          sizeof(char)
+#define HC_VS_MAX_CMD_EVENT   260
+#define NVM_PAYLOAD_MAXLENGTH 260
+#define MAX_PAYLOAD_SIZE      NV_BD_ADDR_SIZE
+#ifdef BTNV_DEBUG
+#define BTNV_INFO(args...)    fprintf(stdout, ## args);
+#define BTNV_ERR(args...)     fprintf(stderr, ## args);
+#define BTNV_OS_ERR           fprintf(stderr, "err =%d msg = %s\n", errno, strerror(errno))
+#else
+#define BTNV_INFO(args...)
+#define BTNV_ERR(args...)
+#define BTNV_OS_ERR
+#endif
+
+typedef enum {
+  NV_WRITE_ONCE_ENABLE = 1,
+  NV_WRITE_ONCE_DISABLE = 0
+}nv_persist_write_type;
+
+typedef struct {
+  nv_persist_items_enum_type item;     /* Item to access */
+  nv_persist_write_type writeprotect;
+  uint8 nSize;
+  unsigned char pCmdBuffer[MAX_PAYLOAD_SIZE];    /* Pointer to read or write data */
+} nv_persist_params;
+
+typedef struct _nv_items_tag {
+  nv_persist_items_enum_type type;
+  uint8 size;
+  nv_persist_write_type multi_time_wr;
+}nv_items;
+
+nv_items nvItems[3] =
+{
+  {NV_BD_ADDR_I,                 NV_BD_ADDR_SIZE,     NV_WRITE_ONCE_ENABLE},
+  {NV_BT_SOC_REFCLOCK_TYPE_I,    NV_REF_CLOCK_SIZE,   NV_WRITE_ONCE_DISABLE},
+  {NV_BT_SOC_CLK_SHARING_TYPE_I, NV_REF_CLOCK_T_SIZE, NV_WRITE_ONCE_DISABLE},
+};
+/*==============================================================
+FUNCTION:  bt_nv_init
+==============================================================*/
+/**
+* Intialize the required variables and check the path exists mentioned for writing the binary.
+* TODO: Need to add verification of binary?
+*
+*
+* @return  int - negative number on failure.
+*
+*/
+int bt_nv_init()
+{
+  return 0;
+}
+
+/*==============================================================
+FUNCTION:  bt_nv_deinit
+==============================================================*/
+/**
+* DeIntialize the required variables.
+*
+*
+*
+* @return  int - negative number on failure.
+*
+*/
+int bt_nv_deinit()
+{
+  return 0;
+}
+
+/*==============================================================
+FUNCTION:  bt_nv_write
+==============================================================*/
+/**
+* Write the nparams number of items from nv_params structure to the persist NV file
+* (PERSISTENCE_PATH/BT_NV_FILE_NAME)
+*
+*
+* @return  int - negative number on failure.
+*
+*/
+int bt_nv_write
+(
+  nv_persist_params *params,
+  uint8 nparams
+)
+{
+  int nFd;
+  struct passwd *pwd;
+  struct group  *grp;
+  unsigned char cmd[HC_VS_MAX_CMD_EVENT];
+  int nwrite = 0, i = 0,j = 0;
+  char filename[NAME_MAX];
+
+  snprintf(filename, NAME_MAX, "%s/%s",PERSISTENCE_PATH,BT_NV_FILE_NAME );
+  BTNV_INFO("BT-NV-WRITE: Opening file '%s' for writing\n", filename);
+
+  /* R/W access to user only for the file created below */
+  umask(066);
+
+  /* Open the firmware file*/
+  nFd = open(filename, O_CREAT | O_RDWR, 0666);
+  if(nFd < 0)
+  {
+     BTNV_ERR("BT-NV-WRITE: Failed to Open/create a '%s' file\n",filename);
+     BTNV_OS_ERR;
+     return -1;
+  }
+
+  /* Retrieve user id corresponding to "bluetooth" user */
+  pwd = getpwnam("bluetooth");
+  if (!pwd)
+  {
+      BTNV_ERR("BT-NV-WRITE: user not found in /etc/passwd\n");
+      BTNV_OS_ERR;
+      nwrite = -1;
+      goto out;
+  }
+
+  /* Retrieve group id corresponding to "bluetooth" user */
+  grp = getgrnam("bluetooth");
+  if (!grp)
+  {
+      BTNV_ERR("BT-NV-WRITE: group not found in /etc/group\n");
+      BTNV_OS_ERR;
+      nwrite = -1;
+      goto out;
+  }
+
+  /* Set user and group ownership as "bluetooth"
+   * for firmware file created/opened above
+   */
+  if (fchown(nFd, pwd->pw_uid, grp->gr_gid) < 0)
+  {
+      BTNV_ERR("BT-NV-WRITE: fchown failed \n");
+      BTNV_OS_ERR;
+      nwrite = -1;
+      goto out;
+  }
+
+  for(i = 0; i < nparams; i++)
+  {
+    if((void*)(&params[i]) == NULL)
+    {
+      BTNV_ERR("BT-NV-WRITE: params[%d]) is NULL \n", i);
+      BTNV_OS_ERR;
+      nwrite = -1;
+      goto out;
+    }
+    else
+    {
+      BTNV_INFO("BT-NV-WRITE: params[%d] is valid\n",i);
+    }
+    cmd[0] = (uint8)params[i].item;
+    cmd[1] = (uint8)params[i].writeprotect;
+    cmd[2] = (uint8)params[i].nSize;
+
+    BTNV_INFO("BT-NV-WRITE:****** params[i].writeprotect_0ld = %d new  = %d\n",
+                    (uint8)params[i].writeprotect,(uint8)cmd[1]);
+
+    memcpy(&cmd[NV_CMD_HDR_SIZE], params[i].pCmdBuffer, params[i].nSize);
+
+    if((nwrite = write(nFd, cmd, (NV_CMD_HDR_SIZE+params[i].nSize))) <= 0)
+    {
+      BTNV_ERR("BT-NV-WRITE: Failed to write to binary file\n");
+      BTNV_OS_ERR;
+      nwrite = -1;
+      goto out;
+    }
+    else
+    {
+      BTNV_INFO("BT-NV-WRITE: Written %d data",nwrite);
+      for(j = 0; j < NV_CMD_HDR_SIZE + params[i].nSize;j++)
+        BTNV_INFO("%02x  ",cmd[j]);
+      BTNV_INFO("\n");
+    }
+  }
+out:
+  close(nFd);
+  BTNV_INFO("BT-NV-WRITE: closed file pointer\n");
+  return nwrite;
+}
+/*==============================================================
+FUNCTION:  bt_nv_read
+==============================================================*/
+/**
+* Read the item  from (PERSISTENCE_PATH/BT_NV_FILE_NAME) as
+* mentioned in the  nv_params and return the value through
+* the argument pointer.
+*
+* @return  int - negative number on failure.
+*
+*/
+int bt_nv_read
+(
+ nv_persist_params *params_read
+)
+{
+  int nFd;
+  int nRead = 0;
+  unsigned char payload[NVM_PAYLOAD_MAXLENGTH];
+  unsigned char header[NV_CMD_HDR_SIZE];
+  int nNvItem = 0, i = 0;
+  char filename[NAME_MAX];
+
+  snprintf(filename, NAME_MAX, "%s/%s",PERSISTENCE_PATH,BT_NV_FILE_NAME);
+  BTNV_INFO("BT-NV-READ: Opening file '%s' for reading\n",filename);
+
+  /* Open the firmware file */
+  nFd = open(filename, O_RDONLY);
+  if(nFd < 0)
+  {
+    BTNV_ERR("BT-NV-READ: Open of firmware file failed\n");
+    BTNV_OS_ERR;
+    return -1;
+  }
+
+  nNvItem = 0;
+  while((nRead = read(nFd, header, NV_CMD_HDR_SIZE)) &&
+         (nRead == 0 || nRead == NV_CMD_HDR_SIZE))
+  {
+    /*Third byte gives the length*/
+    params_read[nNvItem].item = (nv_persist_items_enum_type)header[0];
+    params_read[nNvItem].writeprotect = (nv_persist_write_type)header[1];
+    params_read[nNvItem].nSize = header[2];
+
+    BTNV_INFO("BT-NV-READ: Header = %02x %02x %02x\n",params_read[nNvItem].item,
+                  params_read[nNvItem].writeprotect,
+                  params_read[nNvItem].nSize);
+
+    if(read(nFd, payload, params_read[nNvItem].nSize) ==
+            params_read[nNvItem].nSize)
+    {
+      BTNV_INFO("BT-NV-READ: NV item %02x value:",params_read[nNvItem].item);
+      for(i=0; i < params_read[nNvItem].nSize;i++)
+      {
+        params_read[nNvItem].pCmdBuffer[i] = payload[i];
+        BTNV_INFO("%02x  ",params_read[nNvItem].pCmdBuffer[i]);
+      }
+      BTNV_INFO("\n");
+    }
+    else
+    {
+      BTNV_ERR("BT-NV-READ: fread failed !!! \n");
+    }
+    nNvItem++;
+  }
+
+  BTNV_INFO("BT-NV-READ: Total number of item Read = %d\n",nNvItem);
+  close(nFd);
+  return nNvItem;
+}
+
+/*==============================================================
+FUNCTION:  bt_nv_cmd
+==============================================================*/
+/**
+*  This function is to do the read and write the NV item.
+*
+*  @see  nv_persist_func_enum_type -> For Read or Write (nv_persist_func_enum_type)
+*    nv_persist_items_enum_type  -> NV ID number (refer the nv_persist_items_enum_type enum)
+*    nv_persist_item_type    -> Structure which contains the variables to read or write.
+*    bIsRandom -> Used only in case of BD address NV item being written.
+*      bIsRandom = 1 implies that BD address programmed is random generated
+*      bIsRandom = 0 (default) implies it to be user programmed
+*
+*  @return  Returns the nagative value on failure.
+*
+*  @sideeffects Undetermined.
+*/
+int bt_nv_cmd(nv_persist_func_enum_type nvReadWriteFunc,  nv_persist_items_enum_type nvitem,
+                nv_persist_item_type *my_nv_item, int bIsRandom)
+{
+  nv_persist_params params_temp[NV_BT_ITEM_MAX];
+  nv_persist_stat_enum_type status = NV_SUCCESS;
+  int item = -1, check = -1;
+  int i =0,numitems =0;
+
+  if((numitems = bt_nv_read(params_temp)) == -1)
+  {
+    if(nvReadWriteFunc == NV_READ_F)
+    {
+      BTNV_ERR("BT-NV-CMD: Read from NV persist failed\n");
+      BTNV_OS_ERR;
+      return NV_FAILURE;
+    }
+    numitems = 0;
+  }
+
+  BTNV_INFO("BT-NV-CMD: numitems = %d\n",numitems);
+
+  if(nvitem <= NV_BT_ITEM_MIN || nvitem >= NV_BT_ITEM_MAX)
+  {
+    BTNV_ERR("BT-NV-CMD: Invalid NV item %d\n",nvitem);
+    BTNV_OS_ERR;
+    return NV_FAILURE;
+  }
+
+  for(i = 0; i <numitems;i++)
+  {
+    if( nvitem == params_temp[i].item)
+    {
+      item = i;
+      BTNV_INFO("BT-NV-CMD: Found NV item '%d' at '%d'\n",nvitem,item);
+      break;
+    }
+  }
+
+  switch(nvReadWriteFunc)
+  {
+    case NV_READ_F: //read from file
+      BTNV_INFO("BT-NV-CMD: Read Command Execution\n");
+      if(item == -1)
+      {
+        BTNV_ERR("BT-NV-CMD: NV item %d not found\n",nvitem);
+        BTNV_OS_ERR;
+        return NV_FAILURE;
+      }
+      if(nvitem == NV_BD_ADDR_I)
+      {
+        memcpy((*my_nv_item).bd_addr, params_temp[item].pCmdBuffer, NV_BD_ADDR_SIZE );
+        BTNV_INFO("BT-NV-CMD: NV_READ_F: BD Addr: %02x %02x %02x %02x %02x %02x\n",
+            params_temp[item].pCmdBuffer[0],params_temp[item].pCmdBuffer[1],
+            params_temp[item].pCmdBuffer[2],params_temp[item].pCmdBuffer[3],
+            params_temp[item].pCmdBuffer[4],params_temp[item].pCmdBuffer[5]);
+      }
+      else if(nvitem == NV_BT_SOC_REFCLOCK_TYPE_I)
+      {
+        (*my_nv_item).bt_soc_refclock_type = params_temp[item].pCmdBuffer[0];
+        BTNV_INFO("BT-NV-CMD: NV_READ_F: REFCLOCK_TYPE: %02x (0 -> 32MHz, 1-> 19P2MHz)\n",
+                params_temp[item].pCmdBuffer[0]);
+      }
+      else if(nvitem == NV_BT_SOC_CLK_SHARING_TYPE_I)
+      {
+        (*my_nv_item).bt_soc_clk_sharing_type = params_temp[item].pCmdBuffer[0];
+        BTNV_INFO("BT-NV-CMD: NV_READ_F: CLOCK_SHARING_TYPE: %02x (0 -> Disabled, 1-> Enabled)\n",
+              params_temp[item].pCmdBuffer[0]);
+      }
+      break;
+
+    case NV_WRITE_F: //write to file
+      BTNV_INFO("BT-NV-CMD: Write Command Execution\n");
+      if((item != -1) && params_temp[item].writeprotect)
+      {
+        BTNV_INFO("BT-NV-CMD: NV item %d can be written only once\n",params_temp[item].item);
+        status = NV_READONLY;
+      }
+      else
+      {
+        if(item == -1)
+        {
+          BTNV_INFO("BT-NV-CMD: NV item %d not found\n",nvitem);
+          item = numitems;
+          numitems++;
+        }
+        params_temp[item].item = (nv_persist_items_enum_type)nvitem;
+        params_temp[item].writeprotect = nvItems[nvitem - 1].multi_time_wr;
+        params_temp[item].nSize = (uint8)nvItems[nvitem -1].size;
+        if(nvitem == NV_BD_ADDR_I)
+        {
+            /* Overridden. Since in case of BD address it can be either
+               generated or user defined.
+               If random generated then BD address to be persistent across target
+               reboots but can be reprogrammed once by the user.
+               In case of user defined its persistent across target reboots and
+               can't be reprogrammed again by the user. */
+            params_temp[item].writeprotect = (bIsRandom) ? NV_WRITE_ONCE_DISABLE:
+                                                       nvItems[nvitem - 1].multi_time_wr;
+            params_temp[item].pCmdBuffer[0] = my_nv_item->bd_addr[0];
+            params_temp[item].pCmdBuffer[1] = my_nv_item->bd_addr[1];
+            params_temp[item].pCmdBuffer[2] = my_nv_item->bd_addr[2];
+            params_temp[item].pCmdBuffer[3] = my_nv_item->bd_addr[3];
+            params_temp[item].pCmdBuffer[4] = my_nv_item->bd_addr[4];
+            params_temp[item].pCmdBuffer[5] = my_nv_item->bd_addr[5];
+            BTNV_INFO("BT-NV-CMD: NV_WRITE_F: BD Addr: %02x %02x %02x %02x %02x %02x\n",
+                  params_temp[item].pCmdBuffer[0],params_temp[item].pCmdBuffer[1],
+                  params_temp[item].pCmdBuffer[2],params_temp[item].pCmdBuffer[3],
+                  params_temp[item].pCmdBuffer[4],params_temp[item].pCmdBuffer[5]);
+        }
+        else if(nvitem == NV_BT_SOC_REFCLOCK_TYPE_I)
+        {
+          params_temp[item].pCmdBuffer[0] = (*my_nv_item).bt_soc_refclock_type;
+          BTNV_INFO("BT-NV-CMD: NV_WRITE_F: REFCLOCK_TYPE: %02x (0 -> 32MHz, 1-> 19P2MHz)\n",
+                   params_temp[item].pCmdBuffer[0]);
+        }
+        else if(nvitem == NV_BT_SOC_CLK_SHARING_TYPE_I){
+          params_temp[item].pCmdBuffer[0] = (*my_nv_item).bt_soc_clk_sharing_type;
+          BTNV_INFO("BT-NV-CMD: NV_WRITE_F: CLK_SHARING_TYPE: %02x (0 ->Disable, 1->Enable )\n",
+                  params_temp[item].pCmdBuffer[0]);
+        }
+      }
+
+      BTNV_INFO("BT-NV-CMD:  bt_nv_write numitems: %d.... item = %d\n",numitems,item);
+      if(bt_nv_write(params_temp, numitems) == -1)
+      {
+        BTNV_ERR("BT-NV-CMD: Write failed\n");
+        BTNV_OS_ERR;
+        return NV_FAILURE;
+      }
+      break;
+
+    default:
+        status = NV_BADCMD;
+        BTNV_INFO("BT-NV-CMD: Oops default cmd option\n");
+        break;
+  }
+  return status;
+}
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/bt_nv.h android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/bt_nv.h
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/bt_nv.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/bt_nv.h	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,109 @@
+#ifndef BT_NV_H
+#define BT_NV_H
+/*============================================================================
+  Copyright (c) 2011-2012 Qualcomm Technologies, Inc.  All Rights Reserved.
+  Qualcomm Technologies Proprietary and Confidential.
+
+  FILE: bt_nv.h
+
+  OVERVIEW: Public declarations for the NV parser module.
+
+*==============================================================================
+                        EDIT HISTORY FOR MODULE
+
+  This section contains comments describing changes made to the module.
+  Notice that changes are listed in reverse chronological order. Please
+  use ISO format for dates.
+
+when        who  what, where, why
+----------  ---  -----------------------------------------------------------
+2010-02-15   ss  Intial version
+2011-09-28  rrr  Moved the implementation to CPP, for having BD address being
+                 programmed twice if previous BD address was random generated.
+2012-02-22  rrr  Added macro related to persistent file path.
+============================================================================*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <linux/limits.h>
+
+/* To Enable the logging define the BTNV_DEBUG */
+//#define BTNV_DEBUG
+
+#define TRUE 1
+#define FALSE 0
+#define NV_BD_ADDR_SIZE 6
+#define PERSISTENCE_PATH "/persist"
+#define BT_NV_FILE_NAME ".bt_nv.bin"
+
+/* BTS Master Clock Reference Value */
+typedef long int nv_ps_bt_soc_refclock_enum_type;
+#define NV_PS_BT_SOC_REFCLOCK_32MHZ ((nv_ps_bt_soc_refclock_enum_type)0)
+#define NV_PS_BT_SOC_REFCLOCK_19P2MHZ ((nv_ps_bt_soc_refclock_enum_type)1)
+
+/* Provides Information of BTS clk sharing */
+typedef long int nv_ps_bt_soc_clock_sharing_enum_type;
+#define  NV_PS_BT_SOC_CLOCK_SHARING_DISABLED ((nv_ps_bt_soc_clock_sharing_enum_type)0)
+#define  NV_PS_BT_SOC_CLOCK_SHARING_ENABLED ((nv_ps_bt_soc_clock_sharing_enum_type)1)
+
+
+typedef union{
+  /* Provides the BT Address */
+  unsigned char bd_addr[NV_BD_ADDR_SIZE];
+  /* Provides the BTS Master Reference Clock */
+  nv_ps_bt_soc_refclock_enum_type bt_soc_refclock_type;
+  /* Provides Information of BTS Clk sharing  */
+  nv_ps_bt_soc_clock_sharing_enum_type bt_soc_clk_sharing_type;
+} nv_persist_item_type;
+
+typedef enum {
+  NV_BT_ITEM_MIN,
+  NV_BD_ADDR_I,
+  NV_BT_SOC_REFCLOCK_TYPE_I,
+  NV_BT_SOC_CLK_SHARING_TYPE_I,
+  NV_BT_ITEM_MAX
+} nv_persist_items_enum_type;
+
+
+/*  Command codes when command is issued to the NV task.                   */
+typedef enum {
+  NV_READ_F,          /* Read item */
+  NV_WRITE_F          /* Write item */
+} nv_persist_func_enum_type;
+
+/*  Returned status codes for requested operation.                         */
+typedef enum {
+  NV_SUCCESS=0,          /* Request completed okay */
+  NV_FAILURE,          /* Command failed, reason other than NVM was full */
+  NV_BADCMD,        /* Unrecognizable command field */
+  NV_READONLY,      /* Parameter is write-protected and thus read only */
+} nv_persist_stat_enum_type;
+
+
+/*==============================================================
+FUNCTION:  bt_nv_cmd
+==============================================================*/
+/**
+  This function is to do the read and write the NV item.
+
+  @see  nv_persist_func_enum_type -> For Read or Write (nv_persist_func_enum_type)
+    nv_persist_items_enum_type  -> NV ID number (refer the nv_persist_items_enum_type enum)
+    nv_persist_item_type    -> Structure which contains the variables to read or write.
+    bIsRandom -> Used only in case of BD address NV item being written.
+      bIsRandom = 1 implies that BD address programmed is random generated
+      bIsRandom = 0 (default) implies it to be user programmed
+
+  @return  Returns the nagative value on failure.
+
+  @sideeffects Undetermined.
+*/
+int bt_nv_cmd(nv_persist_func_enum_type nvReadWriteFunc,  nv_persist_items_enum_type nvitem,
+                nv_persist_item_type *my_nv_item, int bIsRandom = 0);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/comdef.h android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/comdef.h
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/comdef.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/comdef.h	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,1288 @@
+#ifndef COMDEF_H
+#define COMDEF_H
+/*===========================================================================
+
+                   S T A N D A R D    D E C L A R A T I O N S
+
+DESCRIPTION
+  This header file contains general types and macros that are of use
+  to all modules.  The values or definitions are dependent on the specified
+  target.  T_WINNT specifies Windows NT based targets, otherwise the
+  default is for ARM targets.
+
+       T_WINNT  Software is hosted on an NT platforn, triggers macro and
+                type definitions, unlike definition above which triggers
+                actual OS calls
+
+DEFINED TYPES
+
+       Name      Definition
+       -------   --------------------------------------------------------
+       byte      8  bit unsigned value
+       word      16 bit unsigned value
+       dword     32 bit unsigned value
+
+       uint1     byte
+       uint2     word
+       uint4     dword
+
+       uint8     8  bit unsigned value
+       uint16    16 bit unsigned value
+       uint32    32 bit unsigned value
+       uint64    64 bit unsigned value
+
+       int8      8  bit signed value
+       int16     16 bit signed value
+       int32     32 bit signed value
+       int 64    64 bit signed value
+
+       sint31    32 bit signed value
+       sint15    16 bit signed value
+       sint7     8  bit signed value
+
+       int1      8  bit signed value
+       int2      16 bit signed value
+       int4      32 bit signed value
+
+       boolean   8 bit boolean value
+
+DEFINED CONSTANTS
+
+       Name      Definition
+       -------   --------------------------------------------------------
+       TRUE      Asserted boolean condition (Logical 1)
+       FALSE     Deasserted boolean condition (Logical 0)
+
+       ON        Asserted condition
+       OFF       Deasserted condition
+
+       NULL      Pointer to nothing
+
+       PACKED    Used to indicate structures which should use packed
+                 alignment
+
+       INLINE    Used to inline functions for compilers which support this
+
+  -----------------------------------------------------------------------------
+  Copyright (c) 1990, 1992-1994, 1997-2007 Qualcomm Technologies, Inc.
+  All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+  -----------------------------------------------------------------------------
+===========================================================================*/
+
+
+/*===========================================================================
+
+                      EDIT HISTORY FOR FILE
+
+This section contains comments describing changes made to this file.
+Notice that changes are listed in reverse chronological order.
+
+$Header: //linux/pkgs/proprietary/oncrpc/main/source/inc/comdef.h#4 $
+
+when       who     what, where, why
+--------   ---     ----------------------------------------------------------
+01/09/06   bfc     Added Pthe OST_ALIGN macro.
+09/22/06    th     Added FIQLOCK_SAV/FIQFREE_SAV macros for Windows Mobile
+05/10/06   taw     Added FIQLOCK_SAV/FIQFREE_SAV macros.
+01/25/06   sam     Added MSM_INTLOCK/MSM_INTFREE macros.
+07/13/05   adm     Merged in changes related to supporting BootLoader compilation
+                   for L4 builds
+07/06/05   ptm     Merge to 6550 for L4.
+06/30/05   adm     Merging in 6800's later changes and made some fixes.
+06/29/05   adm     Merged in 6800 l4 related changes
+02/28/04   jcw     Removed TASKLOCK/TASKFREE definition to INTLOCK/INTFREE for L4.
+02/14/04   hcg     Add TASKLOCK/TASKFREE definition to INTLOCK/INTFREE for L4.
+08/25/04   jac     suppress lint error 413 for FPOS macro
+11/19/03    gr     Added multiple definition protection for the ARR_SIZE
+                   macro.
+10/18/03    gr     Moved TASKLOCK/TASKFREE into this file from rex.h. DMSS
+                   expects to pick these up just by including comdef.h.
+10/17/03    gr     Made inclusion of target.h unconditional (TG is now
+                   deprecated).
+10/16/03    gr     Defined LOCAL away unconditionally. DMSS doesn't build with
+                   LOCAL set to static.
+01/07/04   ajn     Re-integrated 11/14/03 change
+11/20/03   ak      ARR_SIZE conflict with BREW files fixed
+11/14/03   ajn     Removed #include "rex.h" to avoid circular include issue.
+                   Instead, prototypes for rex_int_lock()/rex_int_free()
+                   have been explicitly included for INTLOCK/INTFREE macros.
+06/11/01    gr     Added MOD_BY_POWER_OF_TWO macro.
+04/12/01    sq     Added inpdw and outpdw macros
+           vas     Added solaris support
+04/06/01    gr     Removed the definitions of abs and labs.
+01/25/01   day     Merged from MSM5105_COMMON.00.00.05.
+             Added include for stdlib.h within WINNT ifdef
+       Added support for ARM_ASM
+       Added support SWIG preprocessor.
+09/09/99   tac     Merged in a bunch of panther changes.
+08/11/99   jct     Corrected conditional compilation around labs to check for
+                   labs instead of abs
+06/30/99   jct     Added PC_EMULATOR capability for INTLOCK and INTLOCKSAV
+06/15/99   jct     Cleanup to make work in Windows NT environment.  Addition
+                   of int(n) types where n is 8,16,32,64 and addition of
+                   unit64.  Removal of OS comments and defines as this is replaced
+                   by T_WINNT.  Conditional inclusion of MAX, MIN, labs, abs,
+                   NULL definitions.  Removal of volatile from packed definition
+                   stdlib.h included for Win32 based targets since this replaces several
+                   of the define here.  Changed out uts calls to be comet calls.
+                   Added a defines for Windows NT targets to define away symbols
+                   no longer supported
+04/09/99    ms     Lint cleanup.
+04/01/99    ms     Lint cleanup.
+02/17/99    ms     Parenthesized abs and labs.
+                   Defined __packed to volatile to exploit lint.
+12/16/98   jct     Removed 80186 support
+12/01/98    ms     Removed definition of bsp_io_base.
+11/20/98    ms     Typecast to volatile pointers in inp,outp,inpw and outpw.
+10/10/98   jct     Honing of OS and T_ definitions, added T_WINNT as a target
+                   which triggers something different then which OS since
+                   we may be running REX on an NT platform, but strictly
+                   speaking, the application software is using REX, not NT
+                   as the OS.  Changed ROM for WINNT/ARM targets to be nothing
+                   instead of const
+09/09/98   jct     Updates to merge ARM support with 186 support, added some
+                   new type aliases, added some segmented architecture macros,
+                   updated comments, removed unused code, updated declaration
+                   of inp/outp to have cdecl
+08/01/98   jct     Updates to support ARM processor
+03/25/96   jah     Moved SET_VECT to 80186.h
+02/06/96   fkm     Put ()s around Macros to Make Lint Happy
+01/12/95   jah     Updated dependency in MACRO INTLOCK_SAV / INTFREE_SAV.
+12/20/94   jah     Corrected typo in ARR_SIZE() macro comments
+03/11/94   jah     Added #ifdef _lint of NULL as 0 for near/far lint problem.
+06/11/93   jah     Changed FPOS() to cast the pointer to 'near' to avoid the
+                   compiler complaints about lost segments.
+01/28/93   twp     Added ARR_SIZE macro to return number of array elements.
+07/17/92   jah     Changed int1 from 'char' to 'signed char'
+06/10/92   jah     Added WORD_LO/HI, INC_SAT
+05/19/92   jah     Added header comments for macros & made them lint-friendly
+05/04/92   jah     Added define for ROM
+03/02/92   jah     Added in/outp prototypes, INT* Macro comments w/lint
+02/20/92   arh     Added LOCAL macro and ifdef/endif around file
+
+===========================================================================*/
+
+
+/*===========================================================================
+
+                            Data Declarations
+
+===========================================================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "target.h"
+#include "armasm.h"
+
+#if defined FEATURE_L4  && !defined FEATURE_L4_KERNEL && \
+    !defined BUILD_BOOT_CHAIN && !defined BUILD_BOOT_CHAIN_OEMSBL
+  #ifndef _ARM_ASM_
+    #ifdef FEATURE_QUARTZ_135
+      #include <l4/cust/msm_syscall.h>
+    #else /* FEATURE_QUARTZ_135 */
+     #include <msm/msm_syscall.h>
+    #endif /* FEATURE_QUARTZ_135 */
+  #endif /* _ARM_ASM_ */
+#endif /* FEATURE_L4 && !FEATURE_L4_KERNEL &&
+          !FEATURE_L4_KERNEL && !BUILD_BOOT_CHAIN_OEMSBL */
+
+/* For NT apps we want to use the Win32 definitions and/or those
+** supplied by the Win32 compiler for things like NULL, MAX, MIN
+** abs, labs, etc.
+*/
+#ifdef T_WINNT
+   #ifndef WIN32
+      #define WIN32
+   #endif
+   #include <stdlib.h>
+#endif
+
+/* ------------------------------------------------------------------------
+** Constants
+** ------------------------------------------------------------------------ */
+
+#ifdef TRUE
+#undef TRUE
+#endif
+
+#ifdef FALSE
+#undef FALSE
+#endif
+
+#define TRUE   1   /* Boolean true value. */
+#define FALSE  0   /* Boolean false value. */
+
+#define  ON   1    /* On value. */
+#define  OFF  0    /* Off value. */
+
+#ifdef _lint
+  #define NULL 0
+#endif
+
+#ifndef NULL
+  #define NULL  0
+#endif
+
+/* -----------------------------------------------------------------------
+** Standard Types
+** ----------------------------------------------------------------------- */
+
+/* The following definitions are the same accross platforms.  This first
+** group are the sanctioned types.
+*/
+#ifndef _ARM_ASM_
+typedef  unsigned char      boolean;     /* Boolean value type. */
+
+typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
+typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
+typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
+
+typedef  signed long int    int32;       /* Signed 32 bit value */
+typedef  signed short       int16;       /* Signed 16 bit value */
+typedef  signed char        int8;        /* Signed 8  bit value */
+
+/* This group are the deprecated types.  Their use should be
+** discontinued and new code should use the types above
+*/
+typedef  unsigned char     byte;         /* Unsigned 8  bit value type. */
+typedef  unsigned short    word;         /* Unsinged 16 bit value type. */
+typedef  unsigned long     dword;        /* Unsigned 32 bit value type. */
+
+typedef  unsigned char     uint1;        /* Unsigned 8  bit value type. */
+typedef  unsigned short    uint2;        /* Unsigned 16 bit value type. */
+typedef  unsigned long     uint4;        /* Unsigned 32 bit value type. */
+
+typedef  signed char       int1;         /* Signed 8  bit value type. */
+typedef  signed short      int2;         /* Signed 16 bit value type. */
+typedef  long int          int4;         /* Signed 32 bit value type. */
+
+typedef  signed long       sint31;       /* Signed 32 bit value */
+typedef  signed short      sint15;       /* Signed 16 bit value */
+typedef  signed char       sint7;        /* Signed 8  bit value */
+
+#ifdef FEATURE_WINCE
+  #define WCE_MSG  RETAILMSG
+  #define WCE_MSG6 RETAILMSG
+  #define WCE_MSGT RETAILMSG
+  #define WCE_MSG_SDBG RETAILMSG
+#endif
+/************************** The PACK() macro *****************************
+  This block sets up the semantics for PACK() macro based upon
+  upon the target compiler. PACK() is necessary to ensure portability of C
+  variable/struct/union packing across many platforms.  For example, ARM
+  compilers require the following:
+    typedef __packed struct { ... } foo_t;
+
+  But GCC requires this to achieve the same effect:
+    typedef struct __attribute((__packed__)) struct { ... } foo_t;
+
+  And, of course, Microsoft VC++ requires an alignment #pragma prologue and
+  epilogue. To satisfy all three, the following form is recommended:
+
+    #ifdef _WIN32
+		#pragma pack(push,1) // Save previous, and turn on 1 byte alignment
+    #endif
+
+    typedef PACK(struct)
+    {
+      ...
+    } such_and_such_t;
+
+    typedef PACK(struct)
+    {
+      ...
+    } this_and_that_t;
+
+    typedef PACK(struct)
+    {
+      PACK(struct)
+      {
+        ...
+      } hdr;
+      PACK(union)
+      {
+        such_and_such_t sas;
+        this_and_that_t tat;
+      } payload;
+    } cmd_t;
+
+*********************** BEGIN PACK() Definition ***************************/
+#if defined __GNUC__
+  #define PACK(x)       x __attribute__((__packed__))
+#elif defined __arm
+  #define PACK(x)       __packed x
+#else
+  #error No PACK() macro defined for this compiler
+#endif
+/********************** END PACK() Definition *****************************/
+/* ---------------------------------------------------------------------
+** Compiler Keyword Macros
+** --------------------------------------------------------------------- */
+#if (! defined T_WINNT) && (! defined TARGET_OS_SOLARIS)
+#ifndef SWIG  /* The SWIG preprocessor gets confused by these */
+  /* Non WinNT Targets
+  */
+  typedef  signed long long   int64;       /* Signed 64 bit value */
+  typedef  unsigned long long uint64;      /* Unsigned 64 bit value */
+
+#if defined(__ARMCC_VERSION) 
+  #define PACKED __packed
+  #define PACKED_POST
+  #define ALIGN(__value) __align(__value)
+  #define POST_ALIGN(__value)
+  #define INLINE __inline
+  #define inline __inline
+#else  /* __GNUC__ */
+  #define PACKED 
+  #ifndef FEATURE_WINCE
+    #define ALIGN(__value) __attribute__((__aligned__(__value)))
+    #define POST_ALIGN(__value)
+    #define PACKED_POST    __attribute__((__packed__))
+  #else /* FEATURE_WINCE */
+    #ifdef WINCE_TODO
+      /*----------------------------------------------------------------------
+        Should we be using something closer to the T_WINNT case below?
+      ----------------------------------------------------------------------*/
+    #endif /* WINCE_TODO */
+    #define ALIGN(__value)
+    #define POST_ALIGN(__value)
+    #define PACKED_POST
+    #define INLINE 
+  #endif /* FEATURE_WINCE */
+    
+
+  #ifndef INLINE
+    #define INLINE inline
+  #endif
+#endif /* defined (__GNUC__) */
+
+  #define CDECL
+#endif /* SWIG */
+  #define far
+  #define near
+  #define _far
+  #define _near
+//  #define _cdecl
+  #define cdecl
+  #define _pascal
+  #define _interrupt
+
+#else /* T_WINNT || TARGET_OS_SOLARIS */
+
+  /* WINNT or SOLARIS based targets
+  */
+#if (defined __GNUC__) || (defined TARGET_OS_SOLARIS)
+  typedef long long           int64;
+  typedef unsigned long long  uint64;
+#else
+  typedef  __int64            int64;       /* Signed 64 bit value */
+  typedef  unsigned __int64   uint64;      /* Unsigned 64 bit value */
+#endif
+  #define PACKED
+  #define PACKED_POST
+  #define ALIGN(__value)
+  #define POST_ALIGN(__value)
+  #ifndef INLINE
+
+  /* INLINE is defined to __inline because WINNT targets work fine with it
+   * and defining it to nothing does not work because the inline function
+   * definition is then multiply defined.  Solaris may need a different value.
+   */
+  #define INLINE __inline
+  #endif
+  #ifndef CDECL
+     #define CDECL __cdecl
+  #endif
+  #define _pascal
+  #define _far
+  #define far
+  #define near
+  #define _near
+  #define cdecl
+  #define _cdecl
+  #define _interrupt
+  #define __packed
+  #define _fmemcpy memcpy
+
+#endif /* T_WINNT */
+#endif // #ifndef _ARM_ASM_
+
+/* ----------------------------------------------------------------------
+** Lint does not understand __packed, so we define it away here.  In the
+** past we did this:
+**   This helps us catch non-packed pointers accessing packed structures,
+**   for example, (although lint thinks it is catching non-volatile pointers
+**   accessing volatile structures).
+**   This does assume that volatile is not being used with __packed anywhere
+**   because that would make Lint see volatile volatile (grrr).
+** but found it to be more trouble than it was worth as it would emit bogus
+** errors
+** ---------------------------------------------------------------------- */
+#ifdef _lint
+  #define __packed
+#endif
+
+/* ----------------------------------------------------------------------
+**                          STANDARD MACROS
+** ---------------------------------------------------------------------- */
+
+#ifndef SWIG /* these confuse the SWIG preprocessor and aren't needed for it */
+
+
+/*===========================================================================
+
+MACRO MEM_B
+MACRO MEM_W
+
+DESCRIPTION
+  Take an address and dereference it as a byte/word, allowing access to an
+  arbitrary memory byte/word.
+
+PARAMETERS
+  x     address to be dereferenced
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  MEM_B byte at the given address
+  MEM_W word at the given address
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  MEM_B( x )  ( *( (byte *) (x) ) )
+#define  MEM_W( x )  ( *( (word *) (x) ) )
+
+
+
+/*===========================================================================
+
+MACRO MAX
+MACRO MIN
+
+DESCRIPTION
+  Evaluate the maximum/minimum of 2 specified arguments.
+
+PARAMETERS
+  x     parameter to compare to 'y'
+  y     parameter to compare to 'x'
+
+DEPENDENCIES
+  'x' and 'y' are referenced multiple times, and should remain the same
+  value each time they are evaluated.
+
+RETURN VALUE
+  MAX   greater of 'x' and 'y'
+  MIN   lesser of 'x' and 'y'
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+#ifndef MAX
+   #define  MAX( x, y ) ( ((x) > (y)) ? (x) : (y) )
+#endif
+
+#ifndef MIN
+   #define  MIN( x, y ) ( ((x) < (y)) ? (x) : (y) )
+#endif
+
+
+
+/*===========================================================================
+
+MACRO FPOS
+
+DESCRIPTION
+  This macro computes the offset, in bytes, of a specified field
+  of a specified structure or union type.
+
+PARAMETERS
+  type          type of the structure or union
+  field         field in the structure or union to get the offset of
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  The byte offset of the 'field' in the structure or union of type 'type'.
+
+SIDE EFFECTS
+  The lint error "Warning 545: Suspicious use of &" is suppressed within
+  this macro.  This is due to the desire to have lint not complain when
+  'field' is an array.
+
+===========================================================================*/
+
+#define FPOS( type, field ) \
+    /*lint -e545 */ ( (dword) &(( type *) 0)-> field ) /*lint +e545 */
+
+
+
+/*===========================================================================
+
+MACRO FSIZ
+
+DESCRIPTION
+  This macro computes the size, in bytes, of a specified field
+  of a specified structure or union type.
+
+PARAMETERS
+  type          type of the structure or union
+  field         field in the structure or union to get the size of
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  size in bytes of the 'field' in a structure or union of type 'type'
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define FSIZ( type, field ) sizeof( ((type *) 0)->field )
+
+
+
+/*===========================================================================
+
+MACRO FLIPW
+
+DESCRIPTION
+  Takes a 2 byte array, with the most significant byte first, followed
+  by the least significant byte, and converts the quantity into a word
+  with Intel byte order (LSB first)
+
+PARAMETERS
+  ray   array of 2 bytes to be converted to a word
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  word in Intel byte order comprised of the 2 bytes of ray.
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )
+
+
+
+/*===========================================================================
+
+MACRO FLOPW
+
+DESCRIPTION
+  Reverses bytes of word value and writes them to a 2 byte array.
+  Effectively the reverse of the FLIPW macro.
+
+PARAMETERS
+  ray   array to receive the 2 bytes from 'val'
+  val   word to break into 2 bytes and put into 'ray'
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+#define  FLOPW( ray, val ) \
+  (ray)[0] = ((val) / 256); \
+  (ray)[1] = ((val) & 0xFF)
+
+
+
+/*===========================================================================
+
+MACRO B_PTR
+MACRO W_PTR
+
+DESCRIPTION
+  Casts the address of a specified variable as a pointer to byte/word,
+  allowing byte/word-wise access, e.g.
+  W_PTR ( xyz )[ 2 ] = 0x1234;  -or-    B_PTR ( xyz )[ 2 ] = 0xFF;
+
+PARAMETERS
+  var   the datum to get a word pointer to
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  Word pointer to var
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  B_PTR( var )  ( (byte *) (void *) &(var) )
+#define  W_PTR( var )  ( (word *) (void *) &(var) )
+#define  D_PTR( var )  ( (dword *) (void *) &(var) )
+
+
+/*===========================================================================
+
+MACRO WORD_LO
+MACRO WORD_HI
+
+DESCRIPTION
+  Take a word and extract the least-significant or most-significant byte.
+
+PARAMETERS
+  xxx   word to extract the Low/High from
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  WORD_LO       Least significant byte of xxx.
+  WORD_HI       Most significant byte of xxx.
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  WORD_LO(xxx)  ((byte) ((word)(xxx) & 255))
+#define  WORD_HI(xxx) \
+  /*lint -e572 */  ((byte) ((word)(xxx) >> 8))  /*lint +e572 */
+
+
+/*===========================================================================
+
+MACRO RND8
+
+DESCRIPTION
+  RND8 rounds a number up to the nearest multiple of 8.
+
+PARAMETERS
+  x     Number to be rounded up
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  x rounded up to the nearest multiple of 8.
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define RND8( x )       ((((x) + 7) / 8 ) * 8 )
+
+/* -----------------------------------------------------------------------
+** Temporary inclusion of rex.h because there is code in AMSS that expects
+** to pick up Rex definitions by just including comdef.h.
+** ----------------------------------------------------------------------- */
+//#include "rex.h"
+
+/*===========================================================================
+
+MACRO INTLOCK / INTFREE
+
+DESCRIPTION
+  INTLOCK Saves current interrupt state on stack then informs the kernel
+  not to process interrupts in this thread. One interrupt may still occur, 
+  but it will not be processed until either INTFREE is called or a context 
+  switch to another thread which has interrupts enabled is made.
+
+  INTFREE Restores previous interrupt state from stack. Used in conjunction
+  with INTLOCK.
+
+  INTLOCK/INTFREE may be nested, in which case inner INTLOCK/INTFREE
+  pairs will have no effect.
+
+PARAMETERS
+  None
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  INTLOCK stops interrupt processing.
+  INTFREE restores the interrupt mask saved previously.
+
+===========================================================================*/
+#if defined PC_EMULATOR_H && !defined T_REXNT
+
+   #define PC_EMULATOR_INTLOCK
+   #include PC_EMULATOR_H
+   #undef PC_EMULATOR_INTLOCK
+
+#elif defined T_WINNT || defined FEATURE_ANDROID
+
+   #define INTLOCK()
+   #define INTFREE()
+
+#elif defined FEATURE_WINCE_OAL
+  #define INTLOCK()  INTERRUPTS_OFF()
+  #define INTFREE()  INTERRUPTS_ON()
+#elif !defined _ARM_ASM_ && (!defined FEATURE_L4 || defined FEATURE_L4_KERNEL)
+
+  #ifdef __cplusplus
+    extern "C" {
+  #endif
+      extern dword rex_int_lock( void );
+      extern dword rex_int_free( void );
+#ifdef FEATURE_WINCE
+      extern int rex_ints_are_locked( void );
+#endif
+
+  #ifdef __cplusplus
+    }
+  #endif
+
+  #define  INTLOCK( )  { dword sav = rex_int_lock();
+  #define  INTFREE( )  if(!sav) (void)rex_int_free();}
+
+#endif
+
+
+/*===========================================================================
+
+MACRO MSM_INTLOCK / MSM_INTFREE
+
+DESCRIPTION
+  MSM_INTLOCK Saves current interrupt state on stack then locks interrupts. 
+  No interrupts will be taken until either MSM_INTFREE is called or a context 
+  switch to another thread which has interrupts enabled is made. This
+  macro is slower than INTLOCK and should only be used when interrupt 
+  locking is needed to ensure timing. To simply prevent context switching, 
+  use the INTLOCK/INTFREE macros above.
+
+  MSM_INTFREE Restores previous interrupt state from stack. Used in conjunction
+  with MSM_INTLOCK.
+
+  MSM_INTLOCK/MSM_INTFREE may be nested, in which case inner 
+  MSM_INTLOCK/MSM_INTFREE pairs will have no effect. It may also be nested
+  inside or outside of INTLOCK/INTFREE.
+
+PARAMETERS
+  None
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  MSM_INTLOCK prevents any interrupts from occurring until MSM_INTFREE is
+    called or a context switch to a thread with interrupts enabled is made.
+  MSM_INTFREE restores the interrupt mask saved previously.
+
+===========================================================================*/
+#ifndef _ARM_ASM
+#if defined FEATURE_L4
+  #ifdef __cplusplus
+    extern "C" {
+  #endif
+      extern dword rex_msm_int_lock( void );
+      extern void rex_msm_int_free( dword set );
+  #ifdef __cplusplus
+    }
+  #endif
+
+  #define MSM_INTLOCK()  { dword sav = rex_msm_int_lock();
+  #define MSM_INTFREE()  rex_msm_int_free( sav ); }
+
+#else
+
+  #define MSM_INTLOCK() INTLOCK()
+  #define MSM_INTFREE() INTFREE()
+
+#endif
+#endif
+
+/*===========================================================================
+
+MACRO FIQLOCK / FIQFREE
+
+DESCRIPTION
+  FIQLOCK Saves current FIQ state on stack then disables FIQ interrupts.
+  Used in conjunction with FIQFREE.
+
+  FIQFREE Restores previous FIQ interrupt state from stack.  Used in 
+  conjunction with FIQLOCK.
+
+PARAMETERS
+  None
+
+DEPENDENCIES
+  This is currently only available in L4 based builds.
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  FIQLOCK turns off FIQ interrupts.
+  FIQFREE restores the FIQ interrupt mask saved previously.
+
+===========================================================================*/
+#if defined FEATURE_L4 && !defined _ARM_ASM_
+
+  #ifdef __cplusplus
+    extern "C" {
+  #endif
+      extern dword rex_fiq_op( dword lock );
+  #ifdef __cplusplus
+    }
+  #endif
+
+  #define  FIQLOCK()  { dword sav = rex_fiq_op(1);
+  #define  FIQFREE()  if(!(sav & PSR_Fiq_Mask)) (void)rex_fiq_op(0);}
+    
+#else
+
+  #define FIQLOCK()
+  #define FIQFREE()
+
+#endif
+
+/*===========================================================================
+
+MACRO INTLOCK_SAV / INTFREE_SAV
+
+DESCRIPTION
+  INTLOCK_SAV Saves current interrupt state in specified variable sav_var
+  then disables interrupts.  Used in conjunction with INTFREE_SAV.
+
+  INTFREE_SAV Restores previous interrupt state from specified variable
+  sav_var.  Used in conjunction with INTLOCK_SAV.
+
+PARAMETERS
+  sav_var       Current flags register, including interrupt status
+
+DEPENDENCIES
+  None.
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  INTLOCK_SAV turn off interrupts
+  INTFREE_SAV restore the interrupt mask saved previously
+
+===========================================================================*/
+
+
+#ifdef _lint    /* get lint to 'know' the parameter is accessed */
+
+  #define  INTLOCK_SAV(sav_var)   (sav_var = 1)
+  #define  INTFREE_SAV(sav_var)   (sav_var = sav_var + 1)
+
+#else
+
+   #if defined PC_EMULATOR_H && !defined T_REXNT
+
+      #define PC_EMULATOR_INTLOCKSAV
+      #include PC_EMULATOR_H
+      #undef  PC_EMULATOR_INTLOCKSAV
+
+   #elif defined T_WINNT
+
+     #define  INTLOCK_SAV( sav_var )
+     #define  INTFREE_SAV( sav_var )
+
+#elif !defined _ARM_ASM_ && (!defined FEATURE_L4 || defined FEATURE_L4_KERNEL)
+
+     #define  INTLOCK_SAV( sav_var )  sav_var = rex_int_lock()
+     #define  INTFREE_SAV( sav_var )  if(!sav_var) rex_int_free()
+
+   #endif
+
+#endif /* END if _lint */
+
+/*===========================================================================
+
+MACRO FIQLOCK_SAV / FIQFREE_SAV
+
+DESCRIPTION
+  FIQLOCK Saves current FIQ state in specified variable sav_var 
+  then disables FIQ interrupts.  Used in conjunction with FIQFREE_SAV.
+
+  FIQFREE_SAV Restores previous FIQ interrupt state from specified variable
+  sav_var.  Used in conjunction with FIQLOCK_SAV.
+
+PARAMETERS
+  sav_var       Current flags register, including interrupt status
+
+DEPENDENCIES
+  This is currently only available in L4 based builds.
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  FIQLOCK_SAV turns off FIQ interrupts.
+  FIQFREE_SAV restores the FIQ interrupt mask saved previously.
+
+===========================================================================*/
+#ifdef _lint    /* get lint to 'know' the parameter is accessed */
+
+  #define  FIQLOCK_SAV(sav_var)   (sav_var = 1)
+  #define  FIQFREE_SAV(sav_var)   (sav_var = sav_var + 1)
+
+#else
+
+  #if defined FEATURE_L4 && !defined _ARM_ASM_
+  
+    #ifdef __cplusplus
+      extern "C" {
+    #endif
+        extern dword rex_fiq_op( dword lock );
+    #ifdef __cplusplus
+      }
+    #endif
+  
+    #define  FIQLOCK_SAV(sav_var)  (sav_var = rex_fiq_op(1))
+    #define  FIQFREE_SAV(sav_var)  if(!(sav_var & PSR_Fiq_Mask)) \
+                                      (void)rex_fiq_op(0)
+
+  #elif defined FEATURE_WINCE
+
+    #define  FIQLOCK_SAV(sav_var)  (sav_var = FIQLockSave())
+    #define  FIQFREE_SAV(sav_var)  if(!(sav_var & 0x40)) (void)FIQLockRestore()
+
+  #else
+  
+    #define FIQLOCK_SAV()
+    #define FIQFREE_SAV()
+  
+  #endif
+  
+#endif
+
+
+/*===========================================================================
+MACRO TASKLOCK/TASKFREE/TASKLOCK_SAV/TASKFREE_SAV
+
+DESCRIPTION
+  TASKLOCK prevents context switching from the point at which it is invoked
+  until a matching TASKFREE is invoked.  While task locked, the current task
+  is guaranteed to not be replaced by a different task, even if the other
+  task has a higher priority.  However, TASKLOCK does not block interrupts
+  from occurring.  An ISR will pre-empt the task, but even if the ISR causes
+  a higher priority task to become ready, control will still resume at the
+  interrupted task.
+
+  Note that a rex-wait() while a TASKLOCK is in effect will not work as
+  normal, as the calling task will not be suspended.
+
+  Also, TASKLOCK/TASKFREE have no effect if called from within an ISR.
+
+  TASKFREE re-enables context switching.
+
+  TASKLOCK_SAV and TASKFREE_SAV are similar to TASKLOCK and TASKFREE
+  respectively, except that the TASKFREE_SAV that matches a TASKLOCK_SAV
+  does not have to be at the same static scope within a function. This
+  makes it easier, for instance, to enable task scheduling and return from
+  the middle of a function.
+
+===========================================================================*/
+#ifdef T_WINNT
+#ifdef __cplusplus
+   extern "C" {
+#endif
+   unsigned char rexnt_is_rex_thread( void );
+#ifdef __cplusplus
+   }
+#endif
+   /* tasks must not be locked by non-REX threads */
+#define TASKLOCK( ) {\
+   unsigned char REXNT_IS_REX_THREAD=rexnt_is_rex_thread();\
+   if ( REXNT_IS_REX_THREAD ) rex_task_lock( ); {
+
+#define TASKFREE( ) \
+   } if ( REXNT_IS_REX_THREAD ) rex_task_free( ); }
+
+#else
+
+#define TASKLOCK( ) { rex_task_lock( );
+
+#define TASKFREE( ) rex_task_free( ); }
+
+#define TASKLOCK_SAV( ) rex_task_lock( )
+
+#define TASKFREE_SAV( ) rex_task_free( )
+
+#endif /* T_WINNT */
+
+/*===========================================================================
+
+MACRO UPCASE
+
+DESCRIPTION
+  Convert a character to uppercase, the character does not have to
+  be printable or a letter.
+
+PARAMETERS
+  c             Character to be converted
+
+DEPENDENCIES
+  'c' is referenced multiple times, and should remain the same value
+  each time it is evaluated.
+
+RETURN VALUE
+  Uppercase equivalent of the character parameter
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  UPCASE( c ) ( ((c) >= 'a' && (c) <= 'z') ? ((c) - 0x20) : (c) )
+
+
+/*===========================================================================
+
+MACRO DECCHK
+MACRO HEXCHK
+
+DESCRIPTION
+  These character attribute macros are similar to the standard 'C' macros
+  (isdec and ishex), but do not rely on the character attributes table used
+  by Microsoft 'C'.
+
+PARAMETERS
+  c             Character to be examined
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  DECCHK        True if the character is a decimal digit, else False
+  HEXCHK        True if the chacters is a hexidecimal digit, else False
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  DECCHK( c ) ((c) >= '0' && (c) <= '9')
+
+#define  HEXCHK( c ) ( ((c) >= '0' && (c) <= '9') ||\
+                       ((c) >= 'A' && (c) <= 'F') ||\
+                       ((c) >= 'a' && (c) <= 'f') )
+
+
+/*===========================================================================
+
+MACRO INC_SAT
+
+DESCRIPTION
+  Increment a value, but saturate it at its maximum positive value, do not
+  let it wrap back to 0 (unsigned) or negative (signed).
+
+PARAMETERS
+  val           value to be incremented with saturation
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  val
+
+SIDE EFFECTS
+  val is updated to the new value
+
+===========================================================================*/
+
+#define  INC_SAT( val )  (val = ((val)+1 > (val)) ? (val)+1 : (val))
+
+
+/*===========================================================================
+
+MACRO ARR_SIZE
+
+DESCRIPTION
+  Return the number of elements in an array.
+
+PARAMETERS
+  a             array name
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  Number of elements in array a
+
+SIDE EFFECTS
+  None.
+
+===========================================================================*/
+#if !defined(ARR_SIZE)
+#define  ARR_SIZE( a )  ( sizeof( (a) ) / sizeof( (a[0]) ) )
+#endif
+/*===========================================================================
+                     MACRO MOD_BY_POWER_OF_TWO
+
+     Will calculate x % y, where x is a non-negative integer and
+     y is a power of 2 from 2^0..2^32.
+
+     Will work for 2^0, 2^1, 2^2, 2^3, 2^4, ... 2^32
+      ie.            1,   2,   4,   8,  16, ... 4294967296
+===========================================================================*/
+
+#define MOD_BY_POWER_OF_TWO( val, mod_by ) \
+           ( (dword)(val) & (dword)((mod_by)-1) )
+
+/* -------------------------------------------------------------------------
+**                       Debug Declarations
+** ------------------------------------------------------------------------- */
+
+/* Define 'SHOW_STAT' in order to view static's as globals
+** (e.g. cl /DSHOW_STAT foo.c) If 'SHOW_STAT' is not defined,
+** it gets defined as 'static'
+*/
+#ifdef LOCAL
+   #undef LOCAL
+#endif
+
+/* Permanently turn on SHOW_STAT since this has always been the case anyway
+*/
+#define SHOW_STAT
+
+#ifdef SHOW_STAT
+  #define LOCAL
+#else
+  #define LOCAL static
+#endif
+
+/* Provide a new macro that will hopefully be used correctly to conditionally
+** turn static on/off
+*/
+#ifdef GLOBALIZE_STATIC
+   #define STATIC
+#else
+   #define STATIC static
+#endif
+
+
+/*===========================================================================
+
+                      FUNCTION DECLARATIONS
+
+===========================================================================*/
+
+
+
+/*===========================================================================
+
+FUNCTION inp, outp, inpw, outpw, inpdw, outpdw
+
+DESCRIPTION
+  IN/OUT port macros for byte and word ports, typically inlined by compilers
+  which support these routines
+
+PARAMETERS
+  inp(   xx_addr )
+  inpw(  xx_addr )
+  inpdw( xx_addr )
+  outp(   xx_addr, xx_byte_val  )
+  outpw(  xx_addr, xx_word_val  )
+  outpdw( xx_addr, xx_dword_val )
+      xx_addr      - Address of port to read or write (may be memory mapped)
+      xx_byte_val  - 8 bit value to write
+      xx_word_val  - 16 bit value to write
+      xx_dword_val - 32 bit value to write
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  inp/inpw/inpdw: the byte, word or dword read from the given address
+  outp/outpw/outpdw: the byte, word or dword written to the given address
+
+SIDE EFFECTS
+  None.
+
+===========================================================================*/
+
+#ifdef PC_EMULATOR_H
+
+  /* For PC emulation, include a header which defines inp/outp/inpw/outpw
+  ** with the semantics above
+  */
+  #define PC_EMULATOR_IO
+  #include PC_EMULATOR_H
+  #undef  PC_EMULATOR_IO
+
+#else
+
+  /* ARM based targets use memory mapped i/o, so the inp/outp calls are
+  ** macroized to access memory directly
+  */
+
+  #define inp(port)         (*((volatile byte *) (port)))
+  #define inpw(port)        (*((volatile word *) (port)))
+  #define inpdw(port)       (*((volatile dword *)(port)))
+
+  #define outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val)))
+  #define outpw(port, val)  (*((volatile word *) (port)) = ((word) (val)))
+  #define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
+
+#endif
+
+
+/*===========================================================================
+
+FUNCTION enable, disable
+
+DESCRIPTION
+  Interrupt enable and disable routines.  Enable should cause the CPU to
+  allow interrupts and disable should cause the CPU to disallow
+  interrupts
+
+PARAMETERS
+  None
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  None.
+
+===========================================================================*/
+
+#ifndef T_WINNT
+
+  #if !defined _ARM_ASM_
+    /* ARM has no such definition, so we provide one here to enable/disable
+    ** interrupts
+    */
+    #define _disable() (void)rex_int_lock()
+    #define _enable()  (void)rex_int_free()
+
+  #endif
+#endif
+
+#endif /* SWIG */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* COMDEF_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/customer.h android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/customer.h
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/customer.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/customer.h	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,11 @@
+/******************************************************************************
+ ----------------------------------------------------------------------------
+ Copyright (c) 2007 Qualcomm Technologies, Inc.
+ All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+ ----------------------------------------------------------------------------
+*******************************************************************************/
+
+#ifndef CUSTOMER_H
+#define CUSTOMER_H
+
+#endif /* CUSTOMER_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/Makefile android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/Makefile
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/Makefile	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,116 @@
+##
+## Build stand-alone hci_qcomm_init for Linux PC use with BTS402x WDS.
+##
+
+# sources and intermediate files are separated
+vpath %.c $(SRCDIR)
+
+CC=gcc
+CFLAGS   += -static
+CFLAGS   += -g
+
+CPPFLAGS += -I.
+CPPFLAGS += -I../../common/inc
+CPPFLAGS += -DFEATURE_BT_QSOC
+CPPFLAGS += -DFEATURE_BT_QSOC_SLEEP
+CPPFLAGS += -DFEATURE_BT_QSOC_NVM_EFS_MODE
+
+CPPFLAGS += -DFEATURE_BT_QSOC_BTS4020_BDB0
+CPPFLAGS += -DFEATURE_BT_QSOC_BTS4020_BDB1
+CPPFLAGS += -DFEATURE_BT_QSOC_BTS4020_R3
+CPPFLAGS += -DFEATURE_BT_QSOC_BTS4021_B1
+CPPFLAGS += -DFEATURE_BT_QSOC_BTS4025_B0
+CPPFLAGS += -DFEATURE_BT_QSOC_BTS4025_B1
+CPPFLAGS += -DFEATURE_BT_QSOC_BTS4025_B2
+CPPFLAGS += -DFEATURE_BT_QSOC_BTS4025_B3
+CPPFLAGS += -DFEATURE_BT_QSOC_MARIMBA_A0
+CPPFLAGS += -DFEATURE_BT_QSOC_MARIMBA_B0
+CPPFLAGS += -DFEATURE_BT_QSOC_MARIMBA_B1
+CPPFLAGS += -DFEATURE_BT_QSOC_BAHAMA_A0
+CPPFLAGS += -DFEATURE_BT_QSOC_BAHAMA_B0
+CPPFLAGS += -DFEATURE_BT_QSOC_BAHAMA_B1
+# configure defaults
+
+BT_QSOC_REF_CLOCK = 19200000
+BT_QSOC_REF_CLOCK = 32000000
+BT_QSOC_HCI_DEVICE = /dev/ttyS0
+BT_QSOC_HCI_BAUD_RATE = 115200
+# BT_QSOC_DISABLE_SLEEP_MODE = 1
+# BT_QSOC_WLAN_COEXISTENCE = 1
+# BT_QSOC_ENABLE_CLOCK_SHARING = 1
+
+ifdef BT_QSOC_DISABLE_SLEEP_MODE
+CPPFLAGS += -DBT_QSOC_DISABLE_SLEEP_MODE
+endif
+
+ifdef BT_QSOC_HCI_DEVICE
+CPPFLAGS += '-DBT_QSOC_HCI_DEVICE="$(BT_QSOC_HCI_DEVICE)"'
+endif
+
+ifdef BT_QSOC_HCI_BAUD_RATE
+CPPFLAGS += -DBT_QSOC_HCI_BAUD_RATE=$(BT_QSOC_HCI_BAUD_RATE)
+endif
+
+ifdef BT_QSOC_REF_CLOCK
+CPPFLAGS += -DBT_QSOC_REF_CLOCK=$(BT_QSOC_REF_CLOCK)
+endif
+
+ifdef BT_QSOC_ENABLE_CLOCK_SHARING
+CPPFLAGS += -DBT_QSOC_ENABLE_CLOCK_SHARING
+endif
+
+ifdef BT_QSOC_WLAN_COEXISTENCE
+CPPFLAGS += -DFEATURE_BT_WLAN_COEXISTENCE
+endif
+
+
+
+APP_NAME := hci_qcomm_init
+
+SRCLIST := bthci_qcomm_linux.cpp
+SRCLIST += bthci_qcomm_linux_uart.c
+SRCLIST += bthci_qcomm_common.c
+SRCLIST += btqsocnvmplatform_linux.c
+
+SRCLIST += btqsocnvm.c
+SRCLIST += btqsocnvmefsmode.c
+SRCLIST += btqsocnvmtags.c
+SRCLIST += btqsocnvmprsr.c
+SRCLIST += btqsocnvmutils.c
+
+SRCLIST += bt_qsoc_nvm_BTS4020_BDB0_19P2Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4020_BDB0_32Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4020_BDB1_19P2Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4020_BDB1_32Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4020_R3_19P2Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4020_R3_32Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4021_B1_19P2Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4021_B1_32Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4025_B0_19P2Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4025_B0_32Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4025_B1_19P2Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4025_B1_32Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4025_B2_19P2Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4025_B2_32Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4025_B3_19P2Mhz.c
+SRCLIST += bt_qsoc_nvm_BTS4025_B3_32Mhz.c
+SRCLIST += bt_qsoc_nvm_MARIMBA_A0.c
+SRCLIST += bt_qsoc_nvm_MARIMBA_B0.c
+SRCLIST += bt_qsoc_nvm_MARIMBA_B1.c
+SRCLIST += bt_qsoc_nvm_BAHAMA_A0.c
+SRCLIST += bt_qsoc_nvm_BAHAMA_B0.c
+SRCLIST += bt_qsoc_nvm_BAHAMA_B1.c
+
+LDLIBS += -lrt
+## LDLIBS += -ldsm
+## LDLIBS += -loncrpc
+## LDLIBS += -lpthread
+## LDLIBS += -lqueue
+## LDLIBS += -lnv
+## LDLIBS += -lpm_lib
+## LDLIBS += -lpmapp_gen
+
+all: $(APP_NAME)
+
+$(APP_NAME): $(SRCLIST)
+	$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o $@ $^ $(LDLIBS)
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/Android.mk android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/Android.mk
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/Android.mk	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,17 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := rampatch_tlv_usb_3.0.tlv
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT_ETC)/firmware
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+include $(BUILD_PREBUILT)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := nvm_tlv_usb_3.0.bin
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT_ETC)/firmware
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+include $(BUILD_PREBUILT)
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/nvm_tlv_usb_3.0.bin android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/nvm_tlv_usb_3.0.bin
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/nvm_tlv_usb_3.0.bin	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/nvm_tlv_usb_3.0.bin	2014-12-23 15:38:42.412459700 +0800
@@ -0,0 +1,19 @@
+5           ?[          
+                        ,   3     @           0# 7         @ABCDEFGXY&_6~&_6~.8MRXp.8MRXp$          			  	 %                4  '            (          2C@=)          )     v  ) a 
+ } P     P "             + _ H l   j H 3 r K/ I e J  f ;   G D E     G	 V	 3 .   r  +* * <         `       Bi=) 
+  ?     , )         
+     P 
+(bd
+       
+.          l 6          9 ,          <            
+
+O   
+< E         22   : V/ }  f       u[ :cK 
+  3  	    @ F          
+ "$(.248:<>@DFHJLNPZ^fnprtvxz  ^                    A  G 	         D N          T          #%&'88 ++++++))))))------((((((////// 
+
+  >{{sqPPP @``0          7_H)8B"   5V%Q                        U          ; D2!S/  &
+U   _ *                             Gw||||    V          %
+2~~Z                 [              
+   
+   hhhhhhhhhhhhhhhiiiiiiiiiiiiiiiiiiiiiiiiiiiiii}}}}}}}}}}}}}}}]          DDDDDDDDDDDDTEDTTEDTTEEDDEEDTETUUUUUUUUUUUUUUUUUeUUeeVUUUUUUeVUfffffffffffffffffwwwwwwwwwwwwgwwgwwxwwxwwxwwwx_ +                3s33  # f3  6 !            2&`0 
\ No newline at end of file
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/rampatch_tlv_usb_3.0.tlv android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/rampatch_tlv_usb_3.0.tlv
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/rampatch_tlv_usb_3.0.tlv	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/rome_usb/rampatch_tlv_usb_3.0.tlv	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1,297 @@
+P P  8         QHQH PJQIQH QHQJh`  %u
+ 2|qpX#^
+:oMf]				6	`
+p[
+XcHI aI `rH hGF 7 (I ! 3t             T VER(0x%04x:0x%04x)
+ H#$	He
+ H H	FxHh zF .-Jh!GJ8FhG ( -	-#FL:F$h0F G#FL:F$h0F G  JF TX , SP@(	IH`	IH`pGO O O O  i   O   M  I  pI`IH`pG  p t  F p
+L %!x` )pH hGH hGH hGH hG%ppq |E P 0( Q IBpG $M #"&6/h1FHG 1F#.h "HG #".h$!HG #".h$!HG #".h$!HG #".h!HG #.hF!HG # ".h!HG #
+".h!HG 
+# ".h2!HG # ".h8!HG # ".h!HG #.hF!HG # "!.hHG #.hF!HG #.hF!HG #.hFZ!HG #.hFZ!HG (# ".h!HG # ",h!HGIH`IH`pGpF@h% (  `"ucu`` (`!h@ a`(Fp %pF~M)hI C(`r h`h`h`h a(h(h@(` pqIh[ C
+`rBh`hh@`pGgIh[ C
+`rhahh@`pGF %\N2hR C0`r"}h'iB%!}h@`0h0h@0`(Fp $LM+h[ C*`rB}ihBa$Fr(h(h@(` FppF $<M*hR C)`rAhBhB}$`BFN(h(h@(` FppFF %)N2hR C1`r!iBhB	%Bb},a} i@ a0h0h@0`(Fp*  &   '  '  '  '  $'  ,'  4'  <'  D'  L'  T'  \'  d'  l'  t'  |'  '  '  '  }   P    (IJh	hBJ!pKF "hI GL (!q!hGMx( &K !hjF G  (!p)x)!pI 	hp!hGI8F	hG8KF "hI GL (!q!hGHx) ! x*I 	hpK!hjF G  (!p!p!hGI(F	hG8Fx %HJ@yh/F+F)~
+ zDyDf yI qHq!F1'}/Iy	) .%@N@80` (I
+hR C`r9FJhG(%'IyJyB*B
+q:FOF0F9h0
+T(8hK"h!G8h6"Ihh@`HAy yiFp'|%J!yh`GN1yB$Kh :C`rI e1qBBF3h 7B9FFIhh@` %py1y@iFp'DyIhv 2C
+`ruJq
+h
+hR
+`iFp'. ymHyBFhFp@O"8F00\jFPt8F0107'
+'9FhF(iFp% %[JhXHG uqxq:FiFrII0F	hG	QHjFh%LJ
+$ &yh!KHG ( !AqqqiF	xriFIxArrr7Is	hGF@H hG y@ x
+( pG9Ip  pG6I $
+WH!JC5IR@2F0 Fp/J $WH"QC-J.M2x#-h G ( $ Fpp%J $WH"QC#J$M2x#-h G ( $ FpF!jF $bF!F * !K "VH#ZC)     6 6 $  6 l     D' J U  6  S  t9   9 K2F@2Fy$ Fy- $J-xxoF;py{pCy;qy{q;B $--+C[zB $zB $G9|I ,2F 2 qzrbF *	)$F	1pF}--hF y|s8|JA Ir0Fh,0G yzu9F0F
+170_-hFN $0x (OM
+#-hV " FGF Bd0xBI  VH!HCI@@0q F xiFp`xHp
+?)F9U9 x!N ( pI(ho yD	yID7Pk  V
+(%0p % -\  VHx )I
+#VHOx?h "(FGFBHm xB  0VH!HCI@@0q!`F_x! V
+(%0p % -SqWH"QCyJ#2!y`G (Gx! V
+(%0p % -:qWH"QCmJ#2!y`G (.%,*
+  V
+(%0p % -!pWH"PC`J!@0  V
+(%0p % -`H hG y@  yF %[J !hXHG  0p ppVH hGpT p 0quq qRI0F	hGQI F	hG(FFF)
+KHB, F8X8x(kEIp(F  F8U8(F6 F ':N8T8&
+  9HjFh !!7Jyh!4HG (/GqqqiF	xriFIxArrr&Is	h F8W8xA)'I 	X(FG%H$K"!h G"J!Fh G1h(FGW,;,@ ,n F8V8k(FW   	  l' 0    9  9 t9 '   6 6      S  6  8   <: I 	hGHpx3(j yD	yID_________e!e!!!!!!!!ee!!!!!!!!!!!!!!)),4eeeeeeee8 (F}(Fy!F(F AH`nJ!h1GI H`Hi"C"Ra1h(FGI  	hQx( yD	yID !F(F !F(FAY,(F:hziFp(zHpypyphyq(yHqJ !hhFG (J !hhFG ( ik )I	hGI(F	hG1h(FG  ( )	b)`)!AIA` pGIA` pG!AIA` pGJ  jNF *>TOR{xdU	"V"V[
+#V#V * + , -01"@CIBF(  BF) !IC1h@
+C0`pG0h
+FQhhL N!3hjF GnHi3"C"RazH)F'yMp #-hF GvI  puH hG!3hr GgMiuH hGtH hGarrH hGrH hGqH hGqHPIz (` H`Z ` ` `i `iH hGiH hGhH hGhH hGgH hGgI  	hGfH hG!3hc G> dH hG>H  j9H`K  "h\I G (5jFxqjFRxqjFxrjFxBrjFyrjFRyJrjFyrjFyrjFz
+sjFRzJsjFzsjFzsjF{
+tjFR{JtjF{tjF{tCI	hG  H@K"!h G   l |   patch_PFAL_DBG_hci_vendor.c h   8 8  $        p QCA6174 8   4  P ^   HCI pre reset complete  0  p0 ,  X  T    '   HCI reset complete     6 6  pypAyqI	hG J!hHGF`yhq qyqy(r zIhr	h FGI(F	hGp !@(((!! !F!CpGpJF &h!HG (yI (uIH	hGfqxq(yIq	h FGpJF $h!HG >yxy  .. .($lqxqHqy@yI(r	h(FGFH
+($9FH
+($
+H 
+($
+
+CJF &h!HG 'y`y  //"/*&nqxqHqy@yI(r	h(FGF"{H4("{H 
+(&F"{HY(&FH
+Fx %((lOJ!hHG d y`y " ((*(CFOx  I)))    C,F8F (,8F s($%"x ! @(((!! !C8F (%%8F 
+>uqqq8zyz@]I0r	h0FGx 'F---l]H%QJ!hRHG (a y`yx ((((/<QHQH% .%(.!:. 3F)F(& 3F)Fu(' .(.:.' 3F)F('
+eGqxqqz@zr I	hG %F yiFppyHpJ?h!HG ZJh8FG `qxqLhF xqhF@x rybr (?#*5 *%**!79   6  6 W  /  /  '         9 i2Uv i0vi2Sv i0vi2Uv i0v !aqI F	hGFJFhF !HG   pV pp'q)F`r
+ I`p	h FGpM &L (HHpf``H~ x( pp pH*h!HGpx(*h !HGppJF $h!HG H hG y@$0yO(8x (  H($lqxIq	h(FG (HP# h" Hl($  8px !d*Bxd*xd( !FpGJF %h!HG 7:
+!y`y#
+CC'?;@CF;yC?;@OC;x +x +%d)aFd)d(
+OH:` hxHCd!bx` %uqxIq	h0FG %J Fh.F!HG PKx ( y(%@%> ((x )ayjFqyQqyq!zqJ	BaznF1pzqpzp!{p 	B Ba{{.Xp (nJ Qqp(!Qq (  }qx]Iq	h8FG !gH h &G`JFh!]HG VHx )
+x ( y((& & `pfqHIxq	h FG !HJq((ihB7R}5UhhB  % -*  C(h!8  		HC iF  r)F F1	0o({sh{ t z(^`tiFxtHxt `p)F+H!r  % -  Ch!8  		HC iF  r F	0?hxsz tz`tiFxtHxt(| u F*|)F01 /F 7*| 9|T)| F0)F:|11(|9|@0`p)FHm  6 '   < @  /  6 t/  V  6 t9   ?  ' CJ !h@HG (!p!ApT!p=I	hG<H!p!Ap":H`"qAq9I8H`:I8H`:I9H`;I9H`;I:H`<J:HP`<H;I`<IA`<I`<I`a;IAaaa:HapG9H !aAa-!	7H9 $ F	<dd
+,2Lb|	RR bta|"CatpF)H&z@(I 	hG'I(F	hG!L`|@@ `t(FF`|!C`t0Fp  '   6   ) l a   X           =  E 7 +   lq ,q       $c'$ ! FHN x $Ih 0~"Cv %I 	h 1uI HGH h0 ~ (mHBH h 0~II vHG! F  p `p%p phF xqhF@x rhFx`rhFxr! F"I0 F/HG(%q `q IhCA" FmB`p  q`q ACH	RHG FH ! hI Kd (H)pGI
+hR C`rHMGJ  d'I:FHN $0hBHHGd,I HaKh GI H`pFHF`A`0F (DHBAH~(LM)hI C(`r F 0F~($L i (*hR C)`r{J QXG i{s!i  s!iH!i a)h)hI)`v(h(h@(`p0FM (HB*x0FD (HB!HB0F8 (HBHB0F, (HB	0F# ( F88!F0Fp" (|Hz (RIddHdvK "hF G!F0F
+EIdHdkHz (jK "hF GgH x@eH x (dI 	hG^H^J xxIBB\I
+iIi
+C
+ZI  	hGYI pTI	hGOIxOJRLiRi((``pG!abapGpGIHGI`Aa>IGH`HIGH`IIGH`IIHH`JIHH`JIIH`8IIH`pG    p ,    .    .u  n  _Hq  u v   >  p  |    t   llm_rmcdCommand.c     0/  t/  /  lB SLC_FrameInt.c  <-      PF_OS.c   ?  llm_conndb.c    1  llm_connmngr.c  X   x  | l ]     @ MB        [ h    X  p 7  pFFFK"!J!F(Fp  5   pGIH`pG!  pH hG ("H# h$|Jd )
+ jCb| j%Cb} )
+ jCb } j!CbpIH`pGd `  @@ " T gIy*fJcIbHHcJcIx	x@@	Cp^I Hc\L` ([H  ` (XH h (   RHB **SISKhB  MH%  ,HH @ (FI	B !F2F9Fm ,=H;Hz|<H=I io
+c0 Hc:Hb:Hic:Hb9H9Ix"3K%+O7N8L	h(`=b6M~G~5I0p	h  G3I`z	hG2M(xG(x.I0p	h  G,I`z	hG+HIho
+c0 HcHb:'I%H`'I&H`(I&H`(I'H`)I'H`)I(H`*I(H`*I)H`pG0   M/  
+     -  ?C
+  R    T-  X  1   ?C 1      ,  /  X   D	   -  " 
+ u" 8 " T	 K# t	 " h
+ " ,	 q# 
+ # 	 HAhhI	x)J!Q`!`I  HdIH	hhGI @I	hGI `IH`H hGH x(I cH hG &I H`I? `MIhxOL ((2J!hGhFG8hG0hGH x (  `ty((60hG8hG0hG/H{*0hG8hG0hGy (!(x(`|(.!y ((x(v`|@`tO8hGH hG8hG(i (`|(Ii	hGH@x(  `ty(| ( tJ!hG-hx (\IH`H!A`H?!`!`HA`OKih|1jFHGNhk$`jM@1H hGCH hG a@ @H		By(Oy(Ih	hGI Ih 	BJ	B>#C!J91HCP~I H` F`!`JQ`Jo!c9xO)1LI `H	hxGhhhmHG9h hGH hG I` `dIH`H~I h`iH x(hI c{ (gH hGsH hG9h GhhAhVHGpPIhJh@pJ%TL# (e``  `lpqHjpH hGpoH h(e``p``c`p;HhIhWeI	h	S!`cMhihcHGcLcI hi hBaIBaIB40N.M1hhjG !a^I @-I@ZI`i )iG  a   ^VO("H1hhGSI"@F !>hFG   ^I@ KLhd	h hG#h"!<h  GH x(I cEH hGCI H`I `hJH x#`( c;H h G ?C0    0C\1   -  DD &  0C& x  @?C  3C5 5 X0  patch_PFAL_LC_State.c   h   t-  @ @-  $   @0       1C@6C@ @ <  @?C ?C \   ?CT-  d-  N  D
+     @0C$ IK	h` !K(p cpGLh@hFH h BI H`> `H@ihHGI%("NIH	hhGI"@F !7hFGO  I8^	h@ C"6hF  G  8^@`H=tHIp	h  GH x(I cH hGHI@hBIBH !Ab!bI H`zI `H hGH x(I cH hGpL%`uH|Oh|N )F0{*K XB{ )| )@|(	8x( ccwH hGvI  	hG (9tH hGsI"	h	hC@@ pI 	B_I 	hGmI H`? ` ``IH``iHE`iIPH	hGhH hGaHgI heIpeHh?H`8x( c8x( cRHh7H`UI H`? ``SHE`pHH hG7I  ^(:I"tBJ!Q`,J!`OIOJIxU|8K&J6LB-M)NhiB()
+GI H`GH h` x(	 DH h` x( cpG?I 	hG>I=H`?I=H`?I>H`@I>H`@I?H`AI?H`AI@H`BI@H`IAH`BI@H`BIAH`pG        ?C ?C 3CT-  d-  N    -  DD D
+  -  P  @ x  @?C $ $ ?C @0C&  1  H   D   3C 0C0&  q    < @-  t-    1C   k'  [*  * 8 $  )%  K&  +  '  ( )  	, ` HL`z(_ayFMFNGH)'#7hCJD GJH hG!	CHI	h@  	(	?4hD G8 `q   q! x`qq8H hG8I`(<JhG (y q 9O ?h6KG (5H hG z (4h1 G   I"Jq"Jr0I/H	h	)),H ,H-I	hG-I,H	h hG ,I*H`,I+H`,I`pGh 8   |h h Cmd/Rsp in Progress for Cmd:    '  Failed to SendCommand:  0/ h </ X/ Failed PRUI_SendCommand:     H     $ @/ \/ D/ e- `/ =. / @0 H h GpFI	|L( (I	hG`p (
+x &(J)Fh  GpfppI	hG pp pH h ( GppML(x!xBI  	hG(x pML(x!xBI  	hG(x pLM x)xBI  	hG x(pLM x)xBI  	hG x(pppGpFHL@x( x(  p(FFI "x(
+pI#xCp"p-H |I 	hG  pHI	JB B CB   B ppG ppGpIH  %LJB%pB IB  K&B&pB B   pppG##p	BpppGIBpppGpppG0H$ hJI
+(
+p( (  %(p(   #p( p0pG(p0pG(p0pGp0pGHyyCJAxxICpGJ%Kp pL  I pi,H %yy>C{O>Fxx0wN8C0}H  
+ ?xI`p 	pjH{ 	 p(   p $d > (	,(F<\H"xCp0F  iFraL#h)F G (iF	z +F\x!eH2dHcK !h`J G#h)F G (dJ]Ih]GhF z03KLFF#h  G (iF	| +FXx!MHMHLK !hHJ G#h)F  G (LJVIhFG0pSL !h0GRIp !h0GPIp !h GNIp !h0GLIp !h0GJI %p @wHL@x($ @T     , ( $     $  4 !  %  8 "  &  < #  '  H p  0 -  `S  |  9  ~  7  8  @S  8 Lr  S  T Addr: 0x%X: Retval: 0x%X  Status: %d    `  8     patch_PFAL_RM_HW.c  h Addr: 0x%X: Data: 0x%X  Status: %d    X e  f  g  h  i   |wNwIwJC0h	!G0 5 |pI ppI poHrIpoHpoH xpoHpI xp!F{ppBB , "C"@RR $%FSBAAFpAFpZHx) !pXH\K!hV G  F VHz@_LN0x([SHTO :h GRH hG (PM(h h ()h @y:hG(hd hBHHIL x(HIjFxpHxPpxpxp "h	G2H i?Hh )xjFpHxPpxpxp "h	G7H$h )G(3H !Ap3Ip3I x	hG4p1I0H`2I0H`2I1H`3I1H`)I2H`3I1H`3I2H`I2H`3I2H`4I2H`4I3H`pGv  r \    !  $  %  &  "  '  #    8  RM_Wake: Exception   ,q   \ h    h0  ,     4   p 9/  ?/  / , / H / 1  !2 X 2 2  4 t0 5 p HNiH2hx GH2hx GH2hx 0GH2hx 0G'Mq7 $)x2hm8FGdd,'M7 $)x2hm8FGdd, $%O52h9](FGdmd , $%O152h9](FGdmd ,H2hx 0GH2hx 0G %,F
+Hi2  H{ ,HON 3h")F G8Umd ,H $O%F 3h")F G8Umd ,HKA
+	p		CHpH 
+ pGKJ  !BFpGI)pG uLi@}M(x (yHNyyC1Ixh` (|h`O!:hGh`yH 
+}yH!`zJ hhGxJh!`hGuJh!hGFoH %@h @C
+oN#7hFGhH @h
+#7hFGF QA#7hFG QA#7hFG\Jh !hGYJh! iGVJFh!`iGFOHh @C
+#4hFGF YIH h9F
+#7hFG  QA#4hFGF@TA !F# *4hFGF   FCaA#4hFG!  #"V0   (  .HJphb G ("I"3  BFM@(HH!p!I H`"I H`"I!H`pG@S  \ :  ;  <  =  R  S          `S  r    r   r  S  >S  ~  0 Lr p \ L q  6 0 7 0 y8 0 HhR C`rJxIphhI`I p
+JHh! xG
+I  	hGIk"CcHii#C@#Caa "`` !aAapGHhR C`rJxIphhI` /
+I  	hGp
+I  ``aHaH`pHpHL xM"hI	 G	 )hI	 	hG"hI  G)h  GHk"CcHii#C@#Caa "``aBapH! oc H h@i (G (H x7H hGIJ	jI I#	h				B	!h G 
+  I	x )I	h@I	h@@ I 	B!h  G  i )IAa H xJ!h GHJ j@ Ij#Cb   `pGH j@ H hGF~M  ih C@  	(((x(H hG (kIN 	hGI"x@pxH hi ( GH hG   IC`I `NixI  `H`p`~Ib c `|I b|H hG (zH x (mHj!CbwI  	hGvI( cSI`
+RL (rI0 biRR aHbi@ @a!)b`kJjCb jI0GMH oc  (fH hGeI `adHl` hGcH hGWH hG (UH x (]H x(FHj"CbPI 	hG8H hi ) GMI  b2Oxocp`GKi0Cah0C`HJhBj1Cbh1C`GI`hi# (hB `Hk"Ccii"C@Caa !``!  !a`a8j@ H!`5H hG5I 	hG
+Q     :    @  @ <   h l W; p :   0  X	                (  d  |          ` *  $, @@ @ @  p      Pe   t pGRL
+RH h ((NL NLOI F	hGNIMH`OIMH`OINH`PINH`PIOH`QIOH`pGOH 'G`OJ9Fh GMH hGMION
+i KJ 	`}JJ i (ii@akiBiBaicj@ =I  kui -	B` (:IHC)F
+8I
+!Bh (
+1ppx@pp
+('7pwpta%7pwph`0i4a` *	 ( , !
+c ( , @pa ,ta 1pHqicHcIj"Cb   H     $ T <  ;  ? H ?  <  <     '     @  < @B X   2I`0          ,HF	FFFFF h$HbpG$H 8 8DFMFVF_F 8dF	wF8IHIA`IG    HIGF	FFFFF hHoHIhC`HbpG  Lq      |q  A     A IA Hq                  qFB    IeHd  u MB pM(x(H@!y!AIHI !AI GH" {L (#hI GpHIaI`(x!HCI#hAF G#h2FI GpIH`pG    p   pG  p p ,q   8q    7X	Y	qB  Hh )
+HxH *h	J  G GpGHh"C`pG          p8L& x % (5I0F	hG``%p2F3I`h
+2H! hF6vvF`1J2
+F@3F2Z2Z:Z2T9A "Br.1IK @ C H 0 H`hI Gp
+H x (J!hGIH`IH`pGX   ,      	    p   patch_PFAL_UART_Common.c    h iC  %D  FiIx)hJ iLQXF$hfHGF
+8 $cIh'F hB~^H^HAx)(x([JhhFGF ,,iF F	x 8wRJah iFhImiFx'(((VIH hG 	`xiF p GCH x@KBH x(G@khG A>H4! h3"HC<ID0iF pd Fqh	5H h@I	 A1H`@kh0FG ,iF F	x 8w#Jah iFhI m'hB t /H hI HAx) !Ap (Hx ) !pI IH`IH`pG    PR	  ,  %  $   p &    $          D  D  FH
+* F
+IoI	~ mK " h@kG	!aHgI F	hGbH@cI p
++aH x@`I 	hG
+%[IFx@ZH x(WI	hG F
+FUH TI
+hR C`rRJ!ROGNRL-  --!Oxq~OthC`N G8h!C8`N G8h!C8`IIHhJCH`8h"!C8`hC`N G8h !C8`N G8h!C8`<IHhJCH` /I@uvhh@`F	2I F	hG1H {(k /I Hc.H$b.H.Jhh G-I 	hG,HapGp)L%eb	`p(I&H`(I'H`)I'H`)I(H`*I(H`*I)H`+I)H`+I*H`pG~ 2 2  x  l | ({       p USB_A:  unk LP on %d       2   @  @ 03 h l @@ F d2 F `3 G 2 F 2 7G 2 G 2 G 43 3H ,3 !`I}"I pGIHHapG  &  !I H I"SC
+Jz`	#YCJRpGIHHapG  `O  	&  II H :H x(	 &4M5O5L (J p3H4O h )"G(!+h/ GiFH p3KjFh0I  G8!+h. G:h G,G (!+h, GhFF#KphjF I G!+h+ G !:hFG!+h+ G0H hGp .I-H`/I-H`pG  $     8  ` / Enable PowerUp Interrupt     PRU is already PowerUp  Enable PowerDown Interrupt  PRU is already PowerDown    Disable Power Interrupt  I / I / F
+h F OF3I?h	x)3I,,,1,	 cF)F F	H @X("I(F	hG   H x "@M-h3F" G ! G 	! GH,! yD	yIDx "Cx"@pFF h!C@I@  	IiFNigiF0Kh(FG0i ({J QXG0i{s !sA1aI	hGH hGA sIH ,| +#ICQq|It#ICQ!q !AtI8F	hGF,AqAIIA!8`91		M@8J8FhiGI p0a0x( 0pJHh xGq
+0r	(hb ,I+ 	hGJh h!GI  	hGFF h!C@I@  	IiFNigiF0|Kh(FG0i ({xJ QXG0i{s !sA1asI	hGrH hGA spIpH ,| +#ICQq|It#ICQ!q !AtcI8F	hGF,AqAIIA!8`91		@8XJ8FhiGWI p1a1x)0pTJRHh xGq
+0r	p(hb ,MI+ 	hGLJh h!GJI 	hG8M $(x (	(x (U(Ri (O0@|(K(i=N ' (2hR C1`r{ )IXG(i{ssG/a0h0h@0`1hI C0`rhFI	hG0h0h@0`hi (M2hR C1`r{ IXGhi{ssGoa0h1n   -  X  4        0   lB @ ' X  X0  ,6 @   7   <     0h@0`(x( (p[JYH!h xG A!sWI"ICATIi	hGFSHSJ@ `!(ahiG (a(x (MNMO GdBRJ!h1IG(x (ML x (Q(Oi (L0@|(H iGN % (
+{ qXG i{ssE%aAIhF	hG`i (
+{ qXG`i{ssEea x(  p$J#H!h xG A!s I"ICA.Ii	hGFH,J@ `!hiG  a!Hx ) !pJH!h xG	]IH` IH` IH`!IH`!I H`"I H`pG  7   X  ' < p @B patch_qcom_ant_interface.c  h 0  lB @ DD @ K \6 ;M `6 1K d6 'P 86 {N h6 P 46 FFxiFtxHthx(1,.0i0)")hF	kFxtXxXtxtxYt$ZB4F4`!@)C
+   (	`~I@ ZB	 BXyYqy *)
+ zDyDG (
+5@G & (  `~
+"PCJ/"
+! F	   p`phx 	!x"C!p)xpkx  B@ Cpvfp. /	a~
+"QCJ (zx @pQx   )+xB!x@ CHpK!h G	 CHpK!h G	@BHK!h G	`~
+!FHCIEFJ!hG(x@I`~	HK!h G`!C`0ix )	0A"CAI0F	hG` !CJ`~h!G`!C` !C`JH!h xG	FIB % %"		diFzpHzHp	x )vF9)skFzpzYpZ{p{Yp*dJ{xJ<FhN4++p+U(R)jiF|pH|Hp|p|KpK(2(((T*(<888MV`!C`hF@ `~ -@ 1Z#V@ 1Z#Wa@ CahF@``~ -@ 1Z#D@ 1Z#E`!C`hF@`~ -@ 1Z#2\@ 1Z#18i0`!C`hF@`~ -@ 3ZC3R@ 1ZII 1R!:`!1C`hF@`~ -@ 1Z#C@ 1Z#C1R(n)m`!V1BhiF}pH}Hp (_|p|
+FHp	Q`jb~S Z[Bc#B`!C!C!I` -CCB  8  AVDTP SNK    AVDTP SRC   AVDTP ROLE NOT DETECTED \ AVDTP_START ROLE NOT DETECTED    < X 7   I    5C` !C`FJ!hGJH!h xG`A#b~Q qZBkF[B!C!CI` -C C`FJ!hGJH!h xG`A#b~Q qZ	BkFa[B!C@!CI` -C C`FJ!hGJH!h xG`*`~@ 0ZB#iFIB8i"0C`I@@ ` -C C`a~hFJ I PRJH!h xG`~a~I qZBwjFRBr!ICICI` -C C`JH!h xG([)} -& &kF|p|XpX|pX|Xp8i0 F.`#@.0C	   (B& B!`F	C `!C` !C` CaG`'!	@.0C
+   (iFIB  	BUJ`~h!G`SILJC`IH!h xG`*!@.0C
+ s   ( iFIB 	B@J`~h!G` !C@@IC`3J2Hh	 xG`&!I@.
+0C   (`iFIB 	B*J`~h!G`A!C`JH!h xGa!"F@.
+0C   (jFRB B
+ @CCaAJ
+Hh xGhF (*F8F	IH`pG\ 7               @  X   T 6 FTJyxx	 *((PH hG:xkFpYp$((,HH Y -=0  y(CI (4(F0Ay )/@yJ(,"9F(F;HY )  y((i1J|* *3L#h[ C"`r
+|0K00h!G h h@ `  8 $jFxpAxQpejF#IB"H&K!h  G$I 	hG#Hp8R!L h ( I	hG   `J !h GH j@ H hGIH`IH`IH`IHapG    D `2    D   8  HCI reset complete   l |       -Z  Z  7[  Q[ ` HM@}}# $ jh&FB.p$i`	BB.p (h` k`K "h0 ihG ,J)xh  GH hGO $>F6h h (!	\ )I	hG (
+hB `hd `,J)xh  GH hGH hG(K"x!h2 GI  	x ) pGI	x ) pGH $hH hGF i!NIB|#ZCR	B(H $ x ($H x ( $ , Hw!x G|!HC@		 a FpH { (TpH hGJ (!h  G!h  GM}! " +h0 GL x(   pH|
+@| ((  pH "A+h1 Gp  xN(
+(z(qJIhGHehhh -(i (xR*8FG1h FGx+
+*#!*6"*</*B*Jdk"@0CvH hGF(i"ZR 			0c1h8FG1h FGzK "hN!(FG(i"k@0C1h8FG1h FGk#@0Ck#@0Ck#@0[C0#C yjFp`yPp !Q^]J  hG\I  p1h FGZH hG FWNFy (*`y('z	(#((E(F1h0F(F1h0	8F0h5@]`q   p  pF>H~0M <Hx( x (:H y:Kbyh7HG(  p F>p)h FGpAxFF )^)W)U)U)|R)R)L)N)sI@T  `   I 1  8& 07 7     \ ' 1  9      .  patch_llm_server.c  h J ?  <  /  @ /    8' '' 'H } ()H H(x $@ ( (0x (@  0p(x@B   FxFIAx)	)))!L!LL! F -((x (@  (p   F  FHFx (} y`y %{ - F0`$W{jFu{Qu|u@|u />{ .7*F
+ ] (2F
+ V (h'WH@x-  iFr siFHiFiFHOs  rHhA
+I	B@I@=Hh!hFH@x.P!iFv HviFHHiFiF pp	r
+*F0Pr2F0H !!'CH@@ Fs@ ~I 	`Hh@H`F}H hFGF{H!NC h1F1AZA\1F
+1AZv]sHAy )9y )6gy  h](lI h  $ ,) yB"a  (`{(bI h  $ , , { (B(G(
+!@@  	 `0F(QIh  $ ,MI	h]bsU'q`  r): s
+!@@  	 `@HFK !h> GEJCIhCHG h!(  	B
+!@@  	 ` rz@rB:F1F     s
+!@@  	 `-J,H!h xG  H } (eJPy (a	y)] )] )]!
+	{YI{y3/        @ 6 '  L 8  Tracking entry exhausted     4  4` h 7    ! (~H"hPCB\\\\
+\*
+*   !*t*p@	VBk
+ByH(`dd H@h (i  @\iFuH@h ()  @\iFwH@h (  @\sH@h (  @\tH@h (i  @\u  	
+ (w!" #@'(F8@  (F@(F@(F@ @ ({ %g@0AxBxmR )^B\)-)RaP(I)9	))	)?)): '!5(. .  $(&( . ( . @a
+ ( . @B ,	
+@	B , (((@ (	  ((  ((	@VHAyB XHo ,R F>UNVMVO() F= (2@<k (A. (1h8FMGF1h8FGF F0F`yqy( (,1F F1(!1h8FGF ! F$(0 F1h8FGF} ! F(! F0F)h FG ! F( F)h0FGGFZ ! F()h FG FH hGfH hG_IH`LH4IH`IH`IH`IH`IH`pG              ' [ `  ` \ > O] > ] > mg > eh > oH x (nI/ 	hGlH %h ){ )FhH{ (BgIi0{fH h (  B* $,"_H @X (h (o .\I0F	hG (0F0F@y( -UI(F	hG (x 5Fd,KIhB  `H` -    s1FH hGEI	hGF $BO, =X - y((i (x @[
+n (8H hG xnFdd,0F0L h ( x(/I-H	hG (-I	hG   `+H hG+I 	hG*I p*J)Hh ! xGp(&Ln *#x - p *@:k n *K "ppIH`IH`IH`IH`IH`pG     5  1  @1  h> ' $< `2  9 	  x    :    ;       i i ; i < Cj D< j ; phHFB/XyiFqyHqxpyHpz ,F	BByJ %yIyHyIpzpxHypzApYzpY %tJ1Fh(FG(Fp pFnHFBcmH`mH hGmK "h!F G DiHjO@x(8h ( iF eHz  xpHx q_H x`q (
+ iF ( iF88h (VH xiFxqHxqNHx (x rHxOI`r	h0FG -CH h (JI(F	hG?H !`GHx(FEHB	DM(x (CI 	hG (pAHBAH hG@HB@H@j (?I`0
+xsIxAs
+F:X: hx* 7JQXG J hG pF1L1Mkh  )hBFGF)hhG0@p#hBFGF)h hG0@p%I$H`&I$H`&I%H`'I%H`pG        p  q  s  <:   
+  ' 6     |&  r    6  R	  | l G  <   .       R  & k 9 Yk 9 l : m 9 xR<**x** pG0xR!***6,"*/*1
+F2F*$"C&k@2!$#Ck@2$$#Ck@2$d#Ck@2\$#CJFFhF !H
+G(` (!,	,,",/, &Gp(h7CGp` C)hpIH`IH`IH`pG'   	n D; +n : n : I  	hGJIh  GIH`pG     <: 9o H pFF-Hz `x@@ `ppIH`pG|&  mo 9 IJF1 *
+~JRR  vsIH`pG|&  -  o 6 FF  jFpkF<0@z4(=(ZW	)W8yo#(0h (I	hG  `H x(Hyo`0}	
+ I0i	hG8yiFp	K "h!F(FGiFp (#KjFh 1iG z'(`hNx##6h"(FGI`h	hG  ``rxJh(FGhF x):F(F!ICyJwHh! xG!CtJiFh	xoGjI(F	hGhF xlH %x )=kOkH DX ,1o (.hI	h )	iB'} )dI	hIiBk *&k .1x})~ *]K "hG ([I F	h00GYJ1FhoGEI0F	hGNHm xBF  ko41)>(F`0 8JJ1Fh  G   h0@{ (!  !CO#?h"0FGk ?H hG@y@@}@!IC  5 i~8MF-h5JR G  4`r0FTpF/H% {F8);)FI  % ,*  p&I 	hG ( ,   p p(Fp!IH`!I H`"I H`I!H`pG   H  `L DM 49 ; dL 7   K   `  2  @1  `  \M  J 8 : t9 0u  M 5  ? o $M q L q hM -r KIF	h G ~ $  FK%Fhh0FG2x   *!AC )B F@B -  %hP0p *+0x!HC ) ' )@B"F@CBBA1p ( ,  FF -o#@#BBB B  @IBP @ 0xqxB @  .I0F	hG (  (  IH`pG  H8 ?  s (7 FH hFFGoh0@{ (Q 8v Mo`#-hB!GFk @\H(I(J(	K(* oAH@#1 !	Y  ){{B)F 1FB(F 0FJB 5FhC!oI 	AC xH@xN;F6h)F FGuHcoh0@{ ( 8vpN1hI C0`rnI	hG0h0h@0`iN (2h!gG (!s7!Ai fJ%F@` !o5A`hj (2h![Ghb^JohhGpF[H hGoh0@{ (+WH h ( iB$`1}TM  SN0hG@y QH hGk`0@y (*h! FGo`0 }0hG@yGI F	hGp*h! FGppFk ,F\4{H)	I)	@2I!Csp 6N #"6h!G (!p
+"0I G/J)FhG{!@sk"@0Cpoxh3[{R + !FL$#$hGIH`IH` IH` IH`pG' 9 T7 (b    @ h patch_llm_afh.c < h7 @1  P7 t9 D7 \7 : p_  : ; Yt L7 u 7 v d7 v 7 z(NHyjFpyPpyqzPqHzrzPrzv{Pv|sH|Ps|s|s}tH}Pt}t}t~uH~Pu~u~uB!JB)PBhF "2BhF KF
+:B BL  B ZBB  pG@( pGF ik  Hp%7n(&FJ6z(l(~~(}z(~(z) ](vJ FhG18F 0@z(%(#(!(( (8F 0 @z(} i"00 h 0{CsX (I F	hG (K!ihGF0N %"6h+F! iG' i"00 hMhPC F-h# FGJFh FG ()I F	hG ( % q~N}"#R6hS G!Ar i7OTWk@"CN #"6h! iG  Hrh0@{ (J!h iG   #}"q~R NS 6hG!ArM#-h F G f=F 5hz(hq~S G i"kKC "hp~!G  hrF8F 0@z() ](} F~hq~S Gyh0@{ (-  Hr ik}II oJ)Fh FGt i"00 hhM 0{@s i"00 h-hhPC# FG W iF00 hiF[JhG   ! i1	Xoh@k#R BCi&!	\q~KN@ 6hS G Hr/h0@{ (hq~S G   Hr;K!ihG8N #"6h#! iGh0@{ (y ik@@ 4J)Fh FG4I 	h0G 7pxz (# i00 hj (,I	hG!i  11	hbxz (I F	hG (
+$H h ($J"H!hI xG(FF   F(7(5(3F8F  {  w    M K J K dJ K K ,J M hJ K J  J LJ  L P8 
+  7   8i00 h i ( I, 	hG x8i00 hhFNNF1N=5NBjj =jjb)bbI	h8FGN(()(Vt`z(wzhwzv {v`yiFryHryq zHq`{ 
+)F8F2h)F8FG8i00 h 0yII qM`z(wzhwzv {v`yiFryHryq zHq8i00 hj ( z 
+)F8F2h)F8FG8i00 h 0yII q)8i00 hj (iLC$h)F8FG2h)F8FG8i00 h 0yII q8i00 ha      LF ((F	 i00 hj - i00 hj ( 	!h GF!h, G } -{ i00 hhFNNF1N<4NjAj <j"babb ((0Uxz wz`wzv8{vxyiFqyHqyr8zHr zO?hF!FG. h`  (rh!"h(F7%xz wz`wzv8{vxyiFqyHqyr8zHr(z FF!F.o`h(FYI F	hG i0 0 hb	 	h2R{ *i22hh * pG	pFhGM0@{F((hG x  p(hGxpy?@ ix!00 h 0sAH@H?K!h<J G(hG"iFF;JhG  p (F6Hh )	B @9k )  pGph0F hoh"@ o`0Co (#H hG"I	hGo!J0A~hU GJ!Fh GoKhx1I{ )N&2@ &2Cp " )hF+8 <= K (? P8 9 peerFeatures[0] = %d    `  8   \J 
+  ' $< M 8    M@2h0-h~@~GoJ0A~hHGH hGI  	hGp&2@&2CpxH hG>H hGIH`IH`IH`IH`IH`HI`IapG  $J 
+  9 h7 ,7 < x K { K w} K ~ K 	 K  L  F  iFFq -(i (Kh(FG/F7 ()ik4 | (K(A(_ (_J/!hGhF y	(w $ jkMy~-h#FQ GhFq}(G(r@Jy~hQ GH hG@yK"h1F(FG&  tx#(iM-h"GI(1{"@@ s@0y@qh"F )iGh{0@{ (  B *   t>(2F(Fz	1{"F@@ sh )iGh{0@{ (  B
+   mMF"-hy~Q Gr   gM}"F-hy~Q Gpy py`pyp0zppz qz`qzq0{`Kqh*F FG ]N@@    ` 6h!`hGhF hF `!ICh0@{ (  MIs	h(FG*iFFJJhG   )iHM{-h# FG t | (DH hGDHz	y~jFpQp!|p>L#$h!FGhF y	FFFC0k@1y	+o%h2O1I{ )@   F#<h"G *I	hG F0{"Cs'J1FhoG   F#<h"G F!F0FIH`IH`pG\M 49 patch_LLM_lp_sniff.c    h M M t9 J ; lM $? ' J J : 8   : < < A J  iF	~)"!jFvk1{** * "F F O IH`pG   M oK`1hF !G F>IH`pG  7  89 F )
+o (k3{J+G+  6, F"KH!hGF@IH`HIbIcpG  J 	 8 A 8 M pMF.{ . ({@h0@{ (H h ( i!iB ik@1Iy)
+h (*!qI  	i1Hh`pFFIH	h iGLF { (Jt!hG  sHFCa`')' ``& CB ``hi@x(-Ih@`H hGM*{ *P   I  x ,K YX@1{vv sBN1hI C0`r ' (vH ih ,{(@<k ,0h0h@0`({yJ (so` !h GvJuHh! xG  ,rHl FG{ssg'[M){ )qaL'"h(( (it!VG({@@ (s\I
+hR C`r $WN2x *VK X!	\!1	\ )VK"!0h0GdBKIhh@`0xB({8@(s"@(sF	hI C `rCH hG h h@ `({!B,<I (&	h G (!({!C
+0 (	h  G({!@(sH!1G({!"h 1G({8@(s({(H hG({ (
+JHh! xGJ !h GIH`IH`IH`IH`pG  5  @1  1  ' patch_llm_pca.c h q  ?   2    M 7   lB D    |?  ? 9 ?  ? eH!qqJFh
+HGL h (
+I	hG   `	IH`
+IH`pG  `  	  9  6  8   8 I
+BJIy
+wIBypy
+qyHtH h GFH %OFB@BhHJ`HI3F@2y 0FJ	yF{ ++)7~C~ pF=`Fy 7Kxh!HG(%Kxh!HG( %J1Fh(FG ,H h (I F	hGH !`~~ pF`Fy %Kxh!HG(%HBUx( yjFq`yPqypyPpB % z( %I 	hG -,~ Hx(HByBjFABjFBy"zByazB%HAqiFAiF	!zqazqJ1Fh(FG ,I F	hGHBZH hG y@x(     (~  (~Hx(%0(}J !hgHGwH!pvH!yqwJaH h-tOF:h^HGnHx)qO8o (8Fp0 8omI 	hGlI	hG8o (]J1Fh(FG ,!pdH:h!IHG F (
+II"j2	iRXkhR 
+ !UJQV(F H!HCOID%F 5y F@0 )))
+y8 (z (6 F@04y )z ) >H?I	hG f`h`y(    8O #]?hU G1i  11	hv1i11	hHv	   ``*H)Ai (' 'Khr"F,2hG $I"H`$I#H`pGt/  /  /  7    
+  /  /    8' ' <:  '    7 @ ,    t9 <    > 6   %  < M ' a 6  6 7M)hI C(`r5N5O0h $ (
+{ yXG0h{ssD4`.H/Nq4`ph (
+{ yXGph{ssDt`(h(h@(` pF`0 Fh0@{ (I(F 0	hFG (I0x	hG)F Fp	! FHK !h GpIH`IH`pG    lB -  ,  7  8 8  RS Error: ltAddr     i K  K FH!HCL X (uH hGH hG  !  FN6hJG&F 6`y  O#[!?h GO9hI C8`rI	hG8h8h@8` )8"Hq'"rr"
+
+"J#P`hH`yH"}NjC,$@2( ~D6yD syCq
+5 syCqsy#Cq(FtJrIhGF  ,FH eNDC0Y (zcH hG0F&1F 1y  #aO ?hF!FG]I
+hR C`rUH Y ({[J QXQOG8Y{s9Y  s9YH9Y8QOO8h8h@8`9hI C8`rHI	hG8h8h@8` ("q0!s!9H hGF?H=J@`!Ah8IG;H"xCp-Hy 7ON G6I@B!51 !8J2hG"Hy *H"xO@p:FyH hC@0 )
+))yII qy"@qph (!	\)"I	hG!Iph	hG Ih	hG  `p`IH`IH`IH`pG   ' ' <    @ \1  < lB   p  patch_llm_rmcdCommand.c h $' & 8  =  =  <  ! (x4yoDH - ,%,#,!,,,,,1F?JE!h7G;K" !h G"R]2pz
+	3O!?h2F G1K, ,,,,0,(,,)h2F^ G"h2F[ Gh2Fn )iGh2Fq )iGh2Fx )iG
+h2Fy )iGh2Fz )iG0FE (I0F	hGIH`pG  8  patch_LLM_LE_control_pdu.c  h   49   lJ pJFhFGF(F`CpF M *FF$*h FGF FxC    $ I	hR GB~$ ' x>F=F ((F!HC$J@hGj iFR(yB F$m xBB}C ) )$xBfI| 	hG4FB$x  % /i hFAZ F )mB (B@, @$"!  $ x (J"A hFAZPC$hmFB F B, % /%r  !
+FCC@@!FM
+F  !
+FCC @@mBB@B %I	h/F G & ,2Fxm@Bp@/F  %vBBBB /8 )2 ), ) ) (>  dN0`p` ,'9F@*@@uh3h*CC@r`1`B (B ) ) ) )@B CI 	hG%H (%% % !%FF6 h hFFp %hFD] ,!F0Fr`CBm4F-@,!F @!H )$N'9F@uh3h*CCr`1`F@ )H !`A`  ,C x & (? pCB  (J!hO1G (J!hP1	GxB!Q1J?  ? 8
+    patch_LLM_SyncLinkMngr.c    h hG xvBN 1hU0G
+(J!hW1HG  j x (0I 	hi0G 	FiBJ!ho1HGiBJ!hp1HG .
+BJ(G    (u I		hiFq &] /9F xCBv .@(F @"Q *O"@>hh2CN;Cs`2`
+FI *  (h(  (iBJ!hw1HG(	)@I)( I 	h0G (~!x   )!AC	B !x@B  h x ' (/J!h1HG JxC hiG( xBI 	h0G  (  x>FB.J!h1HG pC
+JJ xvB@ p  (@q x ' (+ ~JxChiGB x>FB pC BB Z xvB@ p    xB  (A( (dJ!h1aHG!x '&) #pC{C B@*B 7FvBB xC  (RJ!h1OHG xB xC BB xB@ p@ ,  FCIF	h G  /7z~ "<H=Kih FG#2F F ,5I F	hGhF @ hF@(0F	 ! (mkFZBZ "T kF[$LB@+M$/h@mh<@.@4CL $IR* #M5"@.hoh2@<@"C* $"F )
+V 6B!RB ,J  ? L h H 8
+  ? H8 1  ?    I[)@+ ) pGpGik33h 3x +c)
+h0@{(@2Py(  PqpGF i00h  p#5Xp(xFF (c( F#ik33h 2x *
+h2R{*@0By* "BqBJ FhG"F20pF (
+)+))$)  (p pp (p   6N}"A~#R6hT G(x ('(%(#
+(! i"00 h 0AyCAq(x (.(O#?h" iG   "O}"A~#R?hT G
+ (p   i"00 h 0Ay@ ik@0@y (
+H h (JH!hI xGiF@~qHq(xqHz	 tL#$h!FGI	H`pG  |J M dJ 
+  7   8    pJ F JFFh !0FGK "h! FGp1FIH	hG  JiFh0FG (  ik0{(( (I F	hGH`HK !h GIH`pG8 6 	  9 T8 6  8  RnR WAIT...   x: IF	h0G"F2QIB (k}"F QCB"2Y )cJFhGc
+I F	hG#CQcIH`pG   0W ' A  H x (pGF{F2)3)`hh1I{ ) i$!00 h	\h (P2FFFF);)9H x (7 (@   d"aPCFHxB"@xHOk@0 yH x(.
+hy	(;h2F)FHG( F;h2F)F,0G(   FH{ )ahoB]ON9ih|13h|0jFG J  	 hF PC0,8iKF0Bod$$	g\BB)J!hG2HB(8iKF0KB	'o?<Cd$$	gBJ!hyGo|1h3h|0jFGzM(x (zJ !hxHG (!p!	jFuJBtJjFiF	zqiFIzrJAqhoIGqJpHh ! xG (pF FbpFF ("-`y	(FJI(p`I@
+hF1T0\BH\IkB@K*Fh!F@HG( p  p pG(QH hx  0*!0~0H!KJACH"PCHJ 1y)FHh ){(CH!F `CB  FFc!<He (6I hh"o@!	C h		  	B !`1I0H`2I0H`2I1H`3I1H`3I2H`4I2H`4I3H`5I3H`pG   L
+   T-  8'    5  1       patch_SLC_utils.c   h M   ,'   q  `   7    t/   -   1    \1   <  `D  D  D  D 1 D 5 PD  D  {(Jv!hGL`h ( (`hk
+0 HiBHh{( h(F@8 !c4h ,~IBJ!hG" h*h  	BF*  	 ,&@<k ,BJ!hGpj`J H{(*F{( F {("(#(
+(((-(.(2(
+3(4('HiH i {("(#(
+(((	-(.(2(3(4(	IF	hGIF	h GF ,B hA
+!	B)hH		B(h!h@H		Bh `  ,c5`&@<k , t5`E`  LN rA1d!ar`sHh h` (}Hh{ )Mh*hSK?	B/I	x)I	x)I"c{cIzH	hhG (}}I	hGyI"ch{ch
+h!	
+CrI	hQ	I	1d@ A  rBlI	x~)kI"c{ckH hGFh %{)Ah )fK|1hjFGdIhF	hG0i  h@ 		B % /x!h@CB -h!B wCB -qFPI#csA	#r !1d ) F@9k )JE LB#rh!	C6I	h@ @	0d@9k )4I.H	hhGh{ 6IXG(    r`s'(H x('H!c !c )"I"c{c!IH	hhGh%J{ QXG (J!h1GHh h` (7
+5patch_SLC_dispatcher.c  h 1  X  (  \1  `D 1   -  1  D
+  x  @?C  ?  h	 (c  L@ \A H x(I c  c  (JQh1Ci )Kioa(J{))Qh#1CAh )	i ) (I	hGI  `IJh	i`sLFM h(`H `0FmF({3(I- 	hG(h `8FLFM h(`H `0FZF0FV({4(I- 	hG(h `8FO:i$h (IF	hBG  J!h HG	G  8aIxa`HM x (
+yH *:x** "Bt8x (($(((qnC|[Ct+H x(
+(* xp hp *HH`H hG  HH`i i`JHH`i i`y(BHjF h   NH6hh#iFG (iF ) I			  h!	C @$	, $ , $HI h   	` ,pI{H|LH` hGH hG hG  tHH`
+ kIhp	h+ G8xeL(("!$h  G" !$hFG ]JiB (RI	hG  x))t !QaQpC!sy)_I"ICA![I\JIk`hYIG  YIFUH hBUIRH	hGF@M(iB ,5I F	hG  y &(3BHCO h hF/H#?hh"iFG (${)")#)iF ) I			  h!	C @  	(
+ h3J  `h0I FG   ,I F	hG.aH InaA`! 0Ap pFFB	!H h (#IH	hG  Fpx  @?C1  1     ,   -     < 0   h   @-  X0  Y  d 5 $ $ D
+  @  5 X  \1  @    @ FHx(Hd"A PCI	xBIH	hGK "h!FHGF(   ` pFH(FFH x(	 ,. -I(F	hG0FpIx)H!HCI@"D!FH
+!F@1FHjIyppGIx)H!HCI@"DI F F@0F|IQ|H xqpGpFtH $x((F<p -D FH!HCmI@"AFlH1F@1FjH-jIyp(F!(gJypfIppFFH!HC]IFDF9F'  ]("  "h\K0  	B
+y h@  	`0  	B *TISH	hG  (@@h   	`MJ(`h9F(FGh(` (pF<Hx( Fp{0(CJ@Ih@HG|@H hB?I>H	hG ,,I F	hG;I  qH!MC*Ii 1qpF!!04H3Ib5I3H`5I4H`6K4Hf5Hf5Hc5Hd6H5J6Ic
+a6JBc`6J5LT`7L5Me`6L`7L6J"`7Ja7JZg7J`7Jc7H`8I6H`0pG/  t/   /  '  @ h*       /        P
+  8 (D    h \1   /  A  @  C A L@ o    @ A  7 LA  \B '  @    y Y  C F  F  h ( F  h (0|"@tN0y (H@h@y(Jb!hG' - / h!	\o	h )h (  Ih	hG -i  q 	KI!ho )Oy/Ohy/I i		n		??	B f!hoo $$	B  +#\+s[ *JRhRy*J@f(FI{*Ih#1CI{*Ih#1CpFzF(DMIhhB?HJjHhmG (.I	x		)i )	0@yJ(K"ho GIH	h iGI @jaHh`H !qHI h`I bIj	hG  pI- 	hGI 	hG0Fp3I  p2H| )@@IHj (
+IhIy))`0A"CA{IHh@y((Ij`1H"@CHJ!pFH%{ hG ahF xshF@xshFxthFxMHt(x(N@1h0	(x1h@0\`qpvMF(x(vL@!h0	UHmdI"x@p*x#hR2\C
+p0FpFF@h]IBXXO!x8x6 )3bIy )M ..Ij@1	yD=I@m(>Hy	(:F SI(pSI@
+hF1Q0\#(h3X~Bo"@0 ( x(.j % 08x	B	AH  p@HI"m ( %ppLF| ((H x@	HmAy	) -Ip y (z1J !h.HG s .I p	h FG,H }by (*H@y()KjhG(IR-  T-  patch_SLC_FrameInt.c    h DD -  1   -  # /  8 -  @D 1  " 
+ h  ?C& < @   X	    %  D'   8 /   T   
+KJ FhGKJIH!h	 xGHIj	hGpFKF|FF (y (CJ !hAHG AI>p	hG8J?Ih8FG7J6H!h	 xG -4Ij	hG6H!@h1 i	Xkh	I /H@x@+H@x@&H@x@%H$I`%Ic&H$IAa&I%H`'H%IAb'I&JJ`
+a&Jab'J%I`&IaI&H`'I%H`'I&H`(I&H`(I'H`)H'IAb)H(J`a)I(HbpG 7   & -  D'   8   /   	   3   dD Q "  % / W   e  \   9 <   W $# i d# { $$ p6H7Mx5H|(~(
+5H x(4H}IA}IAu(~(!j~a@B	O FC+H0@2@R|@0Btp!H#Nx!H|0~(
+ H x(H}IA}Au0~(# F#X@q~NFBO hC@7|@0GtB@FZ@BO!MC@0C|@0Ct
+IH`
+I	H`pG6  a  <&  	  ,  ha   (  $ F  F -Jd!hG4`|( H@j ( (o-)F1HF2K  ("`F2CHh|! G   u }B	*  0 u#
+|':B@	@
+0 uoF2WrFh2R{ *@	@
+0 u	@	@ @	@ u  (} ..oh *h *	|!B, }@	@
+0 u!}H*I	I!u) .h0@{ (, }2A	I`)D uh|! Go!	Zh0@{ ( }@	@`F !@0Ch ( }@	@  }@	@ }@	@   uo|h0@{ (h! Gh! Gh"|! G ( }@ u uo"|h0@{ (h! Gh! G)L h ( i (#J!hG!h"Kh (ih *	i!1
+\00h!G00 "hFGL"hR C!`rs h h@ `IH`IH`IH`pGpatch_SLC_poll.c    h T-  D @1     &  &  & EH x (DH(CH hGBH h (AI	hGF.~C4 *		))6)!v2JB!"p2B!vF)H x(  ]!C%Ic MhB!#O$N (0@{ ()h  p!K!FhjF|1HGIhF	hG 8@0`HDbH` hGI  pI F	hG@8@   	IH`IH`IH`pGQ  &  lD  -  &   x  @?CD
+  1   h	 \1  l&   DD i &  &  < H !@n! 1 
+	 	I)L ~(
+
+H
+I B (  vIH`pG  \1  1  	     D IJyBhJ\h)	Q  ! )
+ $sI{)	Q  ! )!TpGpH !Dy , "hh&Bh\(     (	s@{(     (nTIBppGpHMxH $AqI	qIJB	(x (H,pH!Aqq"Bqqr hppHp2!ApppD`pI  HqJqPqJMPrNhrOprKxrXrPhy ( ;hh ( 3ph ( +xh ( #H@h ( HI yq@ 1qIr1r1r1r1rMLhi (!hGi (!hG $laaMO(iN ({A)2hR C1`r!1yXG(i{ssD,a0h0h@0`hi ({B)2hR C1`r!	1yXGhi{ssDla0h0h@0`i (!TI	hGi`ai (0@y(I pJHh ! xGiF0DqFI	hGIi	hGa}H!`D```{Hp{HqAqlHdI yq@ 1qcIr1r1r1r1rpkMF(y $ (`)h0"1F (d(yB p Fpp^N1yF )7`y	(`J!hYG   xjFs ys`y %Ps )0hiBiFhF!xBhFaxBhF@xB(Fpm0yB p pG pG0F )5 -3HyjFPpypzpzqzPq{q|qH{r{PrH|r|r{ $ ((~ p*h *zhy)yB $ (YiF	x#cC\BRdBMzL /  , /  t/  @  6           .   0  lB   8   ;   & & 5    patch_SYS_database.c    h B
+#cC3 BCF )h`CiF	iFIAiFiFiF	iFIAhyiF@hqx ( pjph(y!HCI	hG(` (lq $ 0y@q F00h -Bz *P #R<$DC,]B (B@0 pGBC@B 0pGFF%h>F -bz *Q #R< HC(\B )JA BKAB!(bzQB<!ACFR< <1BCiF`z@`r`h]IU`z (0h -Bz *P #R$$DC,]B (B@0 pGBC@B 0pGF hF (<%h>F -bz *Q #R$ HC(\B )JA BKAB!(bzQB$!ACFR$ $1BCiF`z@`r`h]IU`z (0h -By *P #R ,]B (B@0 pGBC@B 0pGF h (5'%h -by *Q #R (\B )JA8FBKAB!(ayJB		  F1:i(.`y@  `qh ,By *   *#CC[\BpG@B pG F#h +`y% ( " (
+'WC]BRB-CI'
+h)FyCR\ * yRqBB
+F2B[R BC9FF`y1F@`q4Hj1F3H 1F2H1F1H1F0H1F/H(FpFFF )T -R 0hFDpp(h (,jy)yBD $ * CX B
+B	AXBdBB 3 (h @iFhy@hq FpI(y	h G(` (  hqF          phFF .!Ey - 0?hFDppl  m rX B ,	B	qXB ,eAL B`ALB$pF ) , h ( FF`yAB
+@  F#h1:Y-`y@`q(Fp pFFFF"I  F"!07 !'ppp@p(((((!((((ap!ap(?((( ((3((/(  0  )x! "ST*\@
+t(/(x thx`t*0  )y! "ST*\@
+t((x thx`txtxt0  )
+|!
+u*\@
+q(")F a F h (9hz (6iF@@k (.HBHBKiF 'nz $ .x/hF$!aCz\bE  y\2mF\--y@*@B@((dBBtw nz $ .x-hF$"bC\cE  \?yB@((dBBQTnz 'tv,NhF	
+   		
+y}@@
+q(  !F$"QCF*haFQF2\		
+uy@@q($ )h`C	$"	T ( ,fD$ (gDB$,FFF *[ ,YiF (T h (`z!zBM % ()$ !hhC	$"hF (m`zB z$!GMHC)hGFO `)h8yG``!h )+ () !arF9y \czB(F$!"hHC$0Z$#ZCk$ !hhC$"iFK`z@`r`h]IU(F	 	pFF *$ ," h ( FbzFPB(F$!HC#hAYRR$#ZC7-`z@`r`h]IU(Fp p
+ FF . /! F0"! ^@@(((  Yd	      `p%p `p%p `p%p 	}*F1Fq*F :F1F FF ! *} -~iz ){N!6h [`@G (o FG (i,&,$ Inz   .iF	y-hF<!ACF\bE !W\xBI))@BBUUnz   .iF	y/hF<!AC
+F\cE !\3\mx@+@BI))@BB..kz)hX $[F !<"FWC zfFXuYB
+ (C @ BD@)	I) )B F  F *l ,j (FM-hG (a'h /`z!zFBY %`F (2  <!.FNC yXXB'B@( (M z)h@GN `)h0yG``!h )2 (0 !arF1y mEczB(F<!"hHC<0Z<#ZC< !hhC<"`z@`r`hA\IT(F F *% ,# h (  F bzFPB(F<!HC#hAYRR<#ZC-`z@`r`h]IU(F  y(  pG pG y ((  pG pGpFB$  $"F(F (   , ( p   pFFBAxBx@B  pGpBL`y ( y (=N0y`q , % ` (0y( eqp@  q   ` (`y"  h{ y  hp%q heqpp#M)y4h] ,lyB 0\ (dBH@x (BJH!h xG(yB p FpF  C H &Ay )xH % h](I h     L  7    $ ,U { ((	(!JIhHGj h8 		B h9
+!	BI C   	B  `{%F(%I"yc1F `{ -	hs   `````h{(I
+hU   `````h](h  $ ,Hv@yB L@ KA"h8 G `pNFthhB  $ ,/F7 {){B F"9F0 (	 ! ViVB`hihB0}hB  $ , FpIFhHh $B    " (&63C}hY			BF
+F0B    ( FppGI &h LhB  $% ,} z ^0@B&FF <B  $ ,0FNF1ihBq}D  $ ,/F7`xixB"` (
+ |*|B F9F0U (p}$0iB  $ , FpFuHtIih %K}B    " (!	Cha			BF
+FB    ((FppG0cIcJih  T}B	  !# )"VBFF	B  ! )0pGTNRMF )N (	z)#IrKI(hIxHCd!FjhhF2B*ihG!F?H (ihh*i@hA;H@hBBLx ( h (*}!F#x( (*}!F5 ()I(h	xHCd!HF*ihFP2Bjhh!FHu (ihh*i@hAH@hBBx (h5 (j}!Fx(N (j}!FI
+H`pG	   h L    @   & pFF!(",M,!)pp @Z 
+i (0 |  p. p ppH hG (-H x ()M!lm FCheH hGH hGH hGH "h )K``HwH x(Ij"CbIle	h FGH hGppJxy*J~ *
+)d!xd	))px xbxK ))/(1KA1h~"Gp/(0A0vpx-H hGK P` PxXTpI	hG (`0 ~(
+I 
+X *@ y ((    %F,F'I
+hR C`r .zH~ )vI! (p(2J PX (-	y))F. (I F	hGF@ih1I{ ) ' ik`0z'h0@{ (# ' ik`0zhF   H hG  iFq HqqqOrrr(u'J.R..l -!h1G(F 0A}jF}s)x )))(VZ |(((N  rJ rG rD |((
+((; r7 r4 r1	 r. |(((' r# r  r ,!h1gGlI F	hG ( iiFk  iks iks  iFaJ hGTIhh@`	F:H h%G (8H x (TJh (o (
+QH $) )OHx+ pPi (()) ))0FF(CHB| *<Ftt0h 2H hG>I	hGp{h{5{vh ,,J9Ih+G8J Fh GF%H hG F4Lf` `r.Her{ass | s r.Is	h FGF r(~+I(H	hGR  ` *  ,a ( ( ( 4  8  0e Pe    ( (    ' X ( `2    a + h patch_PFAL_COEX_MCI.c    + (  -  \  $  ;  t \ ( , HB|*<Dth BhB{h{{H% hGI	hG ,JIhHGJ Fh GFH hG  FL ```rfrHs{as | ss Ir	h FGF r( e(FH hG (H x (H~ ) (lF! F H hG  iFq HqJ!Fh GFH hG (8H x (4 ,2 ]H hGK FPhaiB F!	C8 ]@	 )QBhFH hG  iFqHqq  qaiJy	I	IUh GK"8!hK GH hG (
+H x (HI h`:    pG  pGFHF hG (`H x (\$-#-W INP--OMJ/`iI|0`z	xA)sq{sx)R !isi`I@\s; (t4HpoM/`Oh (qJIhnHGh"|0`8hoR\*sr{s~Jj`h~N1I{ ) !is{Ik	hGs8hyI00 h 0y X! `(tltls!	\0s0 hoI 0y X! M(tlsQi`iI	hGs: FFF*(\Hh|4GJaIhDHGEJ1Fh FGF=H hG\I B[H$[H[IhB8 hF9B20B 3F*F8F~8F F Fz<I 	x B1B7IhyC`!H hG`8p(JF~F ( (HnF hG  iFq HqqJqh1F Gp5I3H`5I4H`6I4H`6I5H`7I5H`7I6H`8I6H`8I7H`9I7H`9I8H`pG +  i   h t \ ( ` *  0e ( ' X   L  xY $ 0  -  0    -  b    d & C C p6   ?q  0h 4h     -     H+         i  pG8M $h~ (6N'& Gd, ov3H@h1HG`ovh~ (+H hG)I ()H x (HiJhi@@$I pJiHhH`JapL!hI C `rH hGH hGH hG #MF-hF GH hGH hG h h@ `pIH`IH`IH`IH`pG0e p  E@` *     (  ( P ` d  (  ( ? ( { ( F 'hFpnH hG (PlH x (LkHlJk"LhBD%F=*xB:x (eKxhjF1F(FG(bK(xh2F !GhFx .\KpFh1F(FG(XHhR C`rbh!hJ`bh!h`hhI`/`o`` `dhHJKJB  FHH=?H.F h6G (!=H x ((F(yAK:H:I!k8K#QhBBY4KIh#B>Ji!h5GM  ,p !ipppiq)y"C)q(I!k&K#Qh'KBF =-~BhR C`rhF`q`0``hh@` IhMMBhd !C`rIh!F`r`0``hh@` IH`IH`pG` *  0h a (       ) patch_PFAL_COEX_MCI_UTIL.c  h 9 *  ( F 0 zB	xN H $hH*h }D-ymD'3;GK!h G! G! G! GGK!h G! Gxh % (@ AI 
+! /  )
+IAd)'!@(($I@F( $mB,(,L`; qN qH hG`!C` !CjK!h GeK!h G! GH x(I	hGpGL h (   ``h (  `` Z  MFF-h	G (+ ,B& /' ,%wM-h	G (qHEh -(F [ lL$h;F	G (  lJ!h1dG  hL $h "1F(F	GdKh"(FG FRH h &FF* , ( SJ!h1KG (! 
+    FOL$h*F9FG LJhG0FFIIH`JIHH`JIIH`KIIH`KIJH`pG  8  LTE OFF LTE IDLE SLEEP  LTE CONNECT SLEEP   LTE INVALID LTE ACTIVE NO CONN NO SLEEP LTE ACTIVE IDLE ]  LTE B7 or B41 ACTIVE    LTE ACTIVE CONN LTE RFU FOR CONNECT SETUP     $,  H H . patch_PFAL_COEX_MWS.c   h . . $H +     . Q   t. I	x )I	hG IH	h	))H HI	hGH hGI
+H`IH`pGT    H     $ T \ I l a T HN $ph!Cp`FO8x(EMy )hGCMN G@Iy 	hG (>J !hFG  8p;H hG;I pph!Cp` 7H@h7M8L ((j@  & Fdd(3H hG (1H hG ( @i (-I	B,H h (
+(j@  (H h ( hG%H hGp FH j@  ,H I x	xMCH hG()i C)a $(i@@ (a FpIH`IH`pG  ` p   ^   ?C     (           (    Hx(H h (  pG )IH`pG$  D  I     FF     !    SIGABRT: Abnormal termination   H		H H	H$	H"	H*Hg@	H@	Hi#	HH%HHHH;HH%	H9%	H	H- H$	HC+ H[ H! H{<H/ HHHDH] Hz HI Hg HUj H}N HaV H_HYH	LH/bHLHrHHM	H	HS	HIHH?	HHH=H	H Hk H;H!$HHEH)H&HHHSHcH#	HRHIH{PHH+wHHH'!H"	HuHHHH[#H"HqVHYpHeHkHH7HCHHHH=HWHHH]HHHyqH	kHH7DH HH+H_IHHHHzH|HIzHwHH{H[UHs	HWH+HHCHYHoHH/H}H~HpHrH]HgHHiHXHZHHuHHHGHHHoHHHg H$H_*H%HHHH}H{HSLH7?HHqNH@	H	Hu H H? H H H H)HH! He=HpHcwHA9	H8	Ha?	
+Y
+Z (A!B"##*@	,@1h3t*N3	 	*4,@1htbt3I *4,l@1ht,t3 O*B#@# ,
+#@#@1h3#%@ #*[*\*]* *#  T,@1h(Tt****TW!+3I,p@1h(Tmu U@'t'%& ,@\%& 0 l, @ %
+$)t,)$"V"BV#6B,XZ Y
+Z ##  &'6#%@t'Aug 14 2014 19:34:52                                 =                                 b  e  h  l  m  o  q  r  v  y  z  |                                                          1  7     sh                                                                          6Hl}OPS_"cm9w;qB'3Tm?2$":U@;2dpFb~$j)x&oT%Sh/PY$Mum;T_(beQ+`z&G@Bm!2Ki6Z+GG2HT9Df:X4mbEuP\g$'}p
\ No newline at end of file
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/target.h android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/target.h
--- android-x86-unpatch/vendor/qcom/proprietary/bt/hci_qcomm_init/target.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/bt/hci_qcomm_init/target.h	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1,83 @@
+#ifndef TARGET_H
+#define TARGET_H
+/*===========================================================================
+
+      T A R G E T   C O N F I G U R A T I O N   H E A D E R   F I L E
+
+DESCRIPTION
+  All the declarations and definitions necessary for general configuration
+  of the DMSS software for a given target environment.
+
+-----------------------------------------------------------------------------
+Copyright (c) 1998-2002 Qualcomm Technologies, Inc.
+All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+-----------------------------------------------------------------------------
+===========================================================================*/
+
+/*===========================================================================
+                      EDIT HISTORY FOR FILE
+
+This section contains comments describing changes made to this file.
+Notice that changes are listed in reverse chronological order.
+
+$Header: //linux/pkgs/proprietary/oncrpc/main/source/inc/target.h#3 $
+
+when       who     what, where, why
+--------   ---     ----------------------------------------------------------
+07/12/02   jct     The appropriate target file is now included via customer.h
+                   in cust*.h.  TG is now fixed to be T_G and all other T_xxx
+                   vars that could be assigned to T_G are deleted.  The use of
+                   TG is deprecated. 
+10/06/00   dsb     The appropriate target file is now included automatically
+                   a make macro. Removed check on T_ACP, T_SMS, and T_SMS_UI.
+                   Cannot remove check on T_AUTH as many files still use this 
+                   instead of FEATURE_AUTH as they should.
+                   Eventually, we want to eliminate T==T_xxx codes, but many
+                   upper layer files still use them, so I have left them in.
+                   When the rest of the DMSS stops using them, they should be
+                   removed here.
+08/13/99   jkl     Included T_Q2
+01/15/99   hrk     Integrating from COMMON_ARM.03.01.00 VU from MSM3000 subsystem.
+                   Re-introduced #defines for all targets. Removal of support for
+                   these targets will be done in the next phase.
+12/16/98   jct     Created for MSM3000+ support
+
+===========================================================================*/
+
+#define T_PC    1       /* PC test software, 80386/80486, running MSDOS  */
+#define T_P     2       /* Portable Phone hardware                       */
+#define T_M     3       /* Mobile Phone hardware                         */
+#define T_REX   4       /* REX test software, 80386/80486, REX and MSDOS */
+#define T_S     5       /* Stretch-portable hardware                     */
+#define T_B2    6       /* Beta II mobile hardware                       */
+#define T_I1    7       /* ISS1 WLL hardware                             */
+#define T_DM    8       /* Diagnostic Monitor                            */
+#define T_G     9       /* Gemini Portable hardware                      */
+#define T_I2    10      /* ISS2 WLL hardware                             */
+#define T_C1    11      /* CSS1 WLL hardware                             */
+#define T_SP    12      /* Service Programming Tool                      */
+#define T_T     13      /* TGP (Third Generation Portable)               */
+#define T_MD    14      /* 1900 MHz Module (Charon)                      */
+#define T_Q     15      /* Q phones (Q-1900, Q-800)                      */
+#define T_O     16      /* Odie (5GP)                                    */
+#define T_Q2    17      /* Q phones (Q-1900, Q-800)                      */             
+
+/* This is deprecated - force to always be T_G
+*/
+#define TG T_G
+
+/* Backward compatibile migration, needs to be eliminated completely
+*/
+#undef T_AUTH
+#ifdef FEATURE_AUTH
+   #define T_AUTH
+#endif
+
+/* All featurization starts from customer.h which includes the appropriate
+**    cust*.h and targ*.h
+*/
+#ifdef CUST_H
+   #include "customer.h"
+#endif
+
+#endif /* TARGET_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/common/inc/armasm.h android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/armasm.h
--- android-x86-unpatch/vendor/qcom/proprietary/common/inc/armasm.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/armasm.h	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1,283 @@
+#ifndef ARMASM_H
+#define ARMASM_H
+/*=============================================================================
+
+                        ARM Assembly Language Definitions
+
+GENERAL DESCRIPTION
+  This file contains assembly language macros for use with the ARM assembler.
+
+
+-----------------------------------------------------------------------------
+Copyright (c) 1998 - 2001 Qualcomm Technologies, Inc.
+All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+-----------------------------------------------------------------------------
+=============================================================================*/
+
+
+/*=============================================================================
+
+                            EDIT HISTORY FOR FILE
+
+$Header: //linux/pkgs/proprietary/oncrpc/main/source/inc/armasm.h#3 $
+
+when       who     what, where, why
+--------   ---     ----------------------------------------------------------
+09/13/05   ck      Copied from 6100 branch
+07/12/02   jct     Removed conditional inclusion of customer.h and target.h
+05/17/01   kar     Bigger SVC stack available to support REX from MSM archive
+01/25/01   day     Merged from MSM5105_COMMON.00.00.05.
+                     Added support for Interworking
+                     Added define for system stack size
+04/02/99    sk     Increased Abort stack size.
+04/02/99    ms     Reduced stack sizes.
+02/03/99    ms     Renamed blx to blatox since blx is a keyword in Assembler
+                   of ARM SDK 2.5
+01/18/99    ms     Moved ARM_TRAP_FRAME related declarations to boot_trap.h.
+                   Moved context frame related macros to rexarm.s.
+                   Incorporated exception frame related macros directly into
+                   boot_abort_handler in bootsys.s.
+12/10/98   jkl     Included r12 in the context frame.
+11/23/98   jkl     Clean up code. Changed save_context_from_task macro.
+10/27/98   jkl     Revised for new context
+09/13/98   hcg     Changed exception/trap frame names
+07/10/98   jct     Revised for coding standard, removed unused code
+01/01/98   bwj     Created
+=============================================================================*/
+
+#include "target.h"
+#include "customer.h"
+
+/*  CPSR Control Masks         */
+#define PSR_Thumb_Mask       0x20
+#define PSR_Fiq_Mask         0x40
+#define PSR_Irq_Mask         0x80
+#define PSR_Mode_Mask        0x1f
+
+/*  Processor mode definitions */
+#define PSR_User             0x10
+#define PSR_Fiq              0x11
+#define PSR_Irq              0x12
+#define PSR_Supervisor       0x13
+#define PSR_Abort            0x17
+#define PSR_Undef            0x1b
+#define PSR_System           0x1f
+#define PSR_Thumb            0x20
+
+/*===========================================================================
+**  GENERAL PURPOSE ASSEMBLY MACROS.
+**=========================================================================*/
+
+#if defined(_ARM_ASM_)
+
+        GBLS    current_node_name
+        GBLS    current_node_type
+        GBLA    current_node_aregcount
+        GBLA    current_node_vregcount
+
+/*===========================================================================
+
+Name: pusha, popa
+
+Description: Readable names for push and pop.
+
+MODE: Any
+STATE: ARM
+
+Registers modified: sp
+
+=============================================================================*/
+
+        MACRO
+        pusha   $stack, $reg
+        str     $reg, [$stack, #-4]!
+        MEND
+
+        MACRO
+        popa    $stack, $reg
+        ldr     $reg, [$stack], #4
+        MEND
+
+/*===========================================================================
+
+Name: Entry_Node, Entry_Node_End
+
+Description: Defines an empty function prolog and epilog of a piece of assembly code.
+             These macros take care of the following:
+               - Exporting the entry point label
+               - Creating a stack frame
+               - Software stack checking
+
+Defined Labels:
+   "node_name" - The main thumb mode entry point of the function.
+   "node_name"_end - A label marking the begining of the function epilog.
+
+Arguments:
+  Leaf_Node
+  Node_Name - The function name of the function to be defined.
+  Leaf_Node_End
+  None
+
+MODE: Any
+STATE: ARM
+
+Registers modified: None
+
+=============================================================================*/
+
+        MACRO
+        ENTRY_NODE $node_name
+current_node_name       SETS    "$node_name"
+        EXPORT  $node_name
+        ALIGN
+        ROUT
+$node_name
+        MEND
+                                        ;  The end of an entry node.
+        MACRO
+        ENTRY_NODE_END
+$current_node_name._exit
+current_node_name       SETS    ""
+        MEND
+
+/*===========================================================================
+
+  Name: Leaf_Node, Leaf_Node_End
+
+  Description: Defines the function prolog and epilog of a function that makes
+               no function calls. These macros take care of the following:
+                 - Exporting the entry point label
+                 - Creating 16 and 32 bit entry points.
+                 - Creating a stack frame
+                 - Software stack checking
+
+  Defined Labels:
+     "node_name" - The main thumb mode entry point of the function.
+     "node_name"_32 - The ARM state entry point to the function.
+     "node_name"_end - A label marking the begining of the function epilog.
+
+  Arguments:
+    Leaf_Node
+     Node_Name - The function name of the function to be defined.
+    Leaf_Node_End
+     None
+
+  MODE: Any
+  STATE: ARM and Thumb state entry points. Code runs in ARM state.
+
+  Registers modified: None
+
+=============================================================================*/
+        MACRO
+        LEAF_NODE $node_name
+current_node_type       SETS    "Leaf"
+        CODE16
+        ENTRY_NODE $node_name
+        bx      pc
+        ALIGN
+        CODE32
+#ifndef __APCS_INTERWORK
+        orr     lr, lr, #0x01
+#endif
+        EXPORT  $node_name._32
+$node_name._32
+        MEND
+
+        MACRO
+        LEAF_NODE_END $node_name
+        ASSERT  "$current_node_type" = "Leaf"
+        ENTRY_NODE_END $node_name
+        bx     lr
+current_node_type       SETS    ""
+        MEND
+
+
+/*===========================================================================
+
+  Name: Leaf_Node_End, Leaf_Node_End_16
+
+  Description: Defines the function prolog and epilog of a Thumb mode only function that makes
+               no function calls. These macros take care of the following:
+                 - Exporting the entry point label
+                 - Creating a 16 bit entry point.
+                 - Creating a stack frame
+                 - Software stack checking
+
+  Defined Labels:
+     "node_name" - The main thumb mode entry point of the function.
+     "node_name"_end - A label marking the begining of the function epilog.
+
+  Arguments:
+    Leaf_Node_16
+     Node_Name - The function name of the function to be defined.
+    Leaf_Node_End_16
+     None
+
+  MODE: Any
+  STATE: Thumb
+
+  Registers modified: None
+
+=============================================================================*/
+
+        MACRO
+        LEAF_NODE_16 $node_name
+current_node_type       SETS    "Leaf16"
+        CODE16
+        ENTRY_NODE $node_name
+        MEND
+
+        MACRO
+        LEAF_NODE_END_16 $node_name
+        ASSERT  "$current_node_type" = "Leaf16"
+        ENTRY_NODE_END $node_name
+        bx     lr
+current_node_type       SETS    ""
+        MEND
+
+
+        MACRO
+        ALTERNATE_ENTRY_16 $node_name
+        ASSERT  "$current_node_type" = "Leaf16"
+        EXPORT $node_name
+$node_name
+        MEND
+
+
+/*===========================================================================
+
+  Name: blatox
+
+  Description: Calls a function from ARM state without having to know whether that
+     that function is ARM or Thumb state code.
+
+  Arguments:
+    destreg - The register that contains the address of the function to be called.
+
+  Registers modified: lr
+
+  MODE: Any
+  STATE: ARM. Can call either ARM or Thumb state functions.
+
+=============================================================================*/
+
+        MACRO
+        blatox     $destreg
+        ROUT
+
+        tst     $destreg, #0x01         /* Test for thumb mode call.  */
+
+        ldrne   lr, =%1
+        ldreq   lr, =%2
+        bx      $destreg
+1
+        CODE16
+        bx      pc
+        ALIGN
+        CODE32
+2
+        MEND
+
+#endif   /* ARM_ASM  */
+
+#endif   /* ARMASM_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/common/inc/comdef.h android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/comdef.h
--- android-x86-unpatch/vendor/qcom/proprietary/common/inc/comdef.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/comdef.h	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1,1288 @@
+#ifndef COMDEF_H
+#define COMDEF_H
+/*===========================================================================
+
+                   S T A N D A R D    D E C L A R A T I O N S
+
+DESCRIPTION
+  This header file contains general types and macros that are of use
+  to all modules.  The values or definitions are dependent on the specified
+  target.  T_WINNT specifies Windows NT based targets, otherwise the
+  default is for ARM targets.
+
+       T_WINNT  Software is hosted on an NT platforn, triggers macro and
+                type definitions, unlike definition above which triggers
+                actual OS calls
+
+DEFINED TYPES
+
+       Name      Definition
+       -------   --------------------------------------------------------
+       byte      8  bit unsigned value
+       word      16 bit unsigned value
+       dword     32 bit unsigned value
+
+       uint1     byte
+       uint2     word
+       uint4     dword
+
+       uint8     8  bit unsigned value
+       uint16    16 bit unsigned value
+       uint32    32 bit unsigned value
+       uint64    64 bit unsigned value
+
+       int8      8  bit signed value
+       int16     16 bit signed value
+       int32     32 bit signed value
+       int 64    64 bit signed value
+
+       sint31    32 bit signed value
+       sint15    16 bit signed value
+       sint7     8  bit signed value
+
+       int1      8  bit signed value
+       int2      16 bit signed value
+       int4      32 bit signed value
+
+       boolean   8 bit boolean value
+
+DEFINED CONSTANTS
+
+       Name      Definition
+       -------   --------------------------------------------------------
+       TRUE      Asserted boolean condition (Logical 1)
+       FALSE     Deasserted boolean condition (Logical 0)
+
+       ON        Asserted condition
+       OFF       Deasserted condition
+
+       NULL      Pointer to nothing
+
+       PACKED    Used to indicate structures which should use packed
+                 alignment
+
+       INLINE    Used to inline functions for compilers which support this
+
+  -----------------------------------------------------------------------------
+  Copyright (c) 1990, 1992-1994, 1997-2007 Qualcomm Technologies, Inc.
+  All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+  -----------------------------------------------------------------------------
+===========================================================================*/
+
+
+/*===========================================================================
+
+                      EDIT HISTORY FOR FILE
+
+This section contains comments describing changes made to this file.
+Notice that changes are listed in reverse chronological order.
+
+$Header: //linux/pkgs/proprietary/oncrpc/main/source/inc/comdef.h#4 $
+
+when       who     what, where, why
+--------   ---     ----------------------------------------------------------
+01/09/06   bfc     Added Pthe OST_ALIGN macro.
+09/22/06    th     Added FIQLOCK_SAV/FIQFREE_SAV macros for Windows Mobile
+05/10/06   taw     Added FIQLOCK_SAV/FIQFREE_SAV macros.
+01/25/06   sam     Added MSM_INTLOCK/MSM_INTFREE macros.
+07/13/05   adm     Merged in changes related to supporting BootLoader compilation
+                   for L4 builds
+07/06/05   ptm     Merge to 6550 for L4.
+06/30/05   adm     Merging in 6800's later changes and made some fixes.
+06/29/05   adm     Merged in 6800 l4 related changes
+02/28/04   jcw     Removed TASKLOCK/TASKFREE definition to INTLOCK/INTFREE for L4.
+02/14/04   hcg     Add TASKLOCK/TASKFREE definition to INTLOCK/INTFREE for L4.
+08/25/04   jac     suppress lint error 413 for FPOS macro
+11/19/03    gr     Added multiple definition protection for the ARR_SIZE
+                   macro.
+10/18/03    gr     Moved TASKLOCK/TASKFREE into this file from rex.h. DMSS
+                   expects to pick these up just by including comdef.h.
+10/17/03    gr     Made inclusion of target.h unconditional (TG is now
+                   deprecated).
+10/16/03    gr     Defined LOCAL away unconditionally. DMSS doesn't build with
+                   LOCAL set to static.
+01/07/04   ajn     Re-integrated 11/14/03 change
+11/20/03   ak      ARR_SIZE conflict with BREW files fixed
+11/14/03   ajn     Removed #include "rex.h" to avoid circular include issue.
+                   Instead, prototypes for rex_int_lock()/rex_int_free()
+                   have been explicitly included for INTLOCK/INTFREE macros.
+06/11/01    gr     Added MOD_BY_POWER_OF_TWO macro.
+04/12/01    sq     Added inpdw and outpdw macros
+           vas     Added solaris support
+04/06/01    gr     Removed the definitions of abs and labs.
+01/25/01   day     Merged from MSM5105_COMMON.00.00.05.
+             Added include for stdlib.h within WINNT ifdef
+       Added support for ARM_ASM
+       Added support SWIG preprocessor.
+09/09/99   tac     Merged in a bunch of panther changes.
+08/11/99   jct     Corrected conditional compilation around labs to check for
+                   labs instead of abs
+06/30/99   jct     Added PC_EMULATOR capability for INTLOCK and INTLOCKSAV
+06/15/99   jct     Cleanup to make work in Windows NT environment.  Addition
+                   of int(n) types where n is 8,16,32,64 and addition of
+                   unit64.  Removal of OS comments and defines as this is replaced
+                   by T_WINNT.  Conditional inclusion of MAX, MIN, labs, abs,
+                   NULL definitions.  Removal of volatile from packed definition
+                   stdlib.h included for Win32 based targets since this replaces several
+                   of the define here.  Changed out uts calls to be comet calls.
+                   Added a defines for Windows NT targets to define away symbols
+                   no longer supported
+04/09/99    ms     Lint cleanup.
+04/01/99    ms     Lint cleanup.
+02/17/99    ms     Parenthesized abs and labs.
+                   Defined __packed to volatile to exploit lint.
+12/16/98   jct     Removed 80186 support
+12/01/98    ms     Removed definition of bsp_io_base.
+11/20/98    ms     Typecast to volatile pointers in inp,outp,inpw and outpw.
+10/10/98   jct     Honing of OS and T_ definitions, added T_WINNT as a target
+                   which triggers something different then which OS since
+                   we may be running REX on an NT platform, but strictly
+                   speaking, the application software is using REX, not NT
+                   as the OS.  Changed ROM for WINNT/ARM targets to be nothing
+                   instead of const
+09/09/98   jct     Updates to merge ARM support with 186 support, added some
+                   new type aliases, added some segmented architecture macros,
+                   updated comments, removed unused code, updated declaration
+                   of inp/outp to have cdecl
+08/01/98   jct     Updates to support ARM processor
+03/25/96   jah     Moved SET_VECT to 80186.h
+02/06/96   fkm     Put ()s around Macros to Make Lint Happy
+01/12/95   jah     Updated dependency in MACRO INTLOCK_SAV / INTFREE_SAV.
+12/20/94   jah     Corrected typo in ARR_SIZE() macro comments
+03/11/94   jah     Added #ifdef _lint of NULL as 0 for near/far lint problem.
+06/11/93   jah     Changed FPOS() to cast the pointer to 'near' to avoid the
+                   compiler complaints about lost segments.
+01/28/93   twp     Added ARR_SIZE macro to return number of array elements.
+07/17/92   jah     Changed int1 from 'char' to 'signed char'
+06/10/92   jah     Added WORD_LO/HI, INC_SAT
+05/19/92   jah     Added header comments for macros & made them lint-friendly
+05/04/92   jah     Added define for ROM
+03/02/92   jah     Added in/outp prototypes, INT* Macro comments w/lint
+02/20/92   arh     Added LOCAL macro and ifdef/endif around file
+
+===========================================================================*/
+
+
+/*===========================================================================
+
+                            Data Declarations
+
+===========================================================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "target.h"
+#include "armasm.h"
+
+#if defined FEATURE_L4  && !defined FEATURE_L4_KERNEL && \
+    !defined BUILD_BOOT_CHAIN && !defined BUILD_BOOT_CHAIN_OEMSBL
+  #ifndef _ARM_ASM_
+    #ifdef FEATURE_QUARTZ_135
+      #include <l4/cust/msm_syscall.h>
+    #else /* FEATURE_QUARTZ_135 */
+     #include <msm/msm_syscall.h>
+    #endif /* FEATURE_QUARTZ_135 */
+  #endif /* _ARM_ASM_ */
+#endif /* FEATURE_L4 && !FEATURE_L4_KERNEL &&
+          !FEATURE_L4_KERNEL && !BUILD_BOOT_CHAIN_OEMSBL */
+
+/* For NT apps we want to use the Win32 definitions and/or those
+** supplied by the Win32 compiler for things like NULL, MAX, MIN
+** abs, labs, etc.
+*/
+#ifdef T_WINNT
+   #ifndef WIN32
+      #define WIN32
+   #endif
+   #include <stdlib.h>
+#endif
+
+/* ------------------------------------------------------------------------
+** Constants
+** ------------------------------------------------------------------------ */
+
+#ifdef TRUE
+#undef TRUE
+#endif
+
+#ifdef FALSE
+#undef FALSE
+#endif
+
+#define TRUE   1   /* Boolean true value. */
+#define FALSE  0   /* Boolean false value. */
+
+#define  ON   1    /* On value. */
+#define  OFF  0    /* Off value. */
+
+#ifdef _lint
+  #define NULL 0
+#endif
+
+#ifndef NULL
+  #define NULL  0
+#endif
+
+/* -----------------------------------------------------------------------
+** Standard Types
+** ----------------------------------------------------------------------- */
+
+/* The following definitions are the same accross platforms.  This first
+** group are the sanctioned types.
+*/
+#ifndef _ARM_ASM_
+typedef  unsigned char      boolean;     /* Boolean value type. */
+
+typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
+typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
+typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
+
+typedef  signed long int    int32;       /* Signed 32 bit value */
+typedef  signed short       int16;       /* Signed 16 bit value */
+typedef  signed char        int8;        /* Signed 8  bit value */
+
+/* This group are the deprecated types.  Their use should be
+** discontinued and new code should use the types above
+*/
+typedef  unsigned char     byte;         /* Unsigned 8  bit value type. */
+typedef  unsigned short    word;         /* Unsinged 16 bit value type. */
+typedef  unsigned long     dword;        /* Unsigned 32 bit value type. */
+
+typedef  unsigned char     uint1;        /* Unsigned 8  bit value type. */
+typedef  unsigned short    uint2;        /* Unsigned 16 bit value type. */
+typedef  unsigned long     uint4;        /* Unsigned 32 bit value type. */
+
+typedef  signed char       int1;         /* Signed 8  bit value type. */
+typedef  signed short      int2;         /* Signed 16 bit value type. */
+typedef  long int          int4;         /* Signed 32 bit value type. */
+
+typedef  signed long       sint31;       /* Signed 32 bit value */
+typedef  signed short      sint15;       /* Signed 16 bit value */
+typedef  signed char       sint7;        /* Signed 8  bit value */
+
+#ifdef FEATURE_WINCE
+  #define WCE_MSG  RETAILMSG
+  #define WCE_MSG6 RETAILMSG
+  #define WCE_MSGT RETAILMSG
+  #define WCE_MSG_SDBG RETAILMSG
+#endif
+/************************** The PACK() macro *****************************
+  This block sets up the semantics for PACK() macro based upon
+  upon the target compiler. PACK() is necessary to ensure portability of C
+  variable/struct/union packing across many platforms.  For example, ARM
+  compilers require the following:
+    typedef __packed struct { ... } foo_t;
+
+  But GCC requires this to achieve the same effect:
+    typedef struct __attribute((__packed__)) struct { ... } foo_t;
+
+  And, of course, Microsoft VC++ requires an alignment #pragma prologue and
+  epilogue. To satisfy all three, the following form is recommended:
+
+    #ifdef _WIN32
+		#pragma pack(push,1) // Save previous, and turn on 1 byte alignment
+    #endif
+
+    typedef PACK(struct)
+    {
+      ...
+    } such_and_such_t;
+
+    typedef PACK(struct)
+    {
+      ...
+    } this_and_that_t;
+
+    typedef PACK(struct)
+    {
+      PACK(struct)
+      {
+        ...
+      } hdr;
+      PACK(union)
+      {
+        such_and_such_t sas;
+        this_and_that_t tat;
+      } payload;
+    } cmd_t;
+
+*********************** BEGIN PACK() Definition ***************************/
+#if defined __GNUC__
+  #define PACK(x)       x __attribute__((__packed__))
+#elif defined __arm
+  #define PACK(x)       __packed x
+#else
+  #error No PACK() macro defined for this compiler
+#endif
+/********************** END PACK() Definition *****************************/
+/* ---------------------------------------------------------------------
+** Compiler Keyword Macros
+** --------------------------------------------------------------------- */
+#if (! defined T_WINNT) && (! defined TARGET_OS_SOLARIS)
+#ifndef SWIG  /* The SWIG preprocessor gets confused by these */
+  /* Non WinNT Targets
+  */
+  typedef  signed long long   int64;       /* Signed 64 bit value */
+  typedef  unsigned long long uint64;      /* Unsigned 64 bit value */
+
+#if defined(__ARMCC_VERSION) 
+  #define PACKED __packed
+  #define PACKED_POST
+  #define ALIGN(__value) __align(__value)
+  #define POST_ALIGN(__value)
+  #define INLINE __inline
+  #define inline __inline
+#else  /* __GNUC__ */
+  #define PACKED 
+  #ifndef FEATURE_WINCE
+    #define ALIGN(__value) __attribute__((__aligned__(__value)))
+    #define POST_ALIGN(__value)
+    #define PACKED_POST    __attribute__((__packed__))
+  #else /* FEATURE_WINCE */
+    #ifdef WINCE_TODO
+      /*----------------------------------------------------------------------
+        Should we be using something closer to the T_WINNT case below?
+      ----------------------------------------------------------------------*/
+    #endif /* WINCE_TODO */
+    #define ALIGN(__value)
+    #define POST_ALIGN(__value)
+    #define PACKED_POST
+    #define INLINE 
+  #endif /* FEATURE_WINCE */
+    
+
+  #ifndef INLINE
+    #define INLINE inline
+  #endif
+#endif /* defined (__GNUC__) */
+
+  #define CDECL
+#endif /* SWIG */
+  #define far
+  #define near
+  #define _far
+  #define _near
+//  #define _cdecl
+  #define cdecl
+  #define _pascal
+  #define _interrupt
+
+#else /* T_WINNT || TARGET_OS_SOLARIS */
+
+  /* WINNT or SOLARIS based targets
+  */
+#if (defined __GNUC__) || (defined TARGET_OS_SOLARIS)
+  typedef long long           int64;
+  typedef unsigned long long  uint64;
+#else
+  typedef  __int64            int64;       /* Signed 64 bit value */
+  typedef  unsigned __int64   uint64;      /* Unsigned 64 bit value */
+#endif
+  #define PACKED
+  #define PACKED_POST
+  #define ALIGN(__value)
+  #define POST_ALIGN(__value)
+  #ifndef INLINE
+
+  /* INLINE is defined to __inline because WINNT targets work fine with it
+   * and defining it to nothing does not work because the inline function
+   * definition is then multiply defined.  Solaris may need a different value.
+   */
+  #define INLINE __inline
+  #endif
+  #ifndef CDECL
+     #define CDECL __cdecl
+  #endif
+  #define _pascal
+  #define _far
+  #define far
+  #define near
+  #define _near
+  #define cdecl
+  #define _cdecl
+  #define _interrupt
+  #define __packed
+  #define _fmemcpy memcpy
+
+#endif /* T_WINNT */
+#endif // #ifndef _ARM_ASM_
+
+/* ----------------------------------------------------------------------
+** Lint does not understand __packed, so we define it away here.  In the
+** past we did this:
+**   This helps us catch non-packed pointers accessing packed structures,
+**   for example, (although lint thinks it is catching non-volatile pointers
+**   accessing volatile structures).
+**   This does assume that volatile is not being used with __packed anywhere
+**   because that would make Lint see volatile volatile (grrr).
+** but found it to be more trouble than it was worth as it would emit bogus
+** errors
+** ---------------------------------------------------------------------- */
+#ifdef _lint
+  #define __packed
+#endif
+
+/* ----------------------------------------------------------------------
+**                          STANDARD MACROS
+** ---------------------------------------------------------------------- */
+
+#ifndef SWIG /* these confuse the SWIG preprocessor and aren't needed for it */
+
+
+/*===========================================================================
+
+MACRO MEM_B
+MACRO MEM_W
+
+DESCRIPTION
+  Take an address and dereference it as a byte/word, allowing access to an
+  arbitrary memory byte/word.
+
+PARAMETERS
+  x     address to be dereferenced
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  MEM_B byte at the given address
+  MEM_W word at the given address
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  MEM_B( x )  ( *( (byte *) (x) ) )
+#define  MEM_W( x )  ( *( (word *) (x) ) )
+
+
+
+/*===========================================================================
+
+MACRO MAX
+MACRO MIN
+
+DESCRIPTION
+  Evaluate the maximum/minimum of 2 specified arguments.
+
+PARAMETERS
+  x     parameter to compare to 'y'
+  y     parameter to compare to 'x'
+
+DEPENDENCIES
+  'x' and 'y' are referenced multiple times, and should remain the same
+  value each time they are evaluated.
+
+RETURN VALUE
+  MAX   greater of 'x' and 'y'
+  MIN   lesser of 'x' and 'y'
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+#ifndef MAX
+   #define  MAX( x, y ) ( ((x) > (y)) ? (x) : (y) )
+#endif
+
+#ifndef MIN
+   #define  MIN( x, y ) ( ((x) < (y)) ? (x) : (y) )
+#endif
+
+
+
+/*===========================================================================
+
+MACRO FPOS
+
+DESCRIPTION
+  This macro computes the offset, in bytes, of a specified field
+  of a specified structure or union type.
+
+PARAMETERS
+  type          type of the structure or union
+  field         field in the structure or union to get the offset of
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  The byte offset of the 'field' in the structure or union of type 'type'.
+
+SIDE EFFECTS
+  The lint error "Warning 545: Suspicious use of &" is suppressed within
+  this macro.  This is due to the desire to have lint not complain when
+  'field' is an array.
+
+===========================================================================*/
+
+#define FPOS( type, field ) \
+    /*lint -e545 */ ( (dword) &(( type *) 0)-> field ) /*lint +e545 */
+
+
+
+/*===========================================================================
+
+MACRO FSIZ
+
+DESCRIPTION
+  This macro computes the size, in bytes, of a specified field
+  of a specified structure or union type.
+
+PARAMETERS
+  type          type of the structure or union
+  field         field in the structure or union to get the size of
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  size in bytes of the 'field' in a structure or union of type 'type'
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define FSIZ( type, field ) sizeof( ((type *) 0)->field )
+
+
+
+/*===========================================================================
+
+MACRO FLIPW
+
+DESCRIPTION
+  Takes a 2 byte array, with the most significant byte first, followed
+  by the least significant byte, and converts the quantity into a word
+  with Intel byte order (LSB first)
+
+PARAMETERS
+  ray   array of 2 bytes to be converted to a word
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  word in Intel byte order comprised of the 2 bytes of ray.
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )
+
+
+
+/*===========================================================================
+
+MACRO FLOPW
+
+DESCRIPTION
+  Reverses bytes of word value and writes them to a 2 byte array.
+  Effectively the reverse of the FLIPW macro.
+
+PARAMETERS
+  ray   array to receive the 2 bytes from 'val'
+  val   word to break into 2 bytes and put into 'ray'
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+#define  FLOPW( ray, val ) \
+  (ray)[0] = ((val) / 256); \
+  (ray)[1] = ((val) & 0xFF)
+
+
+
+/*===========================================================================
+
+MACRO B_PTR
+MACRO W_PTR
+
+DESCRIPTION
+  Casts the address of a specified variable as a pointer to byte/word,
+  allowing byte/word-wise access, e.g.
+  W_PTR ( xyz )[ 2 ] = 0x1234;  -or-    B_PTR ( xyz )[ 2 ] = 0xFF;
+
+PARAMETERS
+  var   the datum to get a word pointer to
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  Word pointer to var
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  B_PTR( var )  ( (byte *) (void *) &(var) )
+#define  W_PTR( var )  ( (word *) (void *) &(var) )
+#define  D_PTR( var )  ( (dword *) (void *) &(var) )
+
+
+/*===========================================================================
+
+MACRO WORD_LO
+MACRO WORD_HI
+
+DESCRIPTION
+  Take a word and extract the least-significant or most-significant byte.
+
+PARAMETERS
+  xxx   word to extract the Low/High from
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  WORD_LO       Least significant byte of xxx.
+  WORD_HI       Most significant byte of xxx.
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  WORD_LO(xxx)  ((byte) ((word)(xxx) & 255))
+#define  WORD_HI(xxx) \
+  /*lint -e572 */  ((byte) ((word)(xxx) >> 8))  /*lint +e572 */
+
+
+/*===========================================================================
+
+MACRO RND8
+
+DESCRIPTION
+  RND8 rounds a number up to the nearest multiple of 8.
+
+PARAMETERS
+  x     Number to be rounded up
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  x rounded up to the nearest multiple of 8.
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define RND8( x )       ((((x) + 7) / 8 ) * 8 )
+
+/* -----------------------------------------------------------------------
+** Temporary inclusion of rex.h because there is code in AMSS that expects
+** to pick up Rex definitions by just including comdef.h.
+** ----------------------------------------------------------------------- */
+//#include "rex.h"
+
+/*===========================================================================
+
+MACRO INTLOCK / INTFREE
+
+DESCRIPTION
+  INTLOCK Saves current interrupt state on stack then informs the kernel
+  not to process interrupts in this thread. One interrupt may still occur, 
+  but it will not be processed until either INTFREE is called or a context 
+  switch to another thread which has interrupts enabled is made.
+
+  INTFREE Restores previous interrupt state from stack. Used in conjunction
+  with INTLOCK.
+
+  INTLOCK/INTFREE may be nested, in which case inner INTLOCK/INTFREE
+  pairs will have no effect.
+
+PARAMETERS
+  None
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  INTLOCK stops interrupt processing.
+  INTFREE restores the interrupt mask saved previously.
+
+===========================================================================*/
+#if defined PC_EMULATOR_H && !defined T_REXNT
+
+   #define PC_EMULATOR_INTLOCK
+   #include PC_EMULATOR_H
+   #undef PC_EMULATOR_INTLOCK
+
+#elif defined T_WINNT || defined FEATURE_ANDROID
+
+   #define INTLOCK()
+   #define INTFREE()
+
+#elif defined FEATURE_WINCE_OAL
+  #define INTLOCK()  INTERRUPTS_OFF()
+  #define INTFREE()  INTERRUPTS_ON()
+#elif !defined _ARM_ASM_ && (!defined FEATURE_L4 || defined FEATURE_L4_KERNEL)
+
+  #ifdef __cplusplus
+    extern "C" {
+  #endif
+      extern dword rex_int_lock( void );
+      extern dword rex_int_free( void );
+#ifdef FEATURE_WINCE
+      extern int rex_ints_are_locked( void );
+#endif
+
+  #ifdef __cplusplus
+    }
+  #endif
+
+  #define  INTLOCK( )  { dword sav = rex_int_lock();
+  #define  INTFREE( )  if(!sav) (void)rex_int_free();}
+
+#endif
+
+
+/*===========================================================================
+
+MACRO MSM_INTLOCK / MSM_INTFREE
+
+DESCRIPTION
+  MSM_INTLOCK Saves current interrupt state on stack then locks interrupts. 
+  No interrupts will be taken until either MSM_INTFREE is called or a context 
+  switch to another thread which has interrupts enabled is made. This
+  macro is slower than INTLOCK and should only be used when interrupt 
+  locking is needed to ensure timing. To simply prevent context switching, 
+  use the INTLOCK/INTFREE macros above.
+
+  MSM_INTFREE Restores previous interrupt state from stack. Used in conjunction
+  with MSM_INTLOCK.
+
+  MSM_INTLOCK/MSM_INTFREE may be nested, in which case inner 
+  MSM_INTLOCK/MSM_INTFREE pairs will have no effect. It may also be nested
+  inside or outside of INTLOCK/INTFREE.
+
+PARAMETERS
+  None
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  MSM_INTLOCK prevents any interrupts from occurring until MSM_INTFREE is
+    called or a context switch to a thread with interrupts enabled is made.
+  MSM_INTFREE restores the interrupt mask saved previously.
+
+===========================================================================*/
+#ifndef _ARM_ASM
+#if defined FEATURE_L4
+  #ifdef __cplusplus
+    extern "C" {
+  #endif
+      extern dword rex_msm_int_lock( void );
+      extern void rex_msm_int_free( dword set );
+  #ifdef __cplusplus
+    }
+  #endif
+
+  #define MSM_INTLOCK()  { dword sav = rex_msm_int_lock();
+  #define MSM_INTFREE()  rex_msm_int_free( sav ); }
+
+#else
+
+  #define MSM_INTLOCK() INTLOCK()
+  #define MSM_INTFREE() INTFREE()
+
+#endif
+#endif
+
+/*===========================================================================
+
+MACRO FIQLOCK / FIQFREE
+
+DESCRIPTION
+  FIQLOCK Saves current FIQ state on stack then disables FIQ interrupts.
+  Used in conjunction with FIQFREE.
+
+  FIQFREE Restores previous FIQ interrupt state from stack.  Used in 
+  conjunction with FIQLOCK.
+
+PARAMETERS
+  None
+
+DEPENDENCIES
+  This is currently only available in L4 based builds.
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  FIQLOCK turns off FIQ interrupts.
+  FIQFREE restores the FIQ interrupt mask saved previously.
+
+===========================================================================*/
+#if defined FEATURE_L4 && !defined _ARM_ASM_
+
+  #ifdef __cplusplus
+    extern "C" {
+  #endif
+      extern dword rex_fiq_op( dword lock );
+  #ifdef __cplusplus
+    }
+  #endif
+
+  #define  FIQLOCK()  { dword sav = rex_fiq_op(1);
+  #define  FIQFREE()  if(!(sav & PSR_Fiq_Mask)) (void)rex_fiq_op(0);}
+    
+#else
+
+  #define FIQLOCK()
+  #define FIQFREE()
+
+#endif
+
+/*===========================================================================
+
+MACRO INTLOCK_SAV / INTFREE_SAV
+
+DESCRIPTION
+  INTLOCK_SAV Saves current interrupt state in specified variable sav_var
+  then disables interrupts.  Used in conjunction with INTFREE_SAV.
+
+  INTFREE_SAV Restores previous interrupt state from specified variable
+  sav_var.  Used in conjunction with INTLOCK_SAV.
+
+PARAMETERS
+  sav_var       Current flags register, including interrupt status
+
+DEPENDENCIES
+  None.
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  INTLOCK_SAV turn off interrupts
+  INTFREE_SAV restore the interrupt mask saved previously
+
+===========================================================================*/
+
+
+#ifdef _lint    /* get lint to 'know' the parameter is accessed */
+
+  #define  INTLOCK_SAV(sav_var)   (sav_var = 1)
+  #define  INTFREE_SAV(sav_var)   (sav_var = sav_var + 1)
+
+#else
+
+   #if defined PC_EMULATOR_H && !defined T_REXNT
+
+      #define PC_EMULATOR_INTLOCKSAV
+      #include PC_EMULATOR_H
+      #undef  PC_EMULATOR_INTLOCKSAV
+
+   #elif defined T_WINNT
+
+     #define  INTLOCK_SAV( sav_var )
+     #define  INTFREE_SAV( sav_var )
+
+#elif !defined _ARM_ASM_ && (!defined FEATURE_L4 || defined FEATURE_L4_KERNEL)
+
+     #define  INTLOCK_SAV( sav_var )  sav_var = rex_int_lock()
+     #define  INTFREE_SAV( sav_var )  if(!sav_var) rex_int_free()
+
+   #endif
+
+#endif /* END if _lint */
+
+/*===========================================================================
+
+MACRO FIQLOCK_SAV / FIQFREE_SAV
+
+DESCRIPTION
+  FIQLOCK Saves current FIQ state in specified variable sav_var 
+  then disables FIQ interrupts.  Used in conjunction with FIQFREE_SAV.
+
+  FIQFREE_SAV Restores previous FIQ interrupt state from specified variable
+  sav_var.  Used in conjunction with FIQLOCK_SAV.
+
+PARAMETERS
+  sav_var       Current flags register, including interrupt status
+
+DEPENDENCIES
+  This is currently only available in L4 based builds.
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  FIQLOCK_SAV turns off FIQ interrupts.
+  FIQFREE_SAV restores the FIQ interrupt mask saved previously.
+
+===========================================================================*/
+#ifdef _lint    /* get lint to 'know' the parameter is accessed */
+
+  #define  FIQLOCK_SAV(sav_var)   (sav_var = 1)
+  #define  FIQFREE_SAV(sav_var)   (sav_var = sav_var + 1)
+
+#else
+
+  #if defined FEATURE_L4 && !defined _ARM_ASM_
+  
+    #ifdef __cplusplus
+      extern "C" {
+    #endif
+        extern dword rex_fiq_op( dword lock );
+    #ifdef __cplusplus
+      }
+    #endif
+  
+    #define  FIQLOCK_SAV(sav_var)  (sav_var = rex_fiq_op(1))
+    #define  FIQFREE_SAV(sav_var)  if(!(sav_var & PSR_Fiq_Mask)) \
+                                      (void)rex_fiq_op(0)
+
+  #elif defined FEATURE_WINCE
+
+    #define  FIQLOCK_SAV(sav_var)  (sav_var = FIQLockSave())
+    #define  FIQFREE_SAV(sav_var)  if(!(sav_var & 0x40)) (void)FIQLockRestore()
+
+  #else
+  
+    #define FIQLOCK_SAV()
+    #define FIQFREE_SAV()
+  
+  #endif
+  
+#endif
+
+
+/*===========================================================================
+MACRO TASKLOCK/TASKFREE/TASKLOCK_SAV/TASKFREE_SAV
+
+DESCRIPTION
+  TASKLOCK prevents context switching from the point at which it is invoked
+  until a matching TASKFREE is invoked.  While task locked, the current task
+  is guaranteed to not be replaced by a different task, even if the other
+  task has a higher priority.  However, TASKLOCK does not block interrupts
+  from occurring.  An ISR will pre-empt the task, but even if the ISR causes
+  a higher priority task to become ready, control will still resume at the
+  interrupted task.
+
+  Note that a rex-wait() while a TASKLOCK is in effect will not work as
+  normal, as the calling task will not be suspended.
+
+  Also, TASKLOCK/TASKFREE have no effect if called from within an ISR.
+
+  TASKFREE re-enables context switching.
+
+  TASKLOCK_SAV and TASKFREE_SAV are similar to TASKLOCK and TASKFREE
+  respectively, except that the TASKFREE_SAV that matches a TASKLOCK_SAV
+  does not have to be at the same static scope within a function. This
+  makes it easier, for instance, to enable task scheduling and return from
+  the middle of a function.
+
+===========================================================================*/
+#ifdef T_WINNT
+#ifdef __cplusplus
+   extern "C" {
+#endif
+   unsigned char rexnt_is_rex_thread( void );
+#ifdef __cplusplus
+   }
+#endif
+   /* tasks must not be locked by non-REX threads */
+#define TASKLOCK( ) {\
+   unsigned char REXNT_IS_REX_THREAD=rexnt_is_rex_thread();\
+   if ( REXNT_IS_REX_THREAD ) rex_task_lock( ); {
+
+#define TASKFREE( ) \
+   } if ( REXNT_IS_REX_THREAD ) rex_task_free( ); }
+
+#else
+
+#define TASKLOCK( ) { rex_task_lock( );
+
+#define TASKFREE( ) rex_task_free( ); }
+
+#define TASKLOCK_SAV( ) rex_task_lock( )
+
+#define TASKFREE_SAV( ) rex_task_free( )
+
+#endif /* T_WINNT */
+
+/*===========================================================================
+
+MACRO UPCASE
+
+DESCRIPTION
+  Convert a character to uppercase, the character does not have to
+  be printable or a letter.
+
+PARAMETERS
+  c             Character to be converted
+
+DEPENDENCIES
+  'c' is referenced multiple times, and should remain the same value
+  each time it is evaluated.
+
+RETURN VALUE
+  Uppercase equivalent of the character parameter
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  UPCASE( c ) ( ((c) >= 'a' && (c) <= 'z') ? ((c) - 0x20) : (c) )
+
+
+/*===========================================================================
+
+MACRO DECCHK
+MACRO HEXCHK
+
+DESCRIPTION
+  These character attribute macros are similar to the standard 'C' macros
+  (isdec and ishex), but do not rely on the character attributes table used
+  by Microsoft 'C'.
+
+PARAMETERS
+  c             Character to be examined
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  DECCHK        True if the character is a decimal digit, else False
+  HEXCHK        True if the chacters is a hexidecimal digit, else False
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+
+#define  DECCHK( c ) ((c) >= '0' && (c) <= '9')
+
+#define  HEXCHK( c ) ( ((c) >= '0' && (c) <= '9') ||\
+                       ((c) >= 'A' && (c) <= 'F') ||\
+                       ((c) >= 'a' && (c) <= 'f') )
+
+
+/*===========================================================================
+
+MACRO INC_SAT
+
+DESCRIPTION
+  Increment a value, but saturate it at its maximum positive value, do not
+  let it wrap back to 0 (unsigned) or negative (signed).
+
+PARAMETERS
+  val           value to be incremented with saturation
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  val
+
+SIDE EFFECTS
+  val is updated to the new value
+
+===========================================================================*/
+
+#define  INC_SAT( val )  (val = ((val)+1 > (val)) ? (val)+1 : (val))
+
+
+/*===========================================================================
+
+MACRO ARR_SIZE
+
+DESCRIPTION
+  Return the number of elements in an array.
+
+PARAMETERS
+  a             array name
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  Number of elements in array a
+
+SIDE EFFECTS
+  None.
+
+===========================================================================*/
+#if !defined(ARR_SIZE)
+#define  ARR_SIZE( a )  ( sizeof( (a) ) / sizeof( (a[0]) ) )
+#endif
+/*===========================================================================
+                     MACRO MOD_BY_POWER_OF_TWO
+
+     Will calculate x % y, where x is a non-negative integer and
+     y is a power of 2 from 2^0..2^32.
+
+     Will work for 2^0, 2^1, 2^2, 2^3, 2^4, ... 2^32
+      ie.            1,   2,   4,   8,  16, ... 4294967296
+===========================================================================*/
+
+#define MOD_BY_POWER_OF_TWO( val, mod_by ) \
+           ( (dword)(val) & (dword)((mod_by)-1) )
+
+/* -------------------------------------------------------------------------
+**                       Debug Declarations
+** ------------------------------------------------------------------------- */
+
+/* Define 'SHOW_STAT' in order to view static's as globals
+** (e.g. cl /DSHOW_STAT foo.c) If 'SHOW_STAT' is not defined,
+** it gets defined as 'static'
+*/
+#ifdef LOCAL
+   #undef LOCAL
+#endif
+
+/* Permanently turn on SHOW_STAT since this has always been the case anyway
+*/
+#define SHOW_STAT
+
+#ifdef SHOW_STAT
+  #define LOCAL
+#else
+  #define LOCAL static
+#endif
+
+/* Provide a new macro that will hopefully be used correctly to conditionally
+** turn static on/off
+*/
+#ifdef GLOBALIZE_STATIC
+   #define STATIC
+#else
+   #define STATIC static
+#endif
+
+
+/*===========================================================================
+
+                      FUNCTION DECLARATIONS
+
+===========================================================================*/
+
+
+
+/*===========================================================================
+
+FUNCTION inp, outp, inpw, outpw, inpdw, outpdw
+
+DESCRIPTION
+  IN/OUT port macros for byte and word ports, typically inlined by compilers
+  which support these routines
+
+PARAMETERS
+  inp(   xx_addr )
+  inpw(  xx_addr )
+  inpdw( xx_addr )
+  outp(   xx_addr, xx_byte_val  )
+  outpw(  xx_addr, xx_word_val  )
+  outpdw( xx_addr, xx_dword_val )
+      xx_addr      - Address of port to read or write (may be memory mapped)
+      xx_byte_val  - 8 bit value to write
+      xx_word_val  - 16 bit value to write
+      xx_dword_val - 32 bit value to write
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  inp/inpw/inpdw: the byte, word or dword read from the given address
+  outp/outpw/outpdw: the byte, word or dword written to the given address
+
+SIDE EFFECTS
+  None.
+
+===========================================================================*/
+
+#ifdef PC_EMULATOR_H
+
+  /* For PC emulation, include a header which defines inp/outp/inpw/outpw
+  ** with the semantics above
+  */
+  #define PC_EMULATOR_IO
+  #include PC_EMULATOR_H
+  #undef  PC_EMULATOR_IO
+
+#else
+
+  /* ARM based targets use memory mapped i/o, so the inp/outp calls are
+  ** macroized to access memory directly
+  */
+
+  #define inp(port)         (*((volatile byte *) (port)))
+  #define inpw(port)        (*((volatile word *) (port)))
+  #define inpdw(port)       (*((volatile dword *)(port)))
+
+  #define outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val)))
+  #define outpw(port, val)  (*((volatile word *) (port)) = ((word) (val)))
+  #define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
+
+#endif
+
+
+/*===========================================================================
+
+FUNCTION enable, disable
+
+DESCRIPTION
+  Interrupt enable and disable routines.  Enable should cause the CPU to
+  allow interrupts and disable should cause the CPU to disallow
+  interrupts
+
+PARAMETERS
+  None
+
+DEPENDENCIES
+  None
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  None.
+
+===========================================================================*/
+
+#ifndef T_WINNT
+
+  #if !defined _ARM_ASM_
+    /* ARM has no such definition, so we provide one here to enable/disable
+    ** interrupts
+    */
+    #define _disable() (void)rex_int_lock()
+    #define _enable()  (void)rex_int_free()
+
+  #endif
+#endif
+
+#endif /* SWIG */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* COMDEF_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/common/inc/common_log.h android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/common_log.h
--- android-x86-unpatch/vendor/qcom/proprietary/common/inc/common_log.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/common_log.h	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1,41 @@
+#ifndef COMMON_LOG_H
+#define COMMON_LOG_H
+/*==========================================================================
+
+  -----------------------------------------------------------------------------
+  Copyright (c) 2012 Qualcomm Technologies, Inc.
+  All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+  -----------------------------------------------------------------------------
+
+===========================================================================*/
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef LOGE
+#define LOGE ALOGE
+#endif
+
+#ifndef LOGW
+#define LOGW ALOGW
+#endif
+
+#ifndef LOGD
+#define LOGD ALOGD
+#endif
+
+#ifndef LOGV
+#define LOGV ALOGV
+#endif
+
+#ifndef LOGI
+#define LOGI ALOGI
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* COMMON_LOG_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/common/inc/customer.h android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/customer.h
--- android-x86-unpatch/vendor/qcom/proprietary/common/inc/customer.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/customer.h	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1,11 @@
+/******************************************************************************
+ ----------------------------------------------------------------------------
+ Copyright (c) 2007 Qualcomm Technologies, Inc.
+ All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+ ----------------------------------------------------------------------------
+*******************************************************************************/
+
+#ifndef CUSTOMER_H
+#define CUSTOMER_H
+
+#endif /* CUSTOMER_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/common/inc/rex.h android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/rex.h
--- android-x86-unpatch/vendor/qcom/proprietary/common/inc/rex.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/rex.h	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1,15 @@
+#ifndef REX_H
+#define REX_H
+
+/*----------------------------------------------------------------------------
+ Copyright (c) 2007 Qualcomm Technologies, Inc.  All Rights Reserved.  
+ Qualcomm Technologies Proprietary and Confidential. 
+----------------------------------------------------------------------------*/
+  
+/// @todo RJS !!! Fix
+#define rex_task_lock( )
+#define rex_task_free( )
+typedef dword   rex_sigs_type;
+
+
+#endif /* REX_H */
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/common/inc/stringl.h android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/stringl.h
--- android-x86-unpatch/vendor/qcom/proprietary/common/inc/stringl.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/stringl.h	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1 @@
+#include "string.h"
diff -Naur android-x86-unpatch/vendor/qcom/proprietary/common/inc/target.h android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/target.h
--- android-x86-unpatch/vendor/qcom/proprietary/common/inc/target.h	1970-01-01 08:00:00.000000000 +0800
+++ android-x86-patched_update_kk/vendor/qcom/proprietary/common/inc/target.h	2014-12-23 15:38:42.416459700 +0800
@@ -0,0 +1,83 @@
+#ifndef TARGET_H
+#define TARGET_H
+/*===========================================================================
+
+      T A R G E T   C O N F I G U R A T I O N   H E A D E R   F I L E
+
+DESCRIPTION
+  All the declarations and definitions necessary for general configuration
+  of the DMSS software for a given target environment.
+
+-----------------------------------------------------------------------------
+Copyright (c) 1998-2002 Qualcomm Technologies, Inc.
+All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
+-----------------------------------------------------------------------------
+===========================================================================*/
+
+/*===========================================================================
+                      EDIT HISTORY FOR FILE
+
+This section contains comments describing changes made to this file.
+Notice that changes are listed in reverse chronological order.
+
+$Header: //linux/pkgs/proprietary/oncrpc/main/source/inc/target.h#3 $
+
+when       who     what, where, why
+--------   ---     ----------------------------------------------------------
+07/12/02   jct     The appropriate target file is now included via customer.h
+                   in cust*.h.  TG is now fixed to be T_G and all other T_xxx
+                   vars that could be assigned to T_G are deleted.  The use of
+                   TG is deprecated. 
+10/06/00   dsb     The appropriate target file is now included automatically
+                   a make macro. Removed check on T_ACP, T_SMS, and T_SMS_UI.
+                   Cannot remove check on T_AUTH as many files still use this 
+                   instead of FEATURE_AUTH as they should.
+                   Eventually, we want to eliminate T==T_xxx codes, but many
+                   upper layer files still use them, so I have left them in.
+                   When the rest of the DMSS stops using them, they should be
+                   removed here.
+08/13/99   jkl     Included T_Q2
+01/15/99   hrk     Integrating from COMMON_ARM.03.01.00 VU from MSM3000 subsystem.
+                   Re-introduced #defines for all targets. Removal of support for
+                   these targets will be done in the next phase.
+12/16/98   jct     Created for MSM3000+ support
+
+===========================================================================*/
+
+#define T_PC    1       /* PC test software, 80386/80486, running MSDOS  */
+#define T_P     2       /* Portable Phone hardware                       */
+#define T_M     3       /* Mobile Phone hardware                         */
+#define T_REX   4       /* REX test software, 80386/80486, REX and MSDOS */
+#define T_S     5       /* Stretch-portable hardware                     */
+#define T_B2    6       /* Beta II mobile hardware                       */
+#define T_I1    7       /* ISS1 WLL hardware                             */
+#define T_DM    8       /* Diagnostic Monitor                            */
+#define T_G     9       /* Gemini Portable hardware                      */
+#define T_I2    10      /* ISS2 WLL hardware                             */
+#define T_C1    11      /* CSS1 WLL hardware                             */
+#define T_SP    12      /* Service Programming Tool                      */
+#define T_T     13      /* TGP (Third Generation Portable)               */
+#define T_MD    14      /* 1900 MHz Module (Charon)                      */
+#define T_Q     15      /* Q phones (Q-1900, Q-800)                      */
+#define T_O     16      /* Odie (5GP)                                    */
+#define T_Q2    17      /* Q phones (Q-1900, Q-800)                      */             
+
+/* This is deprecated - force to always be T_G
+*/
+#define TG T_G
+
+/* Backward compatibile migration, needs to be eliminated completely
+*/
+#undef T_AUTH
+#ifdef FEATURE_AUTH
+   #define T_AUTH
+#endif
+
+/* All featurization starts from customer.h which includes the appropriate
+**    cust*.h and targ*.h
+*/
+#ifdef CUST_H
+   #include "customer.h"
+#endif
+
+#endif /* TARGET_H */
